type Query {
  applicationRound(
    """The ID of the object"""
    id: ID!
  ): ApplicationRoundNode
  applicationRounds(
    first: Int
    last: Int
    offset: Int
    after: String
    before: String
    pk: [Int]
    name: String
    active: Boolean
    ongoing: Boolean
    onlyWithPermissions: Boolean

    """Ordering"""
    orderBy: [ApplicationRoundOrderingChoices]
  ): ApplicationRoundNodeConnection
  application(
    """The ID of the object"""
    id: ID!
  ): ApplicationNode
  applications(
    first: Int
    last: Int
    offset: Int
    after: String
    before: String
    pk: [Int]
    applicationRound: Int
    user: Int
    applicantType: [ReserveeType]
    status: [ApplicationStatusChoice]
    unit: [Int]
    unitGroup: [Int]
    textSearch: String

    """Ordering"""
    orderBy: [ApplicationOrderingChoices]
  ): ApplicationNodeConnection
  applicationSection(
    """The ID of the object"""
    id: ID!
  ): ApplicationSectionNode
  applicationSections(
    first: Int
    last: Int
    offset: Int
    after: String
    before: String
    pk: [Int]
    extUuid: UUID
    name: String
    user: Int
    application: Int
    applicationRound: Int
    reservationUnit: [Int]
    unit: [Int]
    unitGroup: [Int]
    applicantType: [ReserveeType]
    status: [ApplicationSectionStatusChoice]
    applicationStatus: [ApplicationStatusChoice]
    priority: [Priority]
    preferredOrder: [Int]
    includePreferredOrder10OrHigher: Boolean
    municipality: [MunicipalityChoice]
    ageGroup: [Int]
    purpose: [Int]
    textSearch: String
    hasAllocations: Boolean

    """Ordering"""
    orderBy: [ApplicationSectionOrderingChoices]
  ): ApplicationSectionNodeConnection
  allocatedTimeSlots(
    first: Int
    last: Int
    offset: Int
    after: String
    before: String
    pk: [Int]
    dayOfTheWeek: [Weekday]
    applicationRound: Int
    applicationSectionStatus: [ApplicationSectionStatusChoice]
    applicantType: [ReserveeType]
    allocatedUnit: [Int]
    unitGroup: [Int]
    allocatedReservationUnit: [Int]
    accessCodeState: [AccessCodeState]
    textSearch: String

    """Ordering"""
    orderBy: [AllocatedTimeSlotOrderingChoices]
  ): AllocatedTimeSlotNodeConnection

  """
  Return all allocations that affect allocations for given reservation unit (through space hierarchy or common resource) during the given time period.
  """
  affectingAllocatedTimeSlots(reservationUnit: Int!, beginDate: Date!, endDate: Date!): [AllocatedTimeSlotNode!]
  unit(
    """The ID of the object"""
    id: ID!
  ): UnitNode
  units(
    first: Int
    last: Int
    offset: Int
    after: String
    before: String
    nameFi: String
    nameFi_Icontains: String
    nameFi_Istartswith: String
    nameSv: String
    nameSv_Icontains: String
    nameSv_Istartswith: String
    nameEn: String
    nameEn_Icontains: String
    nameEn_Istartswith: String
    pk: [Int]
    unitGroup: [Int]
    onlyWithPermission: Boolean
    publishedReservationUnits: Boolean
    ownReservations: Boolean
    onlyDirectBookable: Boolean
    onlySeasonalBookable: Boolean

    """Ordering"""
    orderBy: [UnitOrderingChoices]
  ): UnitNodeConnection
  unitsAll(
    nameFi: String
    nameFi_Icontains: String
    nameFi_Istartswith: String
    nameSv: String
    nameSv_Icontains: String
    nameSv_Istartswith: String
    nameEn: String
    nameEn_Icontains: String
    nameEn_Istartswith: String
    unit: [Int]
    unitGroup: [Int]
    onlyWithPermission: Boolean
    publishedReservationUnits: Boolean
    ownReservations: Boolean
    onlyDirectBookable: Boolean
    onlySeasonalBookable: Boolean

    """Ordering"""
    orderBy: [UnitOrderingChoices]
  ): [UnitAllNode!]
  resource(
    """The ID of the object"""
    id: ID!
  ): ResourceNode
  resources(
    first: Int
    last: Int
    offset: Int
    after: String
    before: String
    nameFi: String
    nameFi_Icontains: String
    nameFi_Istartswith: String
    nameSv: String
    nameSv_Icontains: String
    nameSv_Istartswith: String
    nameEn: String
    nameEn_Icontains: String
    nameEn_Istartswith: String
    pk: [Int]
    onlyWithPermission: Boolean

    """Ordering"""
    orderBy: [ResourceOrderingChoices]
  ): ResourceNodeConnection
  space(
    """The ID of the object"""
    id: ID!
  ): SpaceNode
  spaces(
    first: Int
    last: Int
    offset: Int
    after: String
    before: String
    nameFi: String
    nameFi_Icontains: String
    nameFi_Istartswith: String
    nameSv: String
    nameSv_Icontains: String
    nameSv_Istartswith: String
    nameEn: String
    nameEn_Icontains: String
    nameEn_Istartswith: String
    pk: [Int]
    onlyWithPermission: Boolean

    """Ordering"""
    orderBy: [SpaceOrderingChoices]
  ): SpaceNodeConnection
  equipment(
    """The ID of the object"""
    id: ID!
  ): EquipmentNode
  equipments(
    first: Int
    last: Int
    offset: Int
    after: String
    before: String
    name: String
    name_Icontains: String
    name_Istartswith: String
    nameFi: String
    nameFi_Icontains: String
    nameFi_Istartswith: String
    nameSv: String
    nameSv_Icontains: String
    nameSv_Istartswith: String
    nameEn: String
    nameEn_Icontains: String
    nameEn_Istartswith: String
    pk: [Int]
    rankGte: Int
    rankLte: Int

    """Ordering"""
    orderBy: [EquipmentOrderingChoices]
  ): EquipmentNodeConnection
  equipmentsAll(
    """Ordering"""
    orderBy: [EquipmentOrderingChoices]
  ): [EquipmentAllNode!]
  equipmentCategory(
    """The ID of the object"""
    id: ID!
  ): EquipmentCategoryNode
  equipmentCategories(
    first: Int
    last: Int
    offset: Int
    after: String
    before: String
    pk: [Int]

    """Ordering"""
    orderBy: [EquipmentCategoryOrderingChoices]
  ): EquipmentCategoryNodeConnection
  reservationUnit(
    """The ID of the object"""
    id: ID!
  ): ReservationUnitNode
  reservationUnits(
    first: Int
    last: Int
    offset: Int
    after: String
    before: String
    nameFi: String
    nameFi_Icontains: String
    nameFi_Istartswith: String
    nameSv: String
    nameSv_Icontains: String
    nameSv_Istartswith: String
    nameEn: String
    nameEn_Icontains: String
    nameEn_Istartswith: String
    descriptionFi: String
    descriptionFi_Icontains: String
    descriptionSv: String
    descriptionSv_Icontains: String
    descriptionEn: String
    descriptionEn_Icontains: String
    pk: [Int]
    uuid: UUID
    tprekId: String
    tprekDepartmentId: String
    unit: [Int]
    unitGroup: [Int]
    reservationUnitType: [Int]
    minPersonsGte: Int
    minPersonsLte: Int
    maxPersonsGte: Int
    maxPersonsLte: Int
    personsAllowed: Int
    textSearch: String
    intendedUses: [Int]
    equipments: [Int]
    isDraft: Boolean
    isVisible: Boolean
    applicationRound: [Int]
    surfaceAreaGte: Int
    surfaceAreaLte: Int
    rankGte: Int
    rankLte: Int
    typeRankGte: Int
    typeRankLte: Int
    reservationKind: ReservationKind
    publishingState: [ReservationUnitPublishingState]
    reservationState: [ReservationUnitReservationState]
    reservationForm: [ReservationFormType]
    accessType: [AccessType]
    accessTypeBeginDate: Date
    accessTypeEndDate: Date
    onlyWithPermission: Boolean
    onlyWithManagePermission: Boolean
    reservableDateStart: Date
    reservableDateEnd: Date
    reservableTimeStart: Time
    reservableTimeEnd: Time
    reservableMinimumDurationMinutes: Int
    showOnlyReservable: Boolean
    calculateFirstReservableTime: Boolean

    """Ordering"""
    orderBy: [ReservationUnitOrderingChoices]
  ): ReservationUnitNodeConnection
  reservationUnitsAll(
    nameFi: String
    nameFi_Icontains: String
    nameFi_Istartswith: String
    nameSv: String
    nameSv_Icontains: String
    nameSv_Istartswith: String
    nameEn: String
    nameEn_Icontains: String
    nameEn_Istartswith: String
    unit: [Int]
    onlyWithPermission: Boolean
    onlyWithManagePermission: Boolean

    """Ordering"""
    orderBy: [ReservationUnitOrderingChoices]
  ): [ReservationUnitAllNode!]
  reservationUnitTypes(
    first: Int
    last: Int
    offset: Int
    after: String
    before: String
    nameFi: String
    nameFi_Icontains: String
    nameFi_Istartswith: String
    nameSv: String
    nameSv_Icontains: String
    nameSv_Istartswith: String
    nameEn: String
    nameEn_Icontains: String
    nameEn_Istartswith: String
    pk: [Int]

    """Ordering"""
    orderBy: [ReservationUnitTypeOrderingChoices]
  ): ReservationUnitTypeNodeConnection
  reservationUnitCancellationRules(
    first: Int
    last: Int
    offset: Int
    after: String
    before: String
    name: String
    pk: [Int]

    """Ordering"""
    orderBy: [ReservationUnitCancellationRuleOrderingChoices]
  ): ReservationUnitCancellationRuleNodeConnection
  taxPercentages(
    first: Int
    last: Int
    offset: Int
    after: String
    before: String
    value: Decimal
    pk: [Int]

    """Ordering"""
    orderBy: [TaxPercentageOrderingChoices]
  ): TaxPercentageNodeConnection
  metadataSets(first: Int, last: Int, offset: Int, after: String, before: String): ReservationMetadataSetNodeConnection
  intendedUses(
    first: Int
    last: Int
    offset: Int
    after: String
    before: String
    nameFi: String
    nameEn: String
    nameSv: String
    pk: [Int]

    """Ordering"""
    orderBy: [IntendedUseOrderingChoices]
  ): IntendedUseNodeConnection
  reservation(
    """The ID of the object"""
    id: ID!
  ): ReservationNode
  reservations(
    first: Int
    last: Int
    offset: Int
    after: String
    before: String
    pk: [Int]
    extUuid: UUID
    reservationUnits: [Int]
    unit: [Int]
    user: [Int]
    reservationUnitType: [Int]
    reservationSeries: [Int]
    reservationUnitNameFi: String
    reservationUnitNameEn: String
    reservationUnitNameSv: String
    beginDate: Date
    endDate: Date
    createdAtGte: Date
    createdAtLte: Date
    priceGte: Decimal
    priceLte: Decimal
    applyingForFreeOfCharge: Boolean
    isRecurring: Boolean
    requested: Boolean
    onlyWithPermission: Boolean
    onlyWithHandlingPermission: Boolean
    state: [ReservationStateChoice]
    reservationType: [ReservationTypeChoice]
    orderStatus: [OrderStatusWithFree]
    textSearch: String

    """Ordering"""
    orderBy: [ReservationOrderingChoices]
  ): ReservationNodeConnection

  """
  Find all reservations that affect other reservations through the space hierarchy or a common resource.
  """
  affectingReservations(
    """
    Reservations should contain at least one reservation unit that belongs to any of these units.
    """
    forUnits: [Int] = []

    """Reservations should contain at least one these reservation units."""
    forReservationUnits: [Int] = []
    pk: [Int]
    extUuid: UUID
    reservationUnits: [Int]
    unit: [Int]
    user: [Int]
    reservationUnitType: [Int]
    reservationSeries: [Int]
    reservationUnitNameFi: String
    reservationUnitNameEn: String
    reservationUnitNameSv: String
    beginDate: Date
    endDate: Date
    createdAtGte: Date
    createdAtLte: Date
    priceGte: Decimal
    priceLte: Decimal
    applyingForFreeOfCharge: Boolean
    isRecurring: Boolean
    requested: Boolean
    onlyWithPermission: Boolean
    onlyWithHandlingPermission: Boolean
    state: [ReservationStateChoice]
    reservationType: [ReservationTypeChoice]
    orderStatus: [OrderStatusWithFree]
    textSearch: String

    """Ordering"""
    orderBy: [ReservationOrderingChoices]
  ): [ReservationNode!]
  reservationSeries(
    """The ID of the object"""
    id: ID!
  ): ReservationSeriesNode
  pagedReservationSeries(
    first: Int
    last: Int
    offset: Int
    after: String
    before: String
    name: String
    pk: [Int]
    extUuid: UUID
    beginDate: Date
    endDate: Date
    beginTime: Time
    endTime: Time
    user: ID
    reservationUnitNameFi: String
    reservationUnitNameEn: String
    reservationUnitNameSv: String
    unit: [ID]
    reservationUnit: [ID]
    reservationUnitType: [ID]

    """Ordering"""
    orderBy: [ReservationSeriesOrderingChoices]
  ): ReservationSeriesNodeConnection
  rejectedOccurrence(
    """The ID of the object"""
    id: ID!
  ): RejectedOccurrenceNode
  rejectedOccurrences(
    first: Int
    last: Int
    offset: Int
    after: String
    before: String
    pk: [Int]
    reservationSeries: Int
    applicationRound: Int
    reservationUnit: [Int]
    unit: [Int]
    unitGroup: [Int]
    textSearch: String

    """Ordering"""
    orderBy: [RejectedOccurrenceOrderingChoices]
  ): RejectedOccurrenceNodeConnection
  reservationCancelReasons: [ReservationCancelReasonType!]!
  reservationDenyReasons(
    first: Int
    last: Int
    offset: Int
    after: String
    before: String
    reason: String
    pk: [Int]

    """Ordering"""
    orderBy: [ReservationDenyReasonOrderingChoices]
  ): ReservationDenyReasonNodeConnection
  reservationPurposes(
    first: Int
    last: Int
    offset: Int
    after: String
    before: String
    nameFi: String
    nameEn: String
    nameSv: String
    pk: [Int]

    """Ordering"""
    orderBy: [ReservationPurposeOrderingChoices]
  ): ReservationPurposeNodeConnection
  ageGroups(first: Int, last: Int, offset: Int, after: String, before: String): AgeGroupNodeConnection
  order(orderUuid: String!): PaymentOrderNode
  user(
    """The ID of the object"""
    id: ID!
  ): UserNode
  currentUser: UserNode
  checkPermissions(permission: UserPermissionChoice!, units: [Int!], requireAll: Boolean = false): PermissionCheckerType

  """
  Get information about a user from Helsinki profile. If user is not a profile user, still return data stored in our database, e.g. first and last name. Use only one of 'reservation_pk' or 'application_pk' to select the user. This determines the required permissions to view the user's data.
  """
  profileData(
    """View profile data for this application's user."""
    applicationPk: Int

    """View profile data for this reservation's user."""
    reservationPk: Int
  ): HelsinkiProfileDataNode
  termsOfUse(
    first: Int
    last: Int
    offset: Int
    after: String
    before: String
    pk: [String]
    termsType: TermsOfUseTypeChoices

    """Ordering"""
    orderBy: [TermsOfUseOrderingChoices]
  ): TermsOfUseNodeConnection
  bannerNotification(
    """The ID of the object"""
    id: ID!
  ): BannerNotificationNode
  bannerNotifications(
    first: Int
    last: Int
    offset: Int
    after: String
    before: String
    name: String
    target: BannerNotificationTarget
    isActive: Boolean
    isVisible: Boolean

    """Ordering"""
    orderBy: [BannerNotificationOrderingChoices]
  ): BannerNotificationNodeConnection
  unitGroups(
    first: Int
    last: Int
    offset: Int
    after: String
    before: String
    nameFi: String
    nameFi_Icontains: String
    nameFi_Istartswith: String
    nameSv: String
    nameSv_Icontains: String
    nameSv_Istartswith: String
    nameEn: String
    nameEn_Icontains: String
    nameEn_Istartswith: String
    pk: [Int]
    onlyWithPermission: Boolean
    applicationRound: Int

    """Ordering"""
    orderBy: [UnitGroupOrderingChoices]
  ): UnitGroupNodeConnection
}

type ApplicationRoundNode implements Node {
  nameFi: String
  nameEn: String
  nameSv: String
  criteriaFi: String
  criteriaEn: String
  criteriaSv: String
  notesWhenApplyingFi: String
  notesWhenApplyingEn: String
  notesWhenApplyingSv: String
  applicationPeriodBeginsAt: DateTime!
  applicationPeriodEndsAt: DateTime!
  reservationPeriodBeginDate: Date!
  reservationPeriodEndDate: Date!
  publicDisplayBeginsAt: DateTime!
  publicDisplayEndsAt: DateTime!
  handledAt: DateTime
  sentAt: DateTime
  reservationUnits(
    nameFi: String
    nameFi_Icontains: String
    nameFi_Istartswith: String
    nameSv: String
    nameSv_Icontains: String
    nameSv_Istartswith: String
    nameEn: String
    nameEn_Icontains: String
    nameEn_Istartswith: String
    descriptionFi: String
    descriptionFi_Icontains: String
    descriptionSv: String
    descriptionSv_Icontains: String
    descriptionEn: String
    descriptionEn_Icontains: String
    pk: [Int]
    uuid: UUID
    tprekId: String
    tprekDepartmentId: String
    unit: [Int]
    unitGroup: [Int]
    reservationUnitType: [Int]
    minPersonsGte: Int
    minPersonsLte: Int
    maxPersonsGte: Int
    maxPersonsLte: Int
    personsAllowed: Int
    textSearch: String
    intendedUses: [Int]
    equipments: [Int]
    isDraft: Boolean
    isVisible: Boolean
    applicationRound: [Int]
    surfaceAreaGte: Int
    surfaceAreaLte: Int
    rankGte: Int
    rankLte: Int
    typeRankGte: Int
    typeRankLte: Int
    reservationKind: ReservationKind
    publishingState: [ReservationUnitPublishingState]
    reservationState: [ReservationUnitReservationState]
    reservationForm: [ReservationFormType]
    accessType: [AccessType]
    accessTypeBeginDate: Date
    accessTypeEndDate: Date
    onlyWithPermission: Boolean
    onlyWithManagePermission: Boolean
    reservableDateStart: Date
    reservableDateEnd: Date
    reservableTimeStart: Time
    reservableTimeEnd: Time
    reservableMinimumDurationMinutes: Int
    showOnlyReservable: Boolean
    calculateFirstReservableTime: Boolean

    """Ordering"""
    orderBy: [ReservationUnitOrderingChoices]
  ): [ReservationUnitNode!]!
  purposes(
    nameFi: String
    nameEn: String
    nameSv: String
    pk: [Int]

    """Ordering"""
    orderBy: [ReservationPurposeOrderingChoices]
  ): [ReservationPurposeNode!]!
  termsOfUse: TermsOfUseNode

  """The ID of the object"""
  id: ID!
  status: ApplicationRoundStatusChoice!
  statusTimestamp: DateTime
  reservationCreationStatus: ApplicationRoundReservationCreationStatusChoice!
  isSettingHandledAllowed: Boolean!
  applicationsCount: Int!
  reservationUnitCount: Int!
  pk: Int
}

"""An object with an ID"""
interface Node {
  """The ID of the object"""
  id: ID!
}

"""
The `DateTime` scalar type represents a DateTime
value as specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar DateTime

"""
The `Date` scalar type represents a Date
value as specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar Date

type ReservationUnitNode implements Node {
  extUuid: UUID!
  rank: Int!
  nameFi: String
  nameEn: String
  nameSv: String
  descriptionFi: String
  descriptionEn: String
  descriptionSv: String
  contactInformation: String!
  notesWhenApplyingFi: String
  notesWhenApplyingEn: String
  notesWhenApplyingSv: String
  reservationPendingInstructionsFi: String
  reservationPendingInstructionsEn: String
  reservationPendingInstructionsSv: String
  reservationConfirmedInstructionsFi: String
  reservationConfirmedInstructionsEn: String
  reservationConfirmedInstructionsSv: String
  reservationCancelledInstructionsFi: String
  reservationCancelledInstructionsEn: String
  reservationCancelledInstructionsSv: String
  surfaceArea: Int
  minPersons: Int
  maxPersons: Int
  maxReservationsPerUser: Int
  reservationsMinDaysBefore: Int
  reservationsMaxDaysBefore: Int
  reservationBeginsAt: DateTime
  reservationEndsAt: DateTime
  publishBeginsAt: DateTime
  publishEndsAt: DateTime
  minReservationDuration: Duration
  maxReservationDuration: Duration
  bufferTimeBefore: Duration!
  bufferTimeAfter: Duration!
  isDraft: Boolean!
  isArchived: Boolean!
  requireAdultReservee: Boolean!
  requireReservationHandling: Boolean!
  reservationBlockWholeDay: Boolean!
  canApplyFreeOfCharge: Boolean!
  allowReservationsWithoutOpeningHours: Boolean!
  authentication: AuthenticationType!
  reservationStartInterval: ReservationStartInterval!
  reservationKind: ReservationKind!
  reservationForm: ReservationFormType!
  searchTerms: [String!]!
  unit: UnitNode!
  reservationUnitType: ReservationUnitTypeNode
  cancellationRule: ReservationUnitCancellationRuleNode
  metadataSet: ReservationMetadataSetNode
  cancellationTerms: TermsOfUseNode
  serviceSpecificTerms: TermsOfUseNode
  pricingTerms: TermsOfUseNode
  paymentTerms: TermsOfUseNode
  paymentProduct: PaymentProductNode
  paymentMerchant: PaymentMerchantNode
  spaces(
    nameFi: String
    nameFi_Icontains: String
    nameFi_Istartswith: String
    nameSv: String
    nameSv_Icontains: String
    nameSv_Istartswith: String
    nameEn: String
    nameEn_Icontains: String
    nameEn_Istartswith: String
    pk: [Int]
    onlyWithPermission: Boolean

    """Ordering"""
    orderBy: [SpaceOrderingChoices]
  ): [SpaceNode!]!
  resources(
    nameFi: String
    nameFi_Icontains: String
    nameFi_Istartswith: String
    nameSv: String
    nameSv_Icontains: String
    nameSv_Istartswith: String
    nameEn: String
    nameEn_Icontains: String
    nameEn_Istartswith: String
    pk: [Int]
    onlyWithPermission: Boolean

    """Ordering"""
    orderBy: [ResourceOrderingChoices]
  ): [ResourceNode!]!
  intendedUses(
    nameFi: String
    nameEn: String
    nameSv: String
    pk: [Int]

    """Ordering"""
    orderBy: [IntendedUseOrderingChoices]
  ): [IntendedUseNode!]!
  equipments(
    name: String
    name_Icontains: String
    name_Istartswith: String
    nameFi: String
    nameFi_Icontains: String
    nameFi_Istartswith: String
    nameSv: String
    nameSv_Icontains: String
    nameSv_Istartswith: String
    nameEn: String
    nameEn_Icontains: String
    nameEn_Istartswith: String
    pk: [Int]
    rankGte: Int
    rankLte: Int

    """Ordering"""
    orderBy: [EquipmentOrderingChoices]
  ): [EquipmentNode!]!
  applicationRounds(
    pk: [Int]
    name: String
    active: Boolean
    ongoing: Boolean
    onlyWithPermissions: Boolean

    """Ordering"""
    orderBy: [ApplicationRoundOrderingChoices]
  ): [ApplicationRoundNode!]!
  applicationRoundTimeSlots: [ApplicationRoundTimeSlotNode!]!
  reservations(
    pk: [Int]
    extUuid: UUID
    reservationUnits: [Int]
    unit: [Int]
    user: [Int]
    reservationUnitType: [Int]
    reservationSeries: [Int]
    reservationUnitNameFi: String
    reservationUnitNameEn: String
    reservationUnitNameSv: String
    beginDate: Date
    endDate: Date
    createdAtGte: Date
    createdAtLte: Date
    priceGte: Decimal
    priceLte: Decimal
    applyingForFreeOfCharge: Boolean
    isRecurring: Boolean
    requested: Boolean
    onlyWithPermission: Boolean
    onlyWithHandlingPermission: Boolean
    state: [ReservationStateChoice]
    reservationType: [ReservationTypeChoice]
    orderStatus: [OrderStatusWithFree]
    textSearch: String

    """Ordering"""
    orderBy: [ReservationOrderingChoices]
  ): [ReservationNode!]
  accessTypes(
    pk: [Int]
    isActiveOrFuture: Boolean

    """Ordering"""
    orderBy: [ReservationUnitAccessTypeOrderingChoices]
  ): [ReservationUnitAccessTypeNode!]!
  images: [ReservationUnitImageNode!]!
  pricings: [ReservationUnitPricingNode!]!

  """The ID of the object"""
  id: ID!
  publishingState: ReservationUnitPublishingState!
  reservationState: ReservationUnitReservationState!
  isClosed: Boolean!
  firstReservableDatetime: DateTime
  effectiveAccessType: AccessType
  haukiUrl: String
  reservableTimeSpans(startDate: Date!, endDate: Date!): [ReservableTimeSpanType!]
  numActiveUserReservations: Int!
  calculatedSurfaceArea: Int!
  currentAccessType: AccessType
  pk: Int
}

"""
Leverages the internal Python implementation of UUID (uuid.UUID) to provide native UUID objects
in fields, resolvers and input.
"""
scalar UUID

"""Represents a DurationField value as an integer in seconds."""
scalar Duration

"""An enumeration."""
enum AuthenticationType {
  """Weak"""
  WEAK

  """Strong"""
  STRONG
}

"""An enumeration."""
enum ReservationStartInterval {
  """15 minutes"""
  INTERVAL_15_MINS

  """30 minutes"""
  INTERVAL_30_MINS

  """60 minutes"""
  INTERVAL_60_MINS

  """90 minutes"""
  INTERVAL_90_MINS

  """2 hours"""
  INTERVAL_120_MINS

  """3 hours"""
  INTERVAL_180_MINS

  """4 hours"""
  INTERVAL_240_MINS

  """5 hours"""
  INTERVAL_300_MINS

  """6 hours"""
  INTERVAL_360_MINS

  """7 hours"""
  INTERVAL_420_MINS
}

"""An enumeration."""
enum ReservationKind {
  DIRECT
  SEASON
  DIRECT_AND_SEASON
}

"""Reservation forms for that are supported by the system."""
enum ReservationFormType {
  CONTACT_INFO_FORM
  RESERVEE_INFO_FORM
  PURPOSE_FORM
  AGE_GROUP_FORM
}

type UnitNode implements Node {
  tprekId: String
  nameFi: String
  nameEn: String
  nameSv: String
  descriptionFi: String
  descriptionEn: String
  descriptionSv: String
  shortDescriptionFi: String
  shortDescriptionEn: String
  shortDescriptionSv: String
  webPage: String!
  email: String!
  phone: String!
  addressStreetFi: String
  addressStreetEn: String
  addressStreetSv: String
  addressZip: String!
  addressCityFi: String
  addressCityEn: String
  addressCitySv: String
  paymentMerchant: PaymentMerchantNode
  reservationUnits(
    nameFi: String
    nameFi_Icontains: String
    nameFi_Istartswith: String
    nameSv: String
    nameSv_Icontains: String
    nameSv_Istartswith: String
    nameEn: String
    nameEn_Icontains: String
    nameEn_Istartswith: String
    descriptionFi: String
    descriptionFi_Icontains: String
    descriptionSv: String
    descriptionSv_Icontains: String
    descriptionEn: String
    descriptionEn_Icontains: String
    pk: [Int]
    uuid: UUID
    tprekId: String
    tprekDepartmentId: String
    unit: [Int]
    unitGroup: [Int]
    reservationUnitType: [Int]
    minPersonsGte: Int
    minPersonsLte: Int
    maxPersonsGte: Int
    maxPersonsLte: Int
    personsAllowed: Int
    textSearch: String
    intendedUses: [Int]
    equipments: [Int]
    isDraft: Boolean
    isVisible: Boolean
    applicationRound: [Int]
    surfaceAreaGte: Int
    surfaceAreaLte: Int
    rankGte: Int
    rankLte: Int
    typeRankGte: Int
    typeRankLte: Int
    reservationKind: ReservationKind
    publishingState: [ReservationUnitPublishingState]
    reservationState: [ReservationUnitReservationState]
    reservationForm: [ReservationFormType]
    accessType: [AccessType]
    accessTypeBeginDate: Date
    accessTypeEndDate: Date
    onlyWithPermission: Boolean
    onlyWithManagePermission: Boolean
    reservableDateStart: Date
    reservableDateEnd: Date
    reservableTimeStart: Time
    reservableTimeEnd: Time
    reservableMinimumDurationMinutes: Int
    showOnlyReservable: Boolean
    calculateFirstReservableTime: Boolean

    """Ordering"""
    orderBy: [ReservationUnitOrderingChoices]
  ): [ReservationUnitNode!]!
  spaces(
    nameFi: String
    nameFi_Icontains: String
    nameFi_Istartswith: String
    nameSv: String
    nameSv_Icontains: String
    nameSv_Istartswith: String
    nameEn: String
    nameEn_Icontains: String
    nameEn_Istartswith: String
    pk: [Int]
    onlyWithPermission: Boolean

    """Ordering"""
    orderBy: [SpaceOrderingChoices]
  ): [SpaceNode!]!
  unitGroups(
    nameFi: String
    nameFi_Icontains: String
    nameFi_Istartswith: String
    nameSv: String
    nameSv_Icontains: String
    nameSv_Istartswith: String
    nameEn: String
    nameEn_Icontains: String
    nameEn_Istartswith: String
    pk: [Int]
    onlyWithPermission: Boolean
    applicationRound: Int

    """Ordering"""
    orderBy: [UnitGroupOrderingChoices]
  ): [UnitGroupNode!]!

  """The ID of the object"""
  id: ID!
  pk: Int
}

type PaymentMerchantNode implements Node {
  name: String!

  """The ID of the object"""
  id: ID!
  pk: UUID!
}

"""An enumeration."""
enum ReservationUnitPublishingState {
  DRAFT
  SCHEDULED_PUBLISHING
  SCHEDULED_HIDING
  SCHEDULED_PERIOD
  HIDDEN
  PUBLISHED
  ARCHIVED
}

"""An enumeration."""
enum ReservationUnitReservationState {
  SCHEDULED_RESERVATION
  SCHEDULED_PERIOD
  RESERVABLE
  SCHEDULED_CLOSING
  RESERVATION_CLOSED
}

"""How is the reservee able to enter the space in their reservation unit?"""
enum AccessType {
  ACCESS_CODE
  OPENED_BY_STAFF
  PHYSICAL_KEY
  UNRESTRICTED
}

"""Time scalar that can parse time-strings from database."""
scalar Time

"""Ordering fields for the 'ReservationUnit' model."""
enum ReservationUnitOrderingChoices {
  pkAsc
  pkDesc
  nameFiAsc
  nameFiDesc
  nameEnAsc
  nameEnDesc
  nameSvAsc
  nameSvDesc
  typeFiAsc
  typeFiDesc
  typeEnAsc
  typeEnDesc
  typeSvAsc
  typeSvDesc
  unitNameFiAsc
  unitNameFiDesc
  unitNameEnAsc
  unitNameEnDesc
  unitNameSvAsc
  unitNameSvDesc
  maxPersonsAsc
  maxPersonsDesc
  surfaceAreaAsc
  surfaceAreaDesc
  rankAsc
  rankDesc
  typeRankAsc
  typeRankDesc
}

type SpaceNode implements Node {
  nameFi: String
  nameEn: String
  nameSv: String
  surfaceArea: Int
  maxPersons: Int
  code: String!
  parent: SpaceNode
  unit: UnitNode!
  resources(
    nameFi: String
    nameFi_Icontains: String
    nameFi_Istartswith: String
    nameSv: String
    nameSv_Icontains: String
    nameSv_Istartswith: String
    nameEn: String
    nameEn_Icontains: String
    nameEn_Istartswith: String
    pk: [Int]
    onlyWithPermission: Boolean

    """Ordering"""
    orderBy: [ResourceOrderingChoices]
  ): [ResourceNode!]!
  children(
    nameFi: String
    nameFi_Icontains: String
    nameFi_Istartswith: String
    nameSv: String
    nameSv_Icontains: String
    nameSv_Istartswith: String
    nameEn: String
    nameEn_Icontains: String
    nameEn_Istartswith: String
    pk: [Int]
    onlyWithPermission: Boolean

    """Ordering"""
    orderBy: [SpaceOrderingChoices]
  ): [SpaceNode!]

  """The ID of the object"""
  id: ID!
  pk: Int
}

type ResourceNode implements Node {
  nameFi: String
  nameEn: String
  nameSv: String
  locationType: ResourceLocationType!
  space: SpaceNode

  """The ID of the object"""
  id: ID!
  pk: Int
}

"""An enumeration."""
enum ResourceLocationType {
  FIXED
  MOVABLE
}

"""Ordering fields for the 'Resource' model."""
enum ResourceOrderingChoices {
  pkAsc
  pkDesc
}

"""Ordering fields for the 'Space' model."""
enum SpaceOrderingChoices {
  pkAsc
  pkDesc
}

type UnitGroupNode implements Node {
  nameFi: String
  nameEn: String
  nameSv: String
  units(
    nameFi: String
    nameFi_Icontains: String
    nameFi_Istartswith: String
    nameSv: String
    nameSv_Icontains: String
    nameSv_Istartswith: String
    nameEn: String
    nameEn_Icontains: String
    nameEn_Istartswith: String
    pk: [Int]
    unitGroup: [Int]
    onlyWithPermission: Boolean
    publishedReservationUnits: Boolean
    ownReservations: Boolean
    onlyDirectBookable: Boolean
    onlySeasonalBookable: Boolean

    """Ordering"""
    orderBy: [UnitOrderingChoices]
  ): [UnitNode!]!

  """The ID of the object"""
  id: ID!
  pk: Int
}

"""Ordering fields for the 'Unit' model."""
enum UnitOrderingChoices {
  pkAsc
  pkDesc
  nameFiAsc
  nameFiDesc
  nameEnAsc
  nameEnDesc
  nameSvAsc
  nameSvDesc
  rankAsc
  rankDesc
  reservationCountAsc
  reservationCountDesc
  reservationUnitsCountAsc
  reservationUnitsCountDesc
  unitGroupNameFiAsc
  unitGroupNameFiDesc
  unitGroupNameEnAsc
  unitGroupNameEnDesc
  unitGroupNameSvAsc
  unitGroupNameSvDesc
}

"""Ordering fields for the 'UnitGroup' model."""
enum UnitGroupOrderingChoices {
  pkAsc
  pkDesc
  nameFiAsc
  nameFiDesc
  nameEnAsc
  nameEnDesc
  nameSvAsc
  nameSvDesc
}

type ReservationUnitTypeNode implements Node {
  rank: Int!
  nameFi: String
  nameEn: String
  nameSv: String

  """The ID of the object"""
  id: ID!
  pk: Int
}

type ReservationUnitCancellationRuleNode implements Node {
  nameFi: String
  nameEn: String
  nameSv: String
  canBeCancelledTimeBefore: Duration

  """The ID of the object"""
  id: ID!
  pk: Int
}

type ReservationMetadataSetNode implements Node {
  name: String!
  supportedFields: [ReservationMetadataFieldNode!]!
  requiredFields: [ReservationMetadataFieldNode!]!

  """The ID of the object"""
  id: ID!
  pk: Int
}

type ReservationMetadataFieldNode implements Node {
  fieldName: String!

  """The ID of the object"""
  id: ID!
  pk: Int
}

type TermsOfUseNode implements Node {
  nameFi: String
  nameEn: String
  nameSv: String
  textFi: String
  textEn: String
  textSv: String
  termsType: TermsOfUseTypeChoices!

  """The ID of the object"""
  id: ID!
  pk: String
}

"""An enumeration."""
enum TermsOfUseTypeChoices {
  """Generic terms"""
  GENERIC_TERMS

  """Payment terms"""
  PAYMENT_TERMS

  """Cancellation terms"""
  CANCELLATION_TERMS

  """Reservation series terms"""
  RECURRING_TERMS

  """Service-specific terms"""
  SERVICE_TERMS

  """Pricing terms"""
  PRICING_TERMS
}

type PaymentProductNode implements Node {
  merchant: PaymentMerchantNode

  """The ID of the object"""
  id: ID!
  pk: UUID!
}

type IntendedUseNode implements Node {
  rank: Int!
  nameFi: String
  nameEn: String
  nameSv: String

  """The ID of the object"""
  id: ID!
  imageUrl: String
  smallUrl: String
  pk: Int
}

"""Ordering fields for the 'IntendedUse' model."""
enum IntendedUseOrderingChoices {
  rankAsc
  rankDesc
  nameFiAsc
  nameFiDesc
  nameEnAsc
  nameEnDesc
  nameSvAsc
  nameSvDesc
}

type EquipmentNode implements Node {
  nameFi: String
  nameEn: String
  nameSv: String
  category: EquipmentCategoryNode!

  """The ID of the object"""
  id: ID!
  pk: Int
}

type EquipmentCategoryNode implements Node {
  nameFi: String
  nameEn: String
  nameSv: String

  """The ID of the object"""
  id: ID!
  pk: Int
}

"""Ordering fields for the 'Equipment' model."""
enum EquipmentOrderingChoices {
  nameAsc
  nameDesc
  nameFiAsc
  nameFiDesc
  nameEnAsc
  nameEnDesc
  nameSvAsc
  nameSvDesc
  categoryRankAsc
  categoryRankDesc
}

"""Ordering fields for the 'ApplicationRound' model."""
enum ApplicationRoundOrderingChoices {
  pkAsc
  pkDesc
}

type ApplicationRoundTimeSlotNode implements Node {
  weekday: Weekday!
  isClosed: Boolean!
  reservableTimes: [TimeSlotType]!

  """The ID of the object"""
  id: ID!
  pk: Int
}

"""An enumeration."""
enum Weekday {
  MONDAY
  TUESDAY
  WEDNESDAY
  THURSDAY
  FRIDAY
  SATURDAY
  SUNDAY
}

type TimeSlotType {
  begin: Time!
  end: Time!
}

type ReservationNode implements Node {
  extUuid: UUID!
  name: String
  description: String
  numPersons: Int
  state: ReservationStateChoice
  type: ReservationTypeChoice
  municipality: MunicipalityChoice
  handlingDetails: String
  workingMemo: String
  cancelDetails: String
  cancelReason: ReservationCancelReasonChoice
  beginsAt: DateTime!
  endsAt: DateTime!
  bufferTimeBefore: Duration!
  bufferTimeAfter: Duration!
  handledAt: DateTime
  createdAt: DateTime
  accessType: AccessType
  accessCodeGeneratedAt: DateTime
  accessCodeIsActive: Boolean
  price: Decimal
  unitPrice: Decimal
  taxPercentageValue: Decimal
  applyingForFreeOfCharge: Boolean
  freeOfChargeReason: String
  reserveeIdentifier: String
  reserveeFirstName: String
  reserveeLastName: String
  reserveeEmail: String
  reserveePhone: String
  reserveeOrganisationName: String
  reserveeAddressZip: String
  reserveeType: ReserveeType
  reservationUnit: ReservationUnitNode!
  user: UserNode
  reservationSeries: ReservationSeriesNode
  denyReason: ReservationDenyReasonNode
  purpose: ReservationPurposeNode
  ageGroup: AgeGroupNode
  paymentOrder: PaymentOrderNode

  """The ID of the object"""
  id: ID!
  reserveeName: String
  isBlocked: Boolean!
  isHandled: Boolean
  accessCodeShouldBeActive: Boolean
  isAccessCodeIsActiveCorrect: Boolean
  calendarUrl: String

  """
  Which reservation units' reserveability is affected by this reservation?
  """
  affectedReservationUnits: [Int]

  """
  Details on the pricing that should be currently applied to this reservation.
  """
  appliedPricing: AppliedPricingInfo

  """
  Info fetched from Pindora API. Cached per reservation for 30s. Please don't use this when filtering multiple reservations, queries to Pindora are not optimized.
  """
  pindoraInfo: PindoraReservationInfoType
  priceNet: Decimal
  pk: Int
}

"""An enumeration."""
enum ReservationStateChoice {
  CREATED
  CANCELLED
  REQUIRES_HANDLING
  WAITING_FOR_PAYMENT
  CONFIRMED
  DENIED
}

"""An enumeration."""
enum ReservationTypeChoice {
  NORMAL
  BLOCKED
  STAFF
  BEHALF
  SEASONAL
}

"""Municipality choices"""
enum MunicipalityChoice {
  HELSINKI
  OTHER
}

"""Reasons why user has cancelled their reservation"""
enum ReservationCancelReasonChoice {
  CHANGE_OF_PLANS
  FOUND_ANOTHER_SPACE_ELSEWHERE
  FOUND_ANOTHER_SPACE_VARAAMO
  UNSUITABLE_SPACE
  PROCESSING_TIME_TOO_LONG
  OTHER
  NOT_PAID
}

"""The `Decimal` scalar type represents a python Decimal."""
scalar Decimal

"""An enumeration."""
enum ReserveeType {
  INDIVIDUAL
  COMPANY
  NONPROFIT
}

type UserNode implements Node {
  """
  Designates that this user has all permissions without explicitly assigning them.
  """
  isSuperuser: Boolean!

  """Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only."""
  username: String!
  firstName: String!
  lastName: String!
  email: String!
  uuid: UUID!
  dateOfBirth: Date
  reservationNotification: ReservationNotification
  generalRoles: [GeneralRoleNode!]!
  unitRoles: [UnitRoleNode!]!

  """The ID of the object"""
  id: ID!
  name: String!
  isAdAuthenticated: Boolean!
  isStronglyAuthenticated: Boolean!
  isInternalUser: Boolean!
  pk: Int
}

"""When user wants to receive reservation notification emails."""
enum ReservationNotification {
  ALL
  ONLY_HANDLING_REQUIRED
  NONE
}

type GeneralRoleNode implements Node {
  user: UserNode!
  role: UserRoleChoice!
  assigner: UserNode
  createdAt: DateTime!
  updatedAt: DateTime!

  """The ID of the object"""
  id: ID!
  permissions: [UserPermissionChoice!]!
}

"""An enumeration."""
enum UserRoleChoice {
  """Admin"""
  ADMIN

  """Handler"""
  HANDLER

  """Viewer"""
  VIEWER

  """Reserver"""
  RESERVER

  """Notification manager"""
  NOTIFICATION_MANAGER
}

"""An enumeration."""
enum UserPermissionChoice {
  CAN_CREATE_STAFF_RESERVATIONS
  CAN_MANAGE_APPLICATIONS
  CAN_MANAGE_NOTIFICATIONS
  CAN_MANAGE_RESERVATIONS
  CAN_MANAGE_RESERVATION_RELATED_DATA
  CAN_MANAGE_RESERVATION_UNITS
  CAN_VIEW_APPLICATIONS
  CAN_VIEW_RESERVATIONS
  CAN_VIEW_USERS
}

type UnitRoleNode implements Node {
  user: UserNode!
  role: UserRoleChoice!
  units(
    nameFi: String
    nameFi_Icontains: String
    nameFi_Istartswith: String
    nameSv: String
    nameSv_Icontains: String
    nameSv_Istartswith: String
    nameEn: String
    nameEn_Icontains: String
    nameEn_Istartswith: String
    pk: [Int]
    unitGroup: [Int]
    onlyWithPermission: Boolean
    publishedReservationUnits: Boolean
    ownReservations: Boolean
    onlyDirectBookable: Boolean
    onlySeasonalBookable: Boolean

    """Ordering"""
    orderBy: [UnitOrderingChoices]
  ): [UnitNode!]!
  unitGroups(
    nameFi: String
    nameFi_Icontains: String
    nameFi_Istartswith: String
    nameSv: String
    nameSv_Icontains: String
    nameSv_Istartswith: String
    nameEn: String
    nameEn_Icontains: String
    nameEn_Istartswith: String
    pk: [Int]
    onlyWithPermission: Boolean
    applicationRound: Int

    """Ordering"""
    orderBy: [UnitGroupOrderingChoices]
  ): [UnitGroupNode!]!
  assigner: UserNode
  createdAt: DateTime!
  updatedAt: DateTime!

  """The ID of the object"""
  id: ID!
  permissions: [UserPermissionChoice!]!
}

type ReservationSeriesNode implements Node {
  extUuid: UUID!
  createdAt: DateTime!
  name: String!
  description: String!
  beginDate: Date!
  beginTime: Time!
  endDate: Date!
  endTime: Time!
  recurrenceInDays: Int
  weekdays: [Weekday]!
  reservationUnit: ReservationUnitNode!
  user: UserNode!
  allocatedTimeSlot: AllocatedTimeSlotNode
  ageGroup: AgeGroupNode
  rejectedOccurrences(
    pk: [Int]
    reservationSeries: Int
    applicationRound: Int
    reservationUnit: [Int]
    unit: [Int]
    unitGroup: [Int]
    textSearch: String

    """Ordering"""
    orderBy: [RejectedOccurrenceOrderingChoices]
  ): [RejectedOccurrenceNode!]!
  reservations(
    pk: [Int]
    extUuid: UUID
    reservationUnits: [Int]
    unit: [Int]
    user: [Int]
    reservationUnitType: [Int]
    reservationSeries: [Int]
    reservationUnitNameFi: String
    reservationUnitNameEn: String
    reservationUnitNameSv: String
    beginDate: Date
    endDate: Date
    createdAtGte: Date
    createdAtLte: Date
    priceGte: Decimal
    priceLte: Decimal
    applyingForFreeOfCharge: Boolean
    isRecurring: Boolean
    requested: Boolean
    onlyWithPermission: Boolean
    onlyWithHandlingPermission: Boolean
    state: [ReservationStateChoice]
    reservationType: [ReservationTypeChoice]
    orderStatus: [OrderStatusWithFree]
    textSearch: String

    """Ordering"""
    orderBy: [ReservationOrderingChoices]
  ): [ReservationNode!]!

  """The ID of the object"""
  id: ID!
  accessType: AccessTypeWithMultivalued!
  usedAccessTypes: [AccessType]!
  shouldHaveActiveAccessCode: Boolean!
  isAccessCodeIsActiveCorrect: Boolean!

  """
  Info fetched from Pindora API. Cached per reservation for 30s. Please don't use this when filtering multiple series, queries to Pindora are not optimized.
  """
  pindoraInfo: PindoraSeriesInfoType
  pk: Int
}

type AllocatedTimeSlotNode implements Node {
  dayOfTheWeek: Weekday!
  beginTime: Time!
  endTime: Time!
  reservationUnitOption: ReservationUnitOptionNode!
  reservationSeries: ReservationSeriesNode

  """The ID of the object"""
  id: ID!
  pk: Int
}

type ReservationUnitOptionNode implements Node {
  preferredOrder: Int!
  isRejected: Boolean!
  isLocked: Boolean!
  applicationSection: ApplicationSectionNode!
  reservationUnit: ReservationUnitNode!
  allocatedTimeSlots(
    pk: [Int]
    dayOfTheWeek: [Weekday]
    applicationRound: Int
    applicationSectionStatus: [ApplicationSectionStatusChoice]
    applicantType: [ReserveeType]
    allocatedUnit: [Int]
    unitGroup: [Int]
    allocatedReservationUnit: [Int]
    accessCodeState: [AccessCodeState]
    textSearch: String

    """Ordering"""
    orderBy: [AllocatedTimeSlotOrderingChoices]
  ): [AllocatedTimeSlotNode!]!

  """The ID of the object"""
  id: ID!
  pk: Int
}

type ApplicationSectionNode implements Node {
  extUuid: UUID!
  name: String!
  numPersons: Int!
  reservationsBeginDate: Date!
  reservationsEndDate: Date!
  reservationMinDuration: Duration!
  reservationMaxDuration: Duration!
  appliedReservationsPerWeek: Int!
  application: ApplicationNode!
  purpose: ReservationPurposeNode
  ageGroup: AgeGroupNode
  reservationUnitOptions(
    pk: [Int]
    preferredOrder: [Int]
    reservationUnit: [Int]

    """Ordering"""
    orderBy: [ReservationUnitOptionOrderingChoices]
  ): [ReservationUnitOptionNode!]!
  suitableTimeRanges(
    pk: [Int]
    priority: [Priority]
    fulfilled: Boolean

    """Ordering"""
    orderBy: [SuitableTimeRangeOrderingChoices]
  ): [SuitableTimeRangeNode!]!

  """The ID of the object"""
  id: ID!
  status: ApplicationSectionStatusChoice!
  allocations: Int!
  hasReservations: Boolean!
  shouldHaveActiveAccessCode: Boolean!

  """
  Info fetched from Pindora API. Cached per reservation for 30s. Please don't use this when filtering multiple sections, queries to Pindora are not optimized.
  """
  pindoraInfo: PindoraSectionInfoType
  pk: Int
}

type ApplicationNode implements Node {
  applicantType: ReserveeType
  additionalInformation: String!
  cancelledAt: DateTime
  sentAt: DateTime
  workingMemo: String!
  contactPersonFirstName: String!
  contactPersonLastName: String!
  contactPersonEmail: String
  contactPersonPhoneNumber: String!
  billingStreetAddress: String!
  billingPostCode: String!
  billingCity: String!
  organisationName: String!
  organisationEmail: String
  organisationIdentifier: String!
  organisationYearEstablished: Int
  organisationActiveMembers: Int
  organisationCoreBusiness: String!
  organisationStreetAddress: String!
  organisationPostCode: String!
  organisationCity: String!
  municipality: MunicipalityChoice
  createdAt: DateTime!
  updatedAt: DateTime!
  applicationRound: ApplicationRoundNode!
  user: ApplicantNode
  applicationSections(
    pk: [Int]
    extUuid: UUID
    name: String
    user: Int
    application: Int
    applicationRound: Int
    reservationUnit: [Int]
    unit: [Int]
    unitGroup: [Int]
    applicantType: [ReserveeType]
    status: [ApplicationSectionStatusChoice]
    applicationStatus: [ApplicationStatusChoice]
    priority: [Priority]
    preferredOrder: [Int]
    includePreferredOrder10OrHigher: Boolean
    municipality: [MunicipalityChoice]
    ageGroup: [Int]
    purpose: [Int]
    textSearch: String
    hasAllocations: Boolean

    """Ordering"""
    orderBy: [ApplicationSectionOrderingChoices]
  ): [ApplicationSectionNode!]

  """The ID of the object"""
  id: ID!
  status: ApplicationStatusChoice!
  pk: Int
}

type ApplicantNode implements Node {
  """
  Designates that this user has all permissions without explicitly assigning them.
  """
  isSuperuser: Boolean!

  """Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only."""
  username: String!
  firstName: String!
  lastName: String!
  email: String!
  uuid: UUID!
  dateOfBirth: Date
  reservationNotification: ReservationNotification
  generalRoles: [GeneralRoleNode!]!
  unitRoles: [UnitRoleNode!]!

  """The ID of the object"""
  id: ID!
  name: String!
  isAdAuthenticated: Boolean!
  isStronglyAuthenticated: Boolean!
  isInternalUser: Boolean!
  pk: Int
}

"""An enumeration."""
enum ApplicationSectionStatusChoice {
  UNALLOCATED
  IN_ALLOCATION
  HANDLED
  REJECTED
}

"""An enumeration."""
enum ApplicationStatusChoice {
  DRAFT
  RECEIVED
  IN_ALLOCATION
  HANDLED
  RESULTS_SENT
  EXPIRED
  CANCELLED
}

"""An enumeration."""
enum Priority {
  PRIMARY
  SECONDARY
}

"""Ordering fields for the 'ApplicationSection' model."""
enum ApplicationSectionOrderingChoices {
  pkAsc
  pkDesc
  applicationPkAsc
  applicationPkDesc
  applicantAsc
  applicantDesc
  nameAsc
  nameDesc
  statusAsc
  statusDesc
  applicationStatusAsc
  applicationStatusDesc
  preferredUnitNameFiAsc
  preferredUnitNameFiDesc
  preferredUnitNameEnAsc
  preferredUnitNameEnDesc
  preferredUnitNameSvAsc
  preferredUnitNameSvDesc
  hasAllocationsAsc
  hasAllocationsDesc
  allocationsAsc
  allocationsDesc
}

type ReservationPurposeNode implements Node {
  rank: Int!
  nameFi: String
  nameEn: String
  nameSv: String

  """The ID of the object"""
  id: ID!
  pk: Int
}

type AgeGroupNode implements Node {
  minimum: Int!
  maximum: Int

  """The ID of the object"""
  id: ID!
  pk: Int
}

"""Ordering fields for the 'ReservationUnitOption' model."""
enum ReservationUnitOptionOrderingChoices {
  pkAsc
  pkDesc
}

type SuitableTimeRangeNode implements Node {
  priority: Priority!
  dayOfTheWeek: Weekday!
  beginTime: Time!
  endTime: Time!
  applicationSection: ApplicationSectionNode!

  """The ID of the object"""
  id: ID!
  fulfilled: Boolean!
  pk: Int
}

"""Ordering fields for the 'SuitableTimeRange' model."""
enum SuitableTimeRangeOrderingChoices {
  pkAsc
  pkDesc
}

type PindoraSectionInfoType {
  accessCode: String!
  accessCodeGeneratedAt: DateTime!
  accessCodeIsActive: Boolean!
  accessCodeKeypadUrl: String!
  accessCodePhoneNumber: String!
  accessCodeSmsNumber: String!
  accessCodeSmsMessage: String!
  accessCodeValidity: [PindoraSectionValidityInfoType!]!
}

type PindoraSectionValidityInfoType {
  reservationId: Int!
  reservationSeriesId: Int!
  accessCodeBeginsAt: DateTime!
  accessCodeEndsAt: DateTime!
}

"""The state of the access code."""
enum AccessCodeState {
  ACCESS_CODE_NOT_REQUIRED
  ACCESS_CODE_CREATED
  ACCESS_CODE_PENDING
}

"""Ordering fields for the 'AllocatedTimeSlot' model."""
enum AllocatedTimeSlotOrderingChoices {
  pkAsc
  pkDesc
  applicationSectionPkAsc
  applicationSectionPkDesc
  applicationPkAsc
  applicationPkDesc
  applicationSectionNameAsc
  applicationSectionNameDesc
  allocatedUnitNameFiAsc
  allocatedUnitNameFiDesc
  allocatedUnitNameEnAsc
  allocatedUnitNameEnDesc
  allocatedUnitNameSvAsc
  allocatedUnitNameSvDesc
  allocatedReservationUnitNameFiAsc
  allocatedReservationUnitNameFiDesc
  allocatedReservationUnitNameEnAsc
  allocatedReservationUnitNameEnDesc
  allocatedReservationUnitNameSvAsc
  allocatedReservationUnitNameSvDesc
  allocatedTimeOfWeekAsc
  allocatedTimeOfWeekDesc
  applicantAsc
  applicantDesc
  dayOfTheWeekAsc
  dayOfTheWeekDesc
  applicationStatusAsc
  applicationStatusDesc
  applicationSectionStatusAsc
  applicationSectionStatusDesc
}

type RejectedOccurrenceNode implements Node {
  beginDatetime: DateTime!
  endDatetime: DateTime!
  rejectionReason: RejectionReadinessChoice!
  createdAt: DateTime!
  reservationSeries: ReservationSeriesNode!

  """The ID of the object"""
  id: ID!
  pk: Int
}

"""An enumeration."""
enum RejectionReadinessChoice {
  """Interval not allowed"""
  INTERVAL_NOT_ALLOWED

  """Overlapping reservations"""
  OVERLAPPING_RESERVATIONS

  """Reservation unit closed"""
  RESERVATION_UNIT_CLOSED
}

"""Ordering fields for the 'RejectedOccurrence' model."""
enum RejectedOccurrenceOrderingChoices {
  pkAsc
  pkDesc
  beginDatetimeAsc
  beginDatetimeDesc
  endDatetimeAsc
  endDatetimeDesc
  rejectionReasonAsc
  rejectionReasonDesc
  applicationPkAsc
  applicationPkDesc
  applicationSectionPkAsc
  applicationSectionPkDesc
  applicationSectionNameAsc
  applicationSectionNameDesc
  applicantAsc
  applicantDesc
  reservationUnitPkAsc
  reservationUnitPkDesc
  reservationUnitNameAsc
  reservationUnitNameDesc
  unitPkAsc
  unitPkDesc
  unitNameAsc
  unitNameDesc
}

"""
Same as OrderStatus, but includes the 'FREE' option used for filtering reservations without payments.
"""
enum OrderStatusWithFree {
  DRAFT
  PENDING
  EXPIRED
  CANCELLED
  PAID
  PAID_MANUALLY
  PAID_BY_INVOICE
  REFUNDED
  FREE
}

"""Ordering fields for the 'Reservation' model."""
enum ReservationOrderingChoices {
  pkAsc
  pkDesc
  nameAsc
  nameDesc
  beginsAtAsc
  beginsAtDesc
  endsAtAsc
  endsAtDesc
  createdAtAsc
  createdAtDesc
  stateAsc
  stateDesc
  priceAsc
  priceDesc
  reservationUnitNameFiAsc
  reservationUnitNameFiDesc
  reservationUnitNameEnAsc
  reservationUnitNameEnDesc
  reservationUnitNameSvAsc
  reservationUnitNameSvDesc
  unitNameFiAsc
  unitNameFiDesc
  unitNameEnAsc
  unitNameEnDesc
  unitNameSvAsc
  unitNameSvDesc
  reserveeNameAsc
  reserveeNameDesc
  orderStatusAsc
  orderStatusDesc
}

"\nSame as AccessType, but includes the 'MULTIVALUED' option\nfor series and seasonal bookings where access type between reservations varies.\n"
enum AccessTypeWithMultivalued {
  ACCESS_CODE
  OPENED_BY_STAFF
  PHYSICAL_KEY
  UNRESTRICTED
  MULTIVALUED
}

type PindoraSeriesInfoType {
  accessCode: String!
  accessCodeGeneratedAt: DateTime!
  accessCodeIsActive: Boolean!
  accessCodeKeypadUrl: String!
  accessCodePhoneNumber: String!
  accessCodeSmsNumber: String!
  accessCodeSmsMessage: String!
  accessCodeValidity: [PindoraSeriesValidityInfoType!]!
}

type PindoraSeriesValidityInfoType {
  reservationId: Int!
  reservationSeriesId: Int!
  accessCodeBeginsAt: DateTime!
  accessCodeEndsAt: DateTime!
}

type ReservationDenyReasonNode implements Node {
  reasonFi: String
  reasonEn: String
  reasonSv: String

  """The ID of the object"""
  id: ID!
  pk: Int
}

type PaymentOrderNode implements Node {
  reservation: ReservationNode
  paymentType: PaymentType!
  status: OrderStatus!
  processedAt: DateTime
  handledPaymentDueBy: DateTime
  checkoutUrl: String
  receiptUrl: String

  """The ID of the object"""
  id: ID!
  orderUuid: UUID
  refundUuid: UUID
  expiresInMinutes: Int
  reservationPk: String @deprecated(reason: "Use `reservation` instead.")
}

"""An enumeration."""
enum PaymentType {
  ON_SITE
  ONLINE
  ONLINE_OR_INVOICE
}

"""An enumeration."""
enum OrderStatus {
  DRAFT
  PENDING
  EXPIRED
  CANCELLED
  PAID
  PAID_BY_INVOICE
  PAID_MANUALLY
  REFUNDED
}

type AppliedPricingInfo {
  """
  This is a 'Date', but graphene doesn't know how to serialize it from string...
  """
  begins: String!
  priceUnit: PriceUnit!

  """
  This is a 'Decimal', but graphene doesn't know how to serialize it from string...
  """
  lowestPrice: String!

  """
  This is a 'Decimal', but graphene doesn't know how to serialize it from string...
  """
  highestPrice: String!

  """
  This is a 'Decimal', but graphene doesn't know how to serialize it from string...
  """
  taxPercentage: String!
  materialPriceDescriptionFi: String
  materialPriceDescriptionEn: String
  materialPriceDescriptionSv: String
}

"""An enumeration."""
enum PriceUnit {
  PER_15_MINS
  PER_30_MINS
  PER_HOUR
  PER_HALF_DAY
  PER_DAY
  PER_WEEK
  FIXED
}

type PindoraReservationInfoType {
  accessCode: String!
  accessCodeGeneratedAt: DateTime!
  accessCodeIsActive: Boolean!
  accessCodeKeypadUrl: String!
  accessCodePhoneNumber: String!
  accessCodeSmsNumber: String!
  accessCodeSmsMessage: String!
  accessCodeBeginsAt: DateTime!
  accessCodeEndsAt: DateTime!
}

type ReservationUnitAccessTypeNode implements Node {
  accessType: AccessType!
  beginDate: Date!

  """The ID of the object"""
  id: ID!
  pk: Int
}

"""Ordering fields for the 'ReservationUnitAccessType' model."""
enum ReservationUnitAccessTypeOrderingChoices {
  pkAsc
  pkDesc
  beginDateAsc
  beginDateDesc
}

type ReservationUnitImageNode implements Node {
  imageType: ReservationUnitImageType!
  largeUrl: String
  mediumUrl: String
  smallUrl: String

  """The ID of the object"""
  id: ID!
  imageUrl: String
  pk: Int
}

"""An enumeration."""
enum ReservationUnitImageType {
  """Main image"""
  MAIN

  """Other"""
  OTHER
}

type ReservationUnitPricingNode implements Node {
  begins: Date!
  priceUnit: PriceUnit!
  paymentType: PaymentType
  lowestPrice: Decimal!
  highestPrice: Decimal!
  materialPriceDescriptionFi: String
  materialPriceDescriptionEn: String
  materialPriceDescriptionSv: String
  taxPercentage: TaxPercentageNode!

  """The ID of the object"""
  id: ID!
  lowestPriceNet: Decimal!
  highestPriceNet: Decimal!
  pk: Int
}

type TaxPercentageNode implements Node {
  value: Decimal!

  """The ID of the object"""
  id: ID!
  pk: Int
}

type ReservableTimeSpanType {
  startDatetime: DateTime!
  endDatetime: DateTime!
}

"""Ordering fields for the 'ReservationPurpose' model."""
enum ReservationPurposeOrderingChoices {
  rankAsc
  rankDesc
  nameFiAsc
  nameFiDesc
  nameEnAsc
  nameEnDesc
  nameSvAsc
  nameSvDesc
}

"""An enumeration."""
enum ApplicationRoundStatusChoice {
  UPCOMING
  OPEN
  IN_ALLOCATION
  HANDLED
  RESULTS_SENT
}

"""An enumeration."""
enum ApplicationRoundReservationCreationStatusChoice {
  NOT_COMPLETED
  COMPLETED
  FAILED
}

type ApplicationRoundNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ApplicationRoundNodeEdge]!
  totalCount: Int
}

"""
The Relay compliant `PageInfo` type, containing data necessary to paginate this connection.
"""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String

  """When paginating forwards, the cursor to continue."""
  endCursor: String
}

"""A Relay edge containing a `ApplicationRoundNode` and its cursor."""
type ApplicationRoundNodeEdge {
  """The item at the end of the edge"""
  node: ApplicationRoundNode

  """A cursor for use in pagination"""
  cursor: String!
}

type ApplicationNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ApplicationNodeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `ApplicationNode` and its cursor."""
type ApplicationNodeEdge {
  """The item at the end of the edge"""
  node: ApplicationNode

  """A cursor for use in pagination"""
  cursor: String!
}

"""Ordering fields for the 'Application' model."""
enum ApplicationOrderingChoices {
  pkAsc
  pkDesc
  applicantAsc
  applicantDesc
  applicantTypeAsc
  applicantTypeDesc
  preferredUnitNameFiAsc
  preferredUnitNameFiDesc
  preferredUnitNameEnAsc
  preferredUnitNameEnDesc
  preferredUnitNameSvAsc
  preferredUnitNameSvDesc
  statusAsc
  statusDesc
  sentAtAsc
  sentAtDesc
}

type ApplicationSectionNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ApplicationSectionNodeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `ApplicationSectionNode` and its cursor."""
type ApplicationSectionNodeEdge {
  """The item at the end of the edge"""
  node: ApplicationSectionNode

  """A cursor for use in pagination"""
  cursor: String!
}

type AllocatedTimeSlotNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [AllocatedTimeSlotNodeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `AllocatedTimeSlotNode` and its cursor."""
type AllocatedTimeSlotNodeEdge {
  """The item at the end of the edge"""
  node: AllocatedTimeSlotNode

  """A cursor for use in pagination"""
  cursor: String!
}

type UnitNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [UnitNodeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `UnitNode` and its cursor."""
type UnitNodeEdge {
  """The item at the end of the edge"""
  node: UnitNode

  """A cursor for use in pagination"""
  cursor: String!
}

"""
This Node should be kept to the bare minimum and never expose any relations to avoid performance issues.
"""
type UnitAllNode implements Node {
  tprekId: String
  nameFi: String
  nameEn: String
  nameSv: String

  """The ID of the object"""
  id: ID!
  pk: Int
}

type ResourceNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ResourceNodeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `ResourceNode` and its cursor."""
type ResourceNodeEdge {
  """The item at the end of the edge"""
  node: ResourceNode

  """A cursor for use in pagination"""
  cursor: String!
}

type SpaceNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [SpaceNodeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `SpaceNode` and its cursor."""
type SpaceNodeEdge {
  """The item at the end of the edge"""
  node: SpaceNode

  """A cursor for use in pagination"""
  cursor: String!
}

type EquipmentNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [EquipmentNodeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `EquipmentNode` and its cursor."""
type EquipmentNodeEdge {
  """The item at the end of the edge"""
  node: EquipmentNode

  """A cursor for use in pagination"""
  cursor: String!
}

"""
This Node should be kept to the bare minimum and never expose any relations to avoid performance issues.
"""
type EquipmentAllNode implements Node {
  nameFi: String
  nameEn: String
  nameSv: String

  """The ID of the object"""
  id: ID!
  pk: Int
}

type EquipmentCategoryNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [EquipmentCategoryNodeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `EquipmentCategoryNode` and its cursor."""
type EquipmentCategoryNodeEdge {
  """The item at the end of the edge"""
  node: EquipmentCategoryNode

  """A cursor for use in pagination"""
  cursor: String!
}

"""Ordering fields for the 'EquipmentCategory' model."""
enum EquipmentCategoryOrderingChoices {
  pkAsc
  pkDesc
}

type ReservationUnitNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ReservationUnitNodeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `ReservationUnitNode` and its cursor."""
type ReservationUnitNodeEdge {
  """The item at the end of the edge"""
  node: ReservationUnitNode

  """A cursor for use in pagination"""
  cursor: String!
}

"""
This Node should be kept to the bare minimum and never expose any relations to avoid performance issues.
"""
type ReservationUnitAllNode implements Node {
  nameFi: String
  nameEn: String
  nameSv: String

  """The ID of the object"""
  id: ID!
  pk: Int
}

type ReservationUnitTypeNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ReservationUnitTypeNodeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `ReservationUnitTypeNode` and its cursor."""
type ReservationUnitTypeNodeEdge {
  """The item at the end of the edge"""
  node: ReservationUnitTypeNode

  """A cursor for use in pagination"""
  cursor: String!
}

"""Ordering fields for the 'ReservationUnitType' model."""
enum ReservationUnitTypeOrderingChoices {
  rankAsc
  rankDesc
  nameFiAsc
  nameFiDesc
  nameEnAsc
  nameEnDesc
  nameSvAsc
  nameSvDesc
}

type ReservationUnitCancellationRuleNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ReservationUnitCancellationRuleNodeEdge]!
  totalCount: Int
}

"""
A Relay edge containing a `ReservationUnitCancellationRuleNode` and its cursor.
"""
type ReservationUnitCancellationRuleNodeEdge {
  """The item at the end of the edge"""
  node: ReservationUnitCancellationRuleNode

  """A cursor for use in pagination"""
  cursor: String!
}

"""Ordering fields for the 'ReservationUnitCancellationRule' model."""
enum ReservationUnitCancellationRuleOrderingChoices {
  pkAsc
  pkDesc
}

type TaxPercentageNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [TaxPercentageNodeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `TaxPercentageNode` and its cursor."""
type TaxPercentageNodeEdge {
  """The item at the end of the edge"""
  node: TaxPercentageNode

  """A cursor for use in pagination"""
  cursor: String!
}

"""Ordering fields for the 'TaxPercentage' model."""
enum TaxPercentageOrderingChoices {
  pkAsc
  pkDesc
}

type ReservationMetadataSetNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ReservationMetadataSetNodeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `ReservationMetadataSetNode` and its cursor."""
type ReservationMetadataSetNodeEdge {
  """The item at the end of the edge"""
  node: ReservationMetadataSetNode

  """A cursor for use in pagination"""
  cursor: String!
}

type IntendedUseNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [IntendedUseNodeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `IntendedUseNode` and its cursor."""
type IntendedUseNodeEdge {
  """The item at the end of the edge"""
  node: IntendedUseNode

  """A cursor for use in pagination"""
  cursor: String!
}

type ReservationNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ReservationNodeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `ReservationNode` and its cursor."""
type ReservationNodeEdge {
  """The item at the end of the edge"""
  node: ReservationNode

  """A cursor for use in pagination"""
  cursor: String!
}

type ReservationSeriesNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ReservationSeriesNodeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `ReservationSeriesNode` and its cursor."""
type ReservationSeriesNodeEdge {
  """The item at the end of the edge"""
  node: ReservationSeriesNode

  """A cursor for use in pagination"""
  cursor: String!
}

"""Ordering fields for the 'ReservationSeries' model."""
enum ReservationSeriesOrderingChoices {
  pkAsc
  pkDesc
  nameAsc
  nameDesc
  createdAtAsc
  createdAtDesc
  beginDateAsc
  beginDateDesc
  beginTimeAsc
  beginTimeDesc
  endDateAsc
  endDateDesc
  endTimeAsc
  endTimeDesc
  reservationUnitNameFiAsc
  reservationUnitNameFiDesc
  reservationUnitNameEnAsc
  reservationUnitNameEnDesc
  reservationUnitNameSvAsc
  reservationUnitNameSvDesc
  unitNameFiAsc
  unitNameFiDesc
  unitNameEnAsc
  unitNameEnDesc
  unitNameSvAsc
  unitNameSvDesc
}

type RejectedOccurrenceNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [RejectedOccurrenceNodeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `RejectedOccurrenceNode` and its cursor."""
type RejectedOccurrenceNodeEdge {
  """The item at the end of the edge"""
  node: RejectedOccurrenceNode

  """A cursor for use in pagination"""
  cursor: String!
}

type ReservationCancelReasonType {
  value: ReservationCancelReasonChoice!
  reasonFi: String!
  reasonEn: String!
  reasonSv: String!
}

type ReservationDenyReasonNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ReservationDenyReasonNodeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `ReservationDenyReasonNode` and its cursor."""
type ReservationDenyReasonNodeEdge {
  """The item at the end of the edge"""
  node: ReservationDenyReasonNode

  """A cursor for use in pagination"""
  cursor: String!
}

"""Ordering fields for the 'ReservationDenyReason' model."""
enum ReservationDenyReasonOrderingChoices {
  rankAsc
  rankDesc
}

type ReservationPurposeNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ReservationPurposeNodeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `ReservationPurposeNode` and its cursor."""
type ReservationPurposeNodeEdge {
  """The item at the end of the edge"""
  node: ReservationPurposeNode

  """A cursor for use in pagination"""
  cursor: String!
}

type AgeGroupNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [AgeGroupNodeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `AgeGroupNode` and its cursor."""
type AgeGroupNodeEdge {
  """The item at the end of the edge"""
  node: AgeGroupNode

  """A cursor for use in pagination"""
  cursor: String!
}

type PermissionCheckerType {
  hasPermission: Boolean!
}

type HelsinkiProfileDataNode {
  pk: Int!
  firstName: String
  lastName: String
  email: String
  phone: String
  birthday: Date
  ssn: String
  streetAddress: String
  postalCode: String
  city: String
  countryCode: String
  additionalAddress: String
  municipalityCode: String
  municipalityName: String
  loginMethod: LoginMethod!
  isStrongLogin: Boolean!
}

"""An enumeration."""
enum LoginMethod {
  PROFILE
  AD
  OTHER
}

type TermsOfUseNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [TermsOfUseNodeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `TermsOfUseNode` and its cursor."""
type TermsOfUseNodeEdge {
  """The item at the end of the edge"""
  node: TermsOfUseNode

  """A cursor for use in pagination"""
  cursor: String!
}

"""Ordering fields for the 'TermsOfUse' model."""
enum TermsOfUseOrderingChoices {
  pkAsc
  pkDesc
}

type BannerNotificationNode implements Node {
  name: String!
  messageFi: String
  messageEn: String
  messageSv: String
  draft: Boolean!
  level: BannerNotificationLevel!
  target: BannerNotificationTarget!
  activeFrom: DateTime
  activeUntil: DateTime

  """The ID of the object"""
  id: ID!
  state: BannerNotificationState!
  pk: Int
}

"""An enumeration."""
enum BannerNotificationLevel {
  """Exception"""
  EXCEPTION

  """Warning"""
  WARNING

  """Normal"""
  NORMAL
}

"""An enumeration."""
enum BannerNotificationTarget {
  """All"""
  ALL

  """Staff"""
  STAFF

  """User"""
  USER
}

"""An enumeration."""
enum BannerNotificationState {
  DRAFT
  SCHEDULED
  ACTIVE
}

type BannerNotificationNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [BannerNotificationNodeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `BannerNotificationNode` and its cursor."""
type BannerNotificationNodeEdge {
  """The item at the end of the edge"""
  node: BannerNotificationNode

  """A cursor for use in pagination"""
  cursor: String!
}

"""Ordering fields for the 'BannerNotification' model."""
enum BannerNotificationOrderingChoices {
  pkAsc
  pkDesc
  nameAsc
  nameDesc
  startsAsc
  startsDesc
  endsAsc
  endsDesc
  levelAsc
  levelDesc
  stateAsc
  stateDesc
  targetAsc
  targetDesc
}

type UnitGroupNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [UnitGroupNodeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `UnitGroupNode` and its cursor."""
type UnitGroupNodeEdge {
  """The item at the end of the edge"""
  node: UnitGroupNode

  """A cursor for use in pagination"""
  cursor: String!
}

type Mutation {
  createApplication(input: ApplicationCreateMutationInput!): ApplicationCreateMutationPayload
  updateApplication(input: ApplicationUpdateMutationInput!): ApplicationUpdateMutationPayload
  sendApplication(input: ApplicationSendMutationInput!): ApplicationSendMutationPayload
  cancelApplication(input: ApplicationCancelMutationInput!): ApplicationCancelMutationPayload
  updateApplicationWorkingMemo(input: ApplicationWorkingMemoMutationInput!): ApplicationWorkingMemoMutationPayload
  createApplicationSection(input: ApplicationSectionCreateMutationInput!): ApplicationSectionCreateMutationPayload
  updateApplicationSection(input: ApplicationSectionUpdateMutationInput!): ApplicationSectionUpdateMutationPayload
  deleteApplicationSection(input: ApplicationSectionDeleteMutationInput!): ApplicationSectionDeleteMutationPayload
  createAllocatedTimeslot(input: AllocatedTimeSlotCreateMutationInput!): AllocatedTimeSlotCreateMutationPayload
  deleteAllocatedTimeslot(input: AllocatedTimeSlotDeleteMutationInput!): AllocatedTimeSlotDeleteMutationPayload
  updateReservationUnitOption(input: ReservationUnitOptionUpdateMutationInput!): ReservationUnitOptionUpdateMutationPayload
  rejectAllSectionOptions(input: RejectAllSectionOptionsMutationInput!): RejectAllSectionOptionsMutationPayload
  restoreAllSectionOptions(input: RestoreAllSectionOptionsMutationInput!): RestoreAllSectionOptionsMutationPayload
  rejectAllApplicationOptions(input: RejectAllApplicationOptionsMutationInput!): RejectAllApplicationOptionsMutationPayload
  restoreAllApplicationOptions(input: RestoreAllApplicationOptionsMutationInput!): RestoreAllApplicationOptionsMutationPayload

  """
  Cancel all reservations in the given application section that can be cancelled.
  """
  cancelAllApplicationSectionReservations(input: ApplicationSectionReservationCancellationMutationInput!): ApplicationSectionReservationCancellationMutationPayload
  setApplicationRoundHandled(input: SetApplicationRoundHandledMutationInput!): SetApplicationRoundHandledMutationPayload
  setApplicationRoundResultsSent(input: SetApplicationRoundResultsSentMutationInput!): SetApplicationRoundResultsSentMutationPayload
  updateUnit(input: UnitUpdateMutationInput!): UnitUpdateMutationPayload
  createResource(input: ResourceCreateMutationInput!): ResourceCreateMutationPayload
  updateResource(input: ResourceUpdateMutationInput!): ResourceUpdateMutationPayload
  deleteResource(input: ResourceDeleteMutationInput!): ResourceDeleteMutationPayload
  createSpace(input: SpaceCreateMutationInput!): SpaceCreateMutationPayload
  updateSpace(input: SpaceUpdateMutationInput!): SpaceUpdateMutationPayload
  deleteSpace(input: SpaceDeleteMutationInput!): SpaceDeleteMutationPayload
  createEquipment(input: EquipmentCreateMutationInput!): EquipmentCreateMutationPayload
  updateEquipment(input: EquipmentUpdateMutationInput!): EquipmentUpdateMutationPayload
  deleteEquipment(input: EquipmentDeleteMutationInput!): EquipmentDeleteMutationPayload
  createEquipmentCategory(input: EquipmentCategoryCreateMutationInput!): EquipmentCategoryCreateMutationPayload
  updateEquipmentCategory(input: EquipmentCategoryUpdateMutationInput!): EquipmentCategoryUpdateMutationPayload
  deleteEquipmentCategory(input: EquipmentCategoryDeleteMutationInput!): EquipmentCategoryDeleteMutationPayload
  createReservationUnit(input: ReservationUnitCreateMutationInput!): ReservationUnitCreateMutationPayload
  updateReservationUnit(input: ReservationUnitUpdateMutationInput!): ReservationUnitUpdateMutationPayload
  archiveReservationUnit(input: ReservationUnitArchiveMutationInput!): ReservationUnitArchiveMutationPayload
  createReservationUnitImage(input: ReservationUnitImageCreateMutationInput!): ReservationUnitImageCreateMutationPayload
  updateReservationUnitImage(input: ReservationUnitImageUpdateMutationInput!): ReservationUnitImageUpdateMutationPayload
  deleteReservationUnitImage(input: ReservationUnitImageDeleteMutationInput!): ReservationUnitImageDeleteMutationPayload
  createIntendedUse(input: IntendedUseCreateMutationInput!): IntendedUseCreateMutationPayload
  updateIntendedUse(input: IntendedUseUpdateMutationInput!): IntendedUseUpdateMutationPayload
  createReservation(input: ReservationCreateMutationInput!): ReservationCreateMutationPayload
  createStaffReservation(input: ReservationStaffCreateMutationInput!): ReservationStaffCreateMutationPayload
  updateReservation(input: ReservationUpdateMutationInput!): ReservationUpdateMutationPayload
  confirmReservation(input: ReservationConfirmMutationInput!): ReservationConfirmMutationPayload
  cancelReservation(input: ReservationCancellationMutationInput!): ReservationCancellationMutationPayload
  denyReservation(input: ReservationDenyMutationInput!): ReservationDenyMutationPayload
  deleteReservation(input: ReservationDeleteMutationInput!): ReservationDeleteMutationPayload @deprecated(reason: "Renamed to 'deleteTentativeReservation'.")

  """Used only for deleting a reservation before it is confirmed."""
  deleteTentativeReservation(input: ReservationDeleteTentativeMutationInput!): ReservationDeleteTentativeMutationPayload
  approveReservation(input: ReservationApproveMutationInput!): ReservationApproveMutationPayload
  refundReservation(input: ReservationRefundMutationInput!): ReservationRefundMutationPayload
  requireHandlingForReservation(input: ReservationRequiresHandlingMutationInput!): ReservationRequiresHandlingMutationPayload
  updateReservationWorkingMemo(input: ReservationWorkingMemoMutationInput!): ReservationWorkingMemoMutationPayload
  adjustReservationTime(input: ReservationAdjustTimeMutationInput!): ReservationAdjustTimeMutationPayload
  staffAdjustReservationTime(input: ReservationStaffAdjustTimeMutationInput!): ReservationStaffAdjustTimeMutationPayload
  staffReservationModify(input: ReservationStaffModifyMutationInput!): ReservationStaffModifyMutationPayload
  staffChangeReservationAccessCode(input: ReservationStaffChangeAccessCodeMutationInput!): ReservationStaffChangeAccessCodeMutationPayload
  staffRepairReservationAccessCode(input: ReservationStaffRepairAccessCodeMutationInput!): ReservationStaffRepairAccessCodeMutationPayload
  createReservationSeries(input: ReservationSeriesCreateMutationInput!): ReservationSeriesCreateMutationPayload
  updateReservationSeries(input: ReservationSeriesUpdateMutationInput!): ReservationSeriesUpdateMutationPayload
  addReservationToSeries(input: ReservationSeriesAddMutationInput!): ReservationSeriesAddMutationPayload
  rescheduleReservationSeries(input: ReservationSeriesRescheduleMutationInput!): ReservationSeriesRescheduleMutationPayload
  denyReservationSeries(input: ReservationSeriesDenyMutationInput!): ReservationSeriesDenyMutationPayload
  changeReservationSeriesAccessCode(input: ReservationSeriesChangeAccessCodeMutationInput!): ReservationSeriesChangeAccessCodeMutationPayload
  repairReservationSeriesAccessCode(input: ReservationSeriesRepairAccessCodeMutationInput!): ReservationSeriesRepairAccessCodeMutationPayload
  updateCurrentUser(input: CurrentUserUpdateMutationInput!): CurrentUserUpdateMutationPayload
  updateStaffUser(input: UserStaffUpdateMutationInput!): UserStaffUpdateMutationPayload
  createBannerNotification(input: BannerNotificationCreateMutationInput!): BannerNotificationCreateMutationPayload
  updateBannerNotification(input: BannerNotificationUpdateMutationInput!): BannerNotificationUpdateMutationPayload
  deleteBannerNotification(input: BannerNotificationDeleteMutationInput!): BannerNotificationDeleteMutationPayload
}

type ApplicationCreateMutationPayload {
  pk: Int
  applicationRound: Int
  applicationSections: [ApplicationSectionNode]
  applicantType: ReserveeType
  additionalInformation: String
  contactPersonFirstName: String
  contactPersonLastName: String
  contactPersonEmail: String
  contactPersonPhoneNumber: String
  billingStreetAddress: String
  billingPostCode: String
  billingCity: String
  organisationName: String
  organisationEmail: String
  organisationIdentifier: String
  organisationYearEstablished: Int
  organisationActiveMembers: Int
  organisationCoreBusiness: String
  organisationStreetAddress: String
  organisationPostCode: String
  organisationCity: String
  municipality: MunicipalityChoice
  createdAt: DateTime
  updatedAt: DateTime
  cancelledAt: DateTime
  sentAt: DateTime
  status: Status
}

"""An enumeration."""
enum Status {
  """Draft"""
  DRAFT

  """Received"""
  RECEIVED

  """In Allocation"""
  IN_ALLOCATION

  """Handled"""
  HANDLED

  """Results Sent"""
  RESULTS_SENT

  """Expired"""
  EXPIRED

  """Cancelled"""
  CANCELLED
}

input ApplicationCreateMutationInput {
  pk: Int
  applicationRound: Int!
  applicationSections: [ApplicationSectionForApplicationSerializerInput]
  applicantType: ReserveeType
  additionalInformation: String
  contactPersonFirstName: String
  contactPersonLastName: String
  contactPersonEmail: String
  contactPersonPhoneNumber: String
  billingStreetAddress: String
  billingPostCode: String
  billingCity: String
  organisationName: String
  organisationEmail: String
  organisationIdentifier: String
  organisationYearEstablished: Int
  organisationActiveMembers: Int
  organisationCoreBusiness: String
  organisationStreetAddress: String
  organisationPostCode: String
  organisationCity: String
  municipality: MunicipalityChoice
}

input ApplicationSectionForApplicationSerializerInput {
  pk: Int
  name: String!
  numPersons: Int!
  reservationsBeginDate: Date!
  reservationsEndDate: Date!
  reservationMinDuration: Duration!
  reservationMaxDuration: Duration!
  appliedReservationsPerWeek: Int!
  purpose: Int
  ageGroup: Int
  reservationUnitOptions: [ReservationUnitOptionApplicantSerializerInput]!
  suitableTimeRanges: [SuitableTimeRangeSerializerInput]!
}

input ReservationUnitOptionApplicantSerializerInput {
  pk: Int
  preferredOrder: Int!
  reservationUnit: Int!
}

input SuitableTimeRangeSerializerInput {
  pk: Int
  priority: Priority!
  dayOfTheWeek: Weekday!
  beginTime: Time!
  endTime: Time!
}

type ApplicationUpdateMutationPayload {
  pk: Int
  applicationRound: ID
  applicationSections: [ApplicationSectionNode]
  applicantType: ReserveeType
  additionalInformation: String
  contactPersonFirstName: String
  contactPersonLastName: String
  contactPersonEmail: String
  contactPersonPhoneNumber: String
  billingStreetAddress: String
  billingPostCode: String
  billingCity: String
  organisationName: String
  organisationEmail: String
  organisationIdentifier: String
  organisationYearEstablished: Int
  organisationActiveMembers: Int
  organisationCoreBusiness: String
  organisationStreetAddress: String
  organisationPostCode: String
  organisationCity: String
  municipality: MunicipalityChoice
  user: ID
  createdAt: DateTime
  updatedAt: DateTime
  cancelledAt: DateTime
  sentAt: DateTime
  status: Status
}

input ApplicationUpdateMutationInput {
  pk: Int!
  applicationSections: [UpdateApplicationSectionForApplicationSerializerInput]
  applicantType: ReserveeType
  additionalInformation: String
  contactPersonFirstName: String
  contactPersonLastName: String
  contactPersonEmail: String
  contactPersonPhoneNumber: String
  billingStreetAddress: String
  billingPostCode: String
  billingCity: String
  organisationName: String
  organisationEmail: String
  organisationIdentifier: String
  organisationYearEstablished: Int
  organisationActiveMembers: Int
  organisationCoreBusiness: String
  organisationStreetAddress: String
  organisationPostCode: String
  organisationCity: String
  municipality: MunicipalityChoice
}

input UpdateApplicationSectionForApplicationSerializerInput {
  pk: Int
  name: String
  numPersons: Int
  reservationsBeginDate: Date
  reservationsEndDate: Date
  reservationMinDuration: Duration
  reservationMaxDuration: Duration
  appliedReservationsPerWeek: Int
  purpose: Int
  ageGroup: Int
  reservationUnitOptions: [UpdateReservationUnitOptionApplicantSerializerInput]
  suitableTimeRanges: [UpdateSuitableTimeRangeSerializerInput]
}

input UpdateReservationUnitOptionApplicantSerializerInput {
  pk: Int
  preferredOrder: Int
  reservationUnit: Int
}

input UpdateSuitableTimeRangeSerializerInput {
  pk: Int
  priority: Priority
  dayOfTheWeek: Weekday
  beginTime: Time
  endTime: Time
}

type ApplicationSendMutationPayload {
  pk: Int
}

input ApplicationSendMutationInput {
  pk: Int!
}

type ApplicationCancelMutationPayload {
  pk: Int
}

input ApplicationCancelMutationInput {
  pk: Int!
}

type ApplicationWorkingMemoMutationPayload {
  pk: Int
  workingMemo: String
}

input ApplicationWorkingMemoMutationInput {
  pk: Int!
  workingMemo: String
}

type ApplicationSectionCreateMutationPayload {
  pk: Int
  name: String
  numPersons: Int
  reservationsBeginDate: Date
  reservationsEndDate: Date
  reservationMinDuration: Duration
  reservationMaxDuration: Duration
  appliedReservationsPerWeek: Int
  application: Int
  purpose: Int
  ageGroup: Int
  reservationUnitOptions: [ReservationUnitOptionNode]
  suitableTimeRanges: [SuitableTimeRangeNode]
}

input ApplicationSectionCreateMutationInput {
  pk: Int
  name: String!
  numPersons: Int!
  reservationsBeginDate: Date!
  reservationsEndDate: Date!
  reservationMinDuration: Duration!
  reservationMaxDuration: Duration!
  appliedReservationsPerWeek: Int!
  application: Int!
  purpose: Int
  ageGroup: Int
  reservationUnitOptions: [ReservationUnitOptionApplicantSerializerInput]!
  suitableTimeRanges: [SuitableTimeRangeSerializerInput]!
}

type ApplicationSectionUpdateMutationPayload {
  pk: Int
  name: String
  numPersons: Int
  reservationsBeginDate: Date
  reservationsEndDate: Date
  reservationMinDuration: Duration
  reservationMaxDuration: Duration
  appliedReservationsPerWeek: Int
  application: Int
  purpose: Int
  ageGroup: Int
  reservationUnitOptions: [ReservationUnitOptionNode]
  suitableTimeRanges: [SuitableTimeRangeNode]
}

input ApplicationSectionUpdateMutationInput {
  pk: Int!
  name: String
  numPersons: Int
  reservationsBeginDate: Date
  reservationsEndDate: Date
  reservationMinDuration: Duration
  reservationMaxDuration: Duration
  appliedReservationsPerWeek: Int
  application: Int
  purpose: Int
  ageGroup: Int
  reservationUnitOptions: [UpdateReservationUnitOptionApplicantSerializerInput]
  suitableTimeRanges: [UpdateSuitableTimeRangeSerializerInput]
}

type ApplicationSectionDeleteMutationPayload {
  deleted: Boolean
}

input ApplicationSectionDeleteMutationInput {
  pk: ID!
}

type AllocatedTimeSlotCreateMutationPayload {
  pk: Int
  dayOfTheWeek: Weekday
  beginTime: Time
  endTime: Time
  reservationUnitOption: Int
}

input AllocatedTimeSlotCreateMutationInput {
  pk: Int
  dayOfTheWeek: Weekday!
  beginTime: Time!
  endTime: Time!
  reservationUnitOption: Int!
  force: Boolean
}

type AllocatedTimeSlotDeleteMutationPayload {
  deleted: Boolean
}

input AllocatedTimeSlotDeleteMutationInput {
  pk: ID!
}

type ReservationUnitOptionUpdateMutationPayload {
  pk: Int
  isRejected: Boolean
  isLocked: Boolean
}

input ReservationUnitOptionUpdateMutationInput {
  pk: Int!
  isRejected: Boolean
  isLocked: Boolean
}

type RejectAllSectionOptionsMutationPayload {
  pk: Int
}

input RejectAllSectionOptionsMutationInput {
  pk: Int!
}

type RestoreAllSectionOptionsMutationPayload {
  pk: Int
}

input RestoreAllSectionOptionsMutationInput {
  pk: Int!
}

type RejectAllApplicationOptionsMutationPayload {
  pk: Int
}

input RejectAllApplicationOptionsMutationInput {
  pk: Int!
}

type RestoreAllApplicationOptionsMutationPayload {
  pk: Int
}

input RestoreAllApplicationOptionsMutationInput {
  pk: Int!
}

"""
Cancel all reservations in the given application section that can be cancelled.
"""
type ApplicationSectionReservationCancellationMutationPayload {
  future: Int
  cancelled: Int
}

input ApplicationSectionReservationCancellationMutationInput {
  pk: Int!
  cancelReason: ReservationCancelReasonChoice!
  cancelDetails: String
}

type SetApplicationRoundHandledMutationPayload {
  pk: Int
}

input SetApplicationRoundHandledMutationInput {
  pk: Int!
}

type SetApplicationRoundResultsSentMutationPayload {
  pk: Int
}

input SetApplicationRoundResultsSentMutationInput {
  pk: Int!
}

type UnitUpdateMutationPayload {
  pk: Int
  tprekId: String
  name: String
  nameFi: String
  nameEn: String
  nameSv: String
  description: String
  descriptionFi: String
  descriptionEn: String
  descriptionSv: String
  shortDescription: String
  shortDescriptionFi: String
  shortDescriptionEn: String
  shortDescriptionSv: String
  webPage: String
  email: String
  phone: String
}

input UnitUpdateMutationInput {
  pk: Int!
  tprekId: String
  name: String
  nameFi: String
  nameEn: String
  nameSv: String
  description: String
  descriptionFi: String
  descriptionEn: String
  descriptionSv: String
  shortDescription: String
  shortDescriptionFi: String
  shortDescriptionEn: String
  shortDescriptionSv: String
  webPage: String
  email: String
  phone: String
}

type ResourceCreateMutationPayload {
  pk: Int
  name: String
  nameFi: String
  nameEn: String
  nameSv: String
  locationType: ResourceLocationType
  space: Int
}

input ResourceCreateMutationInput {
  pk: Int
  name: String!
  nameFi: String
  nameEn: String
  nameSv: String
  locationType: ResourceLocationType
  space: Int
}

type ResourceUpdateMutationPayload {
  pk: Int
  name: String
  nameFi: String
  nameEn: String
  nameSv: String
  locationType: ResourceLocationType
  space: Int
}

input ResourceUpdateMutationInput {
  pk: Int!
  name: String
  nameFi: String
  nameEn: String
  nameSv: String
  locationType: ResourceLocationType
  space: Int
}

type ResourceDeleteMutationPayload {
  deleted: Boolean
}

input ResourceDeleteMutationInput {
  pk: ID!
}

type SpaceCreateMutationPayload {
  pk: Int
  name: String
  nameFi: String
  nameEn: String
  nameSv: String
  surfaceArea: Int
  maxPersons: Int
  code: String
  unit: Int
  parent: Int
}

input SpaceCreateMutationInput {
  pk: Int
  name: String!
  nameFi: String
  nameEn: String
  nameSv: String
  surfaceArea: Int
  maxPersons: Int
  code: String
  unit: Int!
  parent: Int
}

type SpaceUpdateMutationPayload {
  pk: Int
  name: String
  nameFi: String
  nameEn: String
  nameSv: String
  surfaceArea: Int
  maxPersons: Int
  code: String
  unit: Int
  parent: Int
}

input SpaceUpdateMutationInput {
  pk: Int!
  name: String
  nameFi: String
  nameEn: String
  nameSv: String
  surfaceArea: Int
  maxPersons: Int
  code: String
  unit: Int
  parent: Int
}

type SpaceDeleteMutationPayload {
  deleted: Boolean
}

input SpaceDeleteMutationInput {
  pk: ID!
}

type EquipmentCreateMutationPayload {
  pk: Int
  name: String
  nameFi: String
  nameEn: String
  nameSv: String
  category: Int
}

input EquipmentCreateMutationInput {
  pk: Int
  name: String!
  nameFi: String
  nameEn: String
  nameSv: String
  category: Int!
}

type EquipmentUpdateMutationPayload {
  pk: Int
  name: String
  nameFi: String
  nameEn: String
  nameSv: String
  category: Int
}

input EquipmentUpdateMutationInput {
  pk: Int!
  name: String
  nameFi: String
  nameEn: String
  nameSv: String
  category: Int
}

type EquipmentDeleteMutationPayload {
  deleted: Boolean
}

input EquipmentDeleteMutationInput {
  pk: ID!
}

type EquipmentCategoryCreateMutationPayload {
  pk: Int
  name: String
  nameFi: String
  nameEn: String
  nameSv: String
}

input EquipmentCategoryCreateMutationInput {
  pk: Int
  name: String!
  nameFi: String
  nameEn: String
  nameSv: String
}

type EquipmentCategoryUpdateMutationPayload {
  pk: Int
  name: String
  nameFi: String
  nameEn: String
  nameSv: String
}

input EquipmentCategoryUpdateMutationInput {
  pk: Int!
  name: String
  nameFi: String
  nameEn: String
  nameSv: String
}

type EquipmentCategoryDeleteMutationPayload {
  deleted: Boolean
}

input EquipmentCategoryDeleteMutationInput {
  pk: ID!
}

type ReservationUnitCreateMutationPayload {
  pk: Int
  extUuid: String
  name: String
  nameFi: String
  nameEn: String
  nameSv: String
  description: String
  descriptionFi: String
  descriptionEn: String
  descriptionSv: String
  notesWhenApplying: String
  notesWhenApplyingFi: String
  notesWhenApplyingEn: String
  notesWhenApplyingSv: String
  contactInformation: String
  reservationPendingInstructions: String
  reservationPendingInstructionsFi: String
  reservationPendingInstructionsEn: String
  reservationPendingInstructionsSv: String
  reservationConfirmedInstructions: String
  reservationConfirmedInstructionsFi: String
  reservationConfirmedInstructionsEn: String
  reservationConfirmedInstructionsSv: String
  reservationCancelledInstructions: String
  reservationCancelledInstructionsFi: String
  reservationCancelledInstructionsEn: String
  reservationCancelledInstructionsSv: String
  surfaceArea: Int
  minPersons: Int
  maxPersons: Int
  maxReservationsPerUser: Int
  reservationsMinDaysBefore: Int
  reservationsMaxDaysBefore: Int
  reservationBeginsAt: DateTime
  reservationEndsAt: DateTime
  publishBeginsAt: DateTime
  publishEndsAt: DateTime
  minReservationDuration: Duration
  maxReservationDuration: Duration
  bufferTimeBefore: Duration
  bufferTimeAfter: Duration
  isDraft: Boolean
  requireAdultReservee: Boolean
  requireReservationHandling: Boolean
  reservationBlockWholeDay: Boolean
  canApplyFreeOfCharge: Boolean
  allowReservationsWithoutOpeningHours: Boolean
  authentication: AuthenticationType
  reservationStartInterval: ReservationStartInterval
  reservationKind: ReservationKind
  reservationForm: ReservationFormType
  publishingState: String
  searchTerms: [String]
  unit: Int
  reservationUnitType: Int
  cancellationRule: Int
  metadataSet: Int
  cancellationTerms: String
  serviceSpecificTerms: String
  pricingTerms: String
  paymentTerms: String
  spaces: [Int]
  resources: [Int]
  intendedUses: [Int]
  equipments: [Int]
  images: [ReservationUnitImageNode]
  pricings: [ReservationUnitPricingNode]
  accessTypes: [ReservationUnitAccessTypeNode]
  applicationRoundTimeSlots: [ApplicationRoundTimeSlotNode]
}

input ReservationUnitCreateMutationInput {
  pk: Int
  name: String!
  nameFi: String
  nameEn: String
  nameSv: String
  description: String
  descriptionFi: String
  descriptionEn: String
  descriptionSv: String
  notesWhenApplying: String
  notesWhenApplyingFi: String
  notesWhenApplyingEn: String
  notesWhenApplyingSv: String
  contactInformation: String
  reservationPendingInstructions: String
  reservationPendingInstructionsFi: String
  reservationPendingInstructionsEn: String
  reservationPendingInstructionsSv: String
  reservationConfirmedInstructions: String
  reservationConfirmedInstructionsFi: String
  reservationConfirmedInstructionsEn: String
  reservationConfirmedInstructionsSv: String
  reservationCancelledInstructions: String
  reservationCancelledInstructionsFi: String
  reservationCancelledInstructionsEn: String
  reservationCancelledInstructionsSv: String
  surfaceArea: Int
  minPersons: Int
  maxPersons: Int
  maxReservationsPerUser: Int
  reservationsMinDaysBefore: Int
  reservationsMaxDaysBefore: Int
  reservationBeginsAt: DateTime
  reservationEndsAt: DateTime
  publishBeginsAt: DateTime
  publishEndsAt: DateTime
  minReservationDuration: Duration
  maxReservationDuration: Duration
  bufferTimeBefore: Duration
  bufferTimeAfter: Duration
  isDraft: Boolean
  requireAdultReservee: Boolean
  requireReservationHandling: Boolean
  reservationBlockWholeDay: Boolean
  canApplyFreeOfCharge: Boolean
  allowReservationsWithoutOpeningHours: Boolean
  authentication: AuthenticationType
  reservationStartInterval: ReservationStartInterval
  reservationKind: ReservationKind
  reservationForm: ReservationFormType
  searchTerms: [String]
  unit: Int!
  reservationUnitType: Int
  cancellationRule: Int
  metadataSet: Int
  cancellationTerms: String
  serviceSpecificTerms: String
  pricingTerms: String
  paymentTerms: String
  spaces: [Int]
  resources: [Int]
  intendedUses: [Int]
  equipments: [Int]
  images: [ReservationUnitImageFieldSerializerInput]
  pricings: [ReservationUnitPricingSerializerInput]
  accessTypes: [ReservationUnitAccessTypeSerializerInput]
  applicationRoundTimeSlots: [ApplicationRoundTimeSlotSerializerInput]
}

input ReservationUnitImageFieldSerializerInput {
  imageUrl: Upload!
  largeUrl: String
  mediumUrl: String
  smallUrl: String
  imageType: ReservationUnitImageType!
}

"""Represents a file upload."""
scalar Upload

input ReservationUnitPricingSerializerInput {
  pk: Int
  begins: Date!
  isActivatedOnBegins: Boolean
  paymentType: PaymentType
  priceUnit: PriceUnit
  lowestPrice: Decimal
  lowestPriceNet: String
  highestPrice: Decimal
  highestPriceNet: String
  taxPercentage: Int!
  materialPriceDescriptionFi: String
  materialPriceDescriptionEn: String
  materialPriceDescriptionSv: String
}

input ReservationUnitAccessTypeSerializerInput {
  pk: Int
  accessType: AccessType
  beginDate: Date!
}

input ApplicationRoundTimeSlotSerializerInput {
  weekday: Weekday!
  isClosed: Boolean
  reservableTimes: [TimeSlotSerializerInput]
}

input TimeSlotSerializerInput {
  begin: Time!
  end: Time!
}

type ReservationUnitUpdateMutationPayload {
  pk: Int
  extUuid: String
  name: String
  nameFi: String
  nameEn: String
  nameSv: String
  description: String
  descriptionFi: String
  descriptionEn: String
  descriptionSv: String
  notesWhenApplying: String
  notesWhenApplyingFi: String
  notesWhenApplyingEn: String
  notesWhenApplyingSv: String
  contactInformation: String
  reservationPendingInstructions: String
  reservationPendingInstructionsFi: String
  reservationPendingInstructionsEn: String
  reservationPendingInstructionsSv: String
  reservationConfirmedInstructions: String
  reservationConfirmedInstructionsFi: String
  reservationConfirmedInstructionsEn: String
  reservationConfirmedInstructionsSv: String
  reservationCancelledInstructions: String
  reservationCancelledInstructionsFi: String
  reservationCancelledInstructionsEn: String
  reservationCancelledInstructionsSv: String
  surfaceArea: Int
  minPersons: Int
  maxPersons: Int
  maxReservationsPerUser: Int
  reservationsMinDaysBefore: Int
  reservationsMaxDaysBefore: Int
  reservationBeginsAt: DateTime
  reservationEndsAt: DateTime
  publishBeginsAt: DateTime
  publishEndsAt: DateTime
  minReservationDuration: Duration
  maxReservationDuration: Duration
  bufferTimeBefore: Duration
  bufferTimeAfter: Duration
  isDraft: Boolean
  requireAdultReservee: Boolean
  requireReservationHandling: Boolean
  reservationBlockWholeDay: Boolean
  canApplyFreeOfCharge: Boolean
  allowReservationsWithoutOpeningHours: Boolean
  authentication: AuthenticationType
  reservationStartInterval: ReservationStartInterval
  reservationKind: ReservationKind
  reservationForm: ReservationFormType
  publishingState: String
  searchTerms: [String]
  unit: Int
  reservationUnitType: Int
  cancellationRule: Int
  metadataSet: Int
  cancellationTerms: String
  serviceSpecificTerms: String
  pricingTerms: String
  paymentTerms: String
  spaces: [Int]
  resources: [Int]
  intendedUses: [Int]
  equipments: [Int]
  images: [ReservationUnitImageNode]
  pricings: [ReservationUnitPricingNode]
  accessTypes: [ReservationUnitAccessTypeNode]
  applicationRoundTimeSlots: [ApplicationRoundTimeSlotNode]
}

input ReservationUnitUpdateMutationInput {
  pk: Int!
  name: String
  nameFi: String
  nameEn: String
  nameSv: String
  description: String
  descriptionFi: String
  descriptionEn: String
  descriptionSv: String
  notesWhenApplying: String
  notesWhenApplyingFi: String
  notesWhenApplyingEn: String
  notesWhenApplyingSv: String
  contactInformation: String
  reservationPendingInstructions: String
  reservationPendingInstructionsFi: String
  reservationPendingInstructionsEn: String
  reservationPendingInstructionsSv: String
  reservationConfirmedInstructions: String
  reservationConfirmedInstructionsFi: String
  reservationConfirmedInstructionsEn: String
  reservationConfirmedInstructionsSv: String
  reservationCancelledInstructions: String
  reservationCancelledInstructionsFi: String
  reservationCancelledInstructionsEn: String
  reservationCancelledInstructionsSv: String
  surfaceArea: Int
  minPersons: Int
  maxPersons: Int
  maxReservationsPerUser: Int
  reservationsMinDaysBefore: Int
  reservationsMaxDaysBefore: Int
  reservationBeginsAt: DateTime
  reservationEndsAt: DateTime
  publishBeginsAt: DateTime
  publishEndsAt: DateTime
  minReservationDuration: Duration
  maxReservationDuration: Duration
  bufferTimeBefore: Duration
  bufferTimeAfter: Duration
  isDraft: Boolean
  requireAdultReservee: Boolean
  requireReservationHandling: Boolean
  reservationBlockWholeDay: Boolean
  canApplyFreeOfCharge: Boolean
  allowReservationsWithoutOpeningHours: Boolean
  authentication: AuthenticationType
  reservationStartInterval: ReservationStartInterval
  reservationKind: ReservationKind
  reservationForm: ReservationFormType
  searchTerms: [String]
  unit: Int
  reservationUnitType: Int
  cancellationRule: Int
  metadataSet: Int
  cancellationTerms: String
  serviceSpecificTerms: String
  pricingTerms: String
  paymentTerms: String
  spaces: [Int]
  resources: [Int]
  intendedUses: [Int]
  equipments: [Int]
  images: [UpdateReservationUnitImageFieldSerializerInput]
  pricings: [UpdateReservationUnitPricingSerializerInput]
  accessTypes: [UpdateReservationUnitAccessTypeSerializerInput]
  applicationRoundTimeSlots: [UpdateApplicationRoundTimeSlotSerializerInput]
}

input UpdateReservationUnitImageFieldSerializerInput {
  imageUrl: Upload!
  largeUrl: String
  mediumUrl: String
  smallUrl: String
  imageType: ReservationUnitImageType
}

input UpdateReservationUnitPricingSerializerInput {
  pk: Int
  begins: Date
  isActivatedOnBegins: Boolean
  paymentType: PaymentType
  priceUnit: PriceUnit
  lowestPrice: Decimal
  lowestPriceNet: String
  highestPrice: Decimal
  highestPriceNet: String
  taxPercentage: Int
  materialPriceDescriptionFi: String
  materialPriceDescriptionEn: String
  materialPriceDescriptionSv: String
}

input UpdateReservationUnitAccessTypeSerializerInput {
  pk: Int
  accessType: AccessType
  beginDate: Date
}

input UpdateApplicationRoundTimeSlotSerializerInput {
  weekday: Weekday!
  isClosed: Boolean
  reservableTimes: [TimeSlotSerializerInput]
}

type ReservationUnitArchiveMutationPayload {
  pk: Int
}

input ReservationUnitArchiveMutationInput {
  pk: Int!
}

type ReservationUnitImageCreateMutationPayload {
  pk: Int
  reservationUnit: Int
  imageType: ReservationUnitImageType
}

input ReservationUnitImageCreateMutationInput {
  pk: Int
  reservationUnit: Int!
  image: Upload!
  imageType: ReservationUnitImageType!
}

type ReservationUnitImageUpdateMutationPayload {
  pk: Int
  imageType: ReservationUnitImageType
}

input ReservationUnitImageUpdateMutationInput {
  pk: Int!
  imageType: ReservationUnitImageType
}

type ReservationUnitImageDeleteMutationPayload {
  deleted: Boolean
}

input ReservationUnitImageDeleteMutationInput {
  pk: ID!
}

type IntendedUseCreateMutationPayload {
  pk: Int
  name: String
  nameFi: String
  nameEn: String
  nameSv: String
}

input IntendedUseCreateMutationInput {
  pk: Int
  name: String!
  nameFi: String
  nameEn: String
  nameSv: String
}

type IntendedUseUpdateMutationPayload {
  pk: Int
  name: String
  nameFi: String
  nameEn: String
  nameSv: String
}

input IntendedUseUpdateMutationInput {
  pk: Int!
  name: String
  nameFi: String
  nameEn: String
  nameSv: String
}

type ReservationCreateMutationPayload {
  pk: Int
}

input ReservationCreateMutationInput {
  pk: Int
  reservationUnit: Int!
  beginsAt: DateTime!
  endsAt: DateTime!
}

type ReservationStaffCreateMutationPayload {
  pk: Int
  name: String
  description: String
  numPersons: Int
  workingMemo: String
  type: ReservationTypeChoice
  municipality: MunicipalityChoice
  beginsAt: DateTime
  endsAt: DateTime
  bufferTimeBefore: Duration
  bufferTimeAfter: Duration
  applyingForFreeOfCharge: Boolean
  freeOfChargeReason: String
  reserveeIdentifier: String
  reserveeFirstName: String
  reserveeLastName: String
  reserveeEmail: String
  reserveePhone: String
  reserveeOrganisationName: String
  reserveeAddressZip: String
  reserveeType: ReserveeType
  ageGroup: Int
  purpose: Int
  state: ReservationStateChoice
  confirmedAt: DateTime
  handledAt: DateTime
}

input ReservationStaffCreateMutationInput {
  pk: Int
  name: String
  description: String
  numPersons: Int
  workingMemo: String
  type: ReservationTypeChoice!
  municipality: MunicipalityChoice
  beginsAt: DateTime!
  endsAt: DateTime!
  bufferTimeBefore: Duration
  bufferTimeAfter: Duration
  applyingForFreeOfCharge: Boolean
  freeOfChargeReason: String
  reserveeIdentifier: String
  reserveeFirstName: String
  reserveeLastName: String
  reserveeEmail: String
  reserveePhone: String
  reserveeOrganisationName: String
  reserveeAddressZip: String
  reserveeType: ReserveeType
  reservationUnit: Int!
  ageGroup: Int
  purpose: Int
}

type ReservationUpdateMutationPayload {
  pk: Int
  name: String
  description: String
  numPersons: Int
  municipality: MunicipalityChoice
  applyingForFreeOfCharge: Boolean
  freeOfChargeReason: String
  reserveeIdentifier: String
  reserveeFirstName: String
  reserveeLastName: String
  reserveeEmail: String
  reserveePhone: String
  reserveeOrganisationName: String
  reserveeAddressZip: String
  reserveeType: ReserveeType
  ageGroup: Int
  purpose: Int
  state: ReservationStateChoice
}

input ReservationUpdateMutationInput {
  pk: Int!
  name: String
  description: String
  numPersons: Int
  municipality: MunicipalityChoice
  applyingForFreeOfCharge: Boolean
  freeOfChargeReason: String
  reserveeIdentifier: String
  reserveeFirstName: String
  reserveeLastName: String
  reserveeEmail: String
  reserveePhone: String
  reserveeOrganisationName: String
  reserveeAddressZip: String
  reserveeType: ReserveeType
  ageGroup: Int
  purpose: Int
}

type ReservationConfirmMutationPayload {
  pk: Int
  state: ReservationStateChoice
  order: PaymentOrderNode
}

input ReservationConfirmMutationInput {
  pk: Int!
}

type ReservationCancellationMutationPayload {
  pk: Int
  cancelReason: ReservationCancelReasonChoice
  cancelDetails: String
  state: ReservationStateChoice
}

input ReservationCancellationMutationInput {
  pk: Int!
  cancelReason: ReservationCancelReasonChoice!
  cancelDetails: String
}

type ReservationDenyMutationPayload {
  pk: Int
  denyReason: Int
  handlingDetails: String
  state: ReservationStateChoice
  handledAt: DateTime
}

input ReservationDenyMutationInput {
  pk: Int!
  denyReason: Int!
  handlingDetails: String!
}

type ReservationDeleteMutationPayload {
  deleted: Boolean
}

input ReservationDeleteMutationInput {
  pk: ID!
}

"""Used only for deleting a reservation before it is confirmed."""
type ReservationDeleteTentativeMutationPayload {
  deleted: Boolean
}

input ReservationDeleteTentativeMutationInput {
  pk: ID!
}

type ReservationApproveMutationPayload {
  pk: Int
  price: Decimal
  handlingDetails: String
  handledAt: DateTime
  state: ReservationStateChoice
}

input ReservationApproveMutationInput {
  pk: Int!
  price: Decimal!
  handlingDetails: String!
}

type ReservationRefundMutationPayload {
  pk: Int
}

input ReservationRefundMutationInput {
  pk: Int!
}

type ReservationRequiresHandlingMutationPayload {
  pk: Int
  state: ReservationStateChoice
}

input ReservationRequiresHandlingMutationInput {
  pk: Int!
}

type ReservationWorkingMemoMutationPayload {
  pk: Int
  workingMemo: String
}

input ReservationWorkingMemoMutationInput {
  pk: Int!
  workingMemo: String!
}

type ReservationAdjustTimeMutationPayload {
  pk: Int
  beginsAt: DateTime
  endsAt: DateTime
  state: ReservationStateChoice
}

input ReservationAdjustTimeMutationInput {
  pk: Int!
  beginsAt: DateTime!
  endsAt: DateTime!
}

type ReservationStaffAdjustTimeMutationPayload {
  pk: Int
  beginsAt: DateTime
  endsAt: DateTime
  bufferTimeBefore: Duration
  bufferTimeAfter: Duration
  state: ReservationStateChoice
}

input ReservationStaffAdjustTimeMutationInput {
  pk: Int!
  beginsAt: DateTime
  endsAt: DateTime
  bufferTimeBefore: Duration
  bufferTimeAfter: Duration
}

type ReservationStaffModifyMutationPayload {
  pk: Int
  name: String
  description: String
  numPersons: Int
  type: ReservationTypeChoice
  municipality: MunicipalityChoice
  applyingForFreeOfCharge: Boolean
  freeOfChargeReason: String
  reserveeFirstName: String
  reserveeLastName: String
  reserveePhone: String
  reserveeOrganisationName: String
  reserveeAddressZip: String
  reserveeEmail: String
  reserveeType: ReserveeType
  reserveeIdentifier: String
  ageGroup: Int
  purpose: Int
  confirmedAt: DateTime
  state: ReservationStateChoice
  beginsAt: DateTime
  endsAt: DateTime
  bufferTimeAfter: Duration
  bufferTimeBefore: Duration
  price: Decimal
  priceNet: String
  nonSubsidisedPrice: Decimal
  nonSubsidisedPriceNet: String
  taxPercentageValue: Decimal
  unitPrice: Decimal
}

input ReservationStaffModifyMutationInput {
  pk: Int!
  name: String
  description: String
  numPersons: Int
  type: ReservationTypeChoice
  municipality: MunicipalityChoice
  applyingForFreeOfCharge: Boolean
  freeOfChargeReason: String
  reserveeFirstName: String
  reserveeLastName: String
  reserveePhone: String
  reserveeOrganisationName: String
  reserveeAddressZip: String
  reserveeEmail: String
  reserveeType: ReserveeType
  reserveeIdentifier: String
  ageGroup: Int
  purpose: Int
}

type ReservationStaffChangeAccessCodeMutationPayload {
  pk: Int
  accessCodeGeneratedAt: DateTime
  accessCodeIsActive: Boolean
}

input ReservationStaffChangeAccessCodeMutationInput {
  pk: Int!
}

type ReservationStaffRepairAccessCodeMutationPayload {
  pk: Int
  accessCodeGeneratedAt: DateTime
  accessCodeIsActive: Boolean
}

input ReservationStaffRepairAccessCodeMutationInput {
  pk: Int!
}

type ReservationSeriesCreateMutationPayload {
  pk: Int
  name: String
  description: String
  reservationUnit: Int
  ageGroup: Int
  recurrenceInDays: Int
  weekdays: [Weekday]
  beginTime: Time
  endTime: Time
  beginDate: Date
  endDate: Date
}

input ReservationSeriesCreateMutationInput {
  pk: Int
  name: String
  description: String
  reservationUnit: Int!
  ageGroup: Int
  recurrenceInDays: Int!
  weekdays: [Weekday]!
  beginTime: Time!
  endTime: Time!
  beginDate: Date!
  endDate: Date!
  reservationDetails: ReservationSeriesReservationCreateSerializerInput!
  checkOpeningHours: Boolean
  skipDates: [Date]
}

input ReservationSeriesReservationCreateSerializerInput {
  name: String
  description: String
  numPersons: Int
  state: ReservationStateChoice
  type: ReservationTypeStaffChoice!
  workingMemo: String
  bufferTimeBefore: Duration
  bufferTimeAfter: Duration
  handledAt: DateTime
  confirmedAt: DateTime
  applyingForFreeOfCharge: Boolean
  freeOfChargeReason: String
  reserveeIdentifier: String
  reserveeFirstName: String
  reserveeLastName: String
  reserveeEmail: String
  reserveePhone: String
  reserveeOrganisationName: String
  reserveeAddressZip: String
  reserveeType: ReserveeType
  user: Int!
  purpose: Int
  municipality: MunicipalityChoice
  ageGroup: Int
}

"""An enumeration."""
enum ReservationTypeStaffChoice {
  """Blocked"""
  BLOCKED

  """Staff"""
  STAFF

  """Behalf"""
  BEHALF
}

type ReservationSeriesUpdateMutationPayload {
  pk: Int
  name: String
  description: String
  ageGroup: Int
}

input ReservationSeriesUpdateMutationInput {
  pk: Int!
  name: String
  description: String
  ageGroup: Int
  reservationDetails: UpdateReservationSeriesReservationUpdateSerializerInput
  skipReservations: [Int]
}

input UpdateReservationSeriesReservationUpdateSerializerInput {
  name: String
  description: String
  numPersons: Int
  workingMemo: String
  applyingForFreeOfCharge: Boolean
  freeOfChargeReason: String
  reserveeIdentifier: String
  reserveeFirstName: String
  reserveeLastName: String
  reserveeEmail: String
  reserveePhone: String
  reserveeOrganisationName: String
  reserveeAddressZip: String
  reserveeType: ReserveeType
  purpose: Int
  municipality: MunicipalityChoice
  ageGroup: Int
}

type ReservationSeriesAddMutationPayload {
  pk: Int
}

input ReservationSeriesAddMutationInput {
  pk: Int!
  beginsAt: DateTime!
  endsAt: DateTime!
  bufferTimeBefore: String
  bufferTimeAfter: String
}

type ReservationSeriesRescheduleMutationPayload {
  pk: Int
  beginDate: Date
  beginTime: Time
  endDate: Date
  endTime: Time
  weekdays: [Weekday]
}

input ReservationSeriesRescheduleMutationInput {
  pk: Int!
  beginDate: Date
  beginTime: Time
  endDate: Date
  endTime: Time
  weekdays: [Weekday]
  skipDates: [Date]
  bufferTimeBefore: String
  bufferTimeAfter: String
}

type ReservationSeriesDenyMutationPayload {
  denied: Int
  future: Int
}

input ReservationSeriesDenyMutationInput {
  pk: Int!
  denyReason: Int!
  handlingDetails: String
}

type ReservationSeriesChangeAccessCodeMutationPayload {
  pk: Int
  accessCodeGeneratedAt: DateTime
  accessCodeIsActive: Boolean
}

input ReservationSeriesChangeAccessCodeMutationInput {
  pk: Int!
}

type ReservationSeriesRepairAccessCodeMutationPayload {
  pk: Int
  accessCodeGeneratedAt: DateTime
  accessCodeIsActive: Boolean
}

input ReservationSeriesRepairAccessCodeMutationInput {
  pk: Int!
}

type CurrentUserUpdateMutationPayload {
  pk: Int
  preferredLanguage: Language
}

"""An enumeration."""
enum Language {
  """Finnish"""
  FI

  """Swedish"""
  SV

  """English"""
  EN
}

input CurrentUserUpdateMutationInput {
  preferredLanguage: Language
}

type UserStaffUpdateMutationPayload {
  pk: Int
  reservationNotification: ReservationNotification
}

input UserStaffUpdateMutationInput {
  pk: Int!
  reservationNotification: ReservationNotification
}

type BannerNotificationCreateMutationPayload {
  pk: Int
  name: String
  message: String
  messageFi: String
  messageEn: String
  messageSv: String
  draft: Boolean
  level: BannerNotificationLevel
  target: BannerNotificationTarget
  activeFrom: DateTime
  activeUntil: DateTime
}

input BannerNotificationCreateMutationInput {
  pk: Int
  name: String!
  message: String
  messageFi: String
  messageEn: String
  messageSv: String
  draft: Boolean
  level: BannerNotificationLevel!
  target: BannerNotificationTarget!
  activeFrom: DateTime
  activeUntil: DateTime
}

type BannerNotificationUpdateMutationPayload {
  pk: Int
  name: String
  message: String
  messageFi: String
  messageEn: String
  messageSv: String
  draft: Boolean
  level: BannerNotificationLevel
  target: BannerNotificationTarget
  activeFrom: DateTime
  activeUntil: DateTime
}

input BannerNotificationUpdateMutationInput {
  pk: Int!
  name: String
  message: String
  messageFi: String
  messageEn: String
  messageSv: String
  draft: Boolean
  level: BannerNotificationLevel
  target: BannerNotificationTarget
  activeFrom: DateTime
  activeUntil: DateTime
}

type BannerNotificationDeleteMutationPayload {
  deleted: Boolean
}

input BannerNotificationDeleteMutationInput {
  pk: ID!
}
