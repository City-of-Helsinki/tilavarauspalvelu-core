"""
Indicate the complexity of resolving a field, counted towards
the maximum query complexity of resolving a root type field.
"""
directive @complexity(
  value: Int!
) on FIELD_DEFINITION

"""
Indicates exactly one field must be supplied and this field must not be `null`.
"""
directive @oneOf on INPUT_OBJECT

"""
Represents a date value as specified by ISO 8601.
Maps to the Python `datetime.date` type.
"""
scalar Date @specifiedBy(url: "https://datatracker.ietf.org/doc/html/rfc3339#section-5.6")

"""
Represents a date and time value as specified by ISO 8601.
Maps to the Python `datetime.datetime` type.
"""
scalar DateTime @specifiedBy(url: "https://datatracker.ietf.org/doc/html/rfc3339#section-5.6")

"""
Represents a number as a string for correctly rounded floating point arithmetic.
Maps to the Python `decimal.Decimal` type.
"""
scalar Decimal

"""
Represents a duration of time in seconds.
Maps to the Python `datetime.timedelta` type.
"""
scalar Duration

"""Represents a valid email address."""
scalar Email @specifiedBy(url: "https://datatracker.ietf.org/doc/html/rfc5322#section-3.4.1")

"""Represents an image file."""
scalar Image

"""
Represents a time value as specified by ISO 8601.
Maps to the Python `datetime.time` type.
"""
scalar Time @specifiedBy(url: "https://datatracker.ietf.org/doc/html/rfc3339#section-5.6")

"""Represents a valid URL."""
scalar URL @specifiedBy(url: "https://datatracker.ietf.org/doc/html/rfc3986")

"""
Represents a universally unique identifier string.
Maps to Python's `uuid.UUID` type.
"""
scalar UUID @specifiedBy(url: "https://datatracker.ietf.org/doc/html/rfc9562")

"""The state of the access code."""
enum AccessCodeState {
  """Access code not required"""
  ACCESS_CODE_NOT_REQUIRED
  """Access code created"""
  ACCESS_CODE_CREATED
  """Access code pending"""
  ACCESS_CODE_PENDING
}

"""How is the reservee able to enter the space in their reservation unit?"""
enum AccessType {
  """access code"""
  ACCESS_CODE
  """opened by staff"""
  OPENED_BY_STAFF
  """physical key"""
  PHYSICAL_KEY
  """unrestricted"""
  UNRESTRICTED
}

"""
Same as AccessType, but includes the 'MULTIVALUED' option
for series and seasonal bookings where access type between reservations varies.
"""
enum AccessTypeWithMultivalued {
  """access code"""
  ACCESS_CODE
  """opened by staff"""
  OPENED_BY_STAFF
  """physical key"""
  PHYSICAL_KEY
  """unrestricted"""
  UNRESTRICTED
  """multi-valued"""
  MULTIVALUED
}

enum AllocatedTimeSlotOrderSet {
  allocatedReservationUnitNameEnAsc
  allocatedReservationUnitNameEnDesc
  allocatedReservationUnitNameFiAsc
  allocatedReservationUnitNameFiDesc
  allocatedReservationUnitNameSvAsc
  allocatedReservationUnitNameSvDesc
  allocatedTimeOfWeekAsc
  allocatedTimeOfWeekDesc
  allocatedUnitNameEnAsc
  allocatedUnitNameEnDesc
  allocatedUnitNameFiAsc
  allocatedUnitNameFiDesc
  allocatedUnitNameSvAsc
  allocatedUnitNameSvDesc
  applicantAsc
  applicantDesc
  applicationPkAsc
  applicationPkDesc
  applicationSectionNameAsc
  applicationSectionNameDesc
  applicationSectionPkAsc
  applicationSectionPkDesc
  applicationSectionStatusAsc
  applicationSectionStatusDesc
  applicationStatusAsc
  applicationStatusDesc
  dayOfTheWeekAsc
  dayOfTheWeekDesc
  pkAsc
  pkDesc
}

enum ApplicationOrderSet {
  applicantAsc
  applicantDesc
  applicantTypeAsc
  applicantTypeDesc
  pkAsc
  pkDesc
  preferredUnitNameEnAsc
  preferredUnitNameEnDesc
  preferredUnitNameFiAsc
  preferredUnitNameFiDesc
  preferredUnitNameSvAsc
  preferredUnitNameSvDesc
  sentAtAsc
  sentAtDesc
  statusAsc
  statusDesc
}

enum ApplicationRoundOrderSet {
  pkAsc
  pkDesc
}

enum ApplicationRoundReservationCreationStatusChoice {
  """Not completed"""
  NOT_COMPLETED
  """Completed"""
  COMPLETED
  """Failed"""
  FAILED
}

enum ApplicationRoundStatusChoice {
  """Upcoming"""
  UPCOMING
  """Open"""
  OPEN
  """In Allocation"""
  IN_ALLOCATION
  """Handled"""
  HANDLED
  """Results Sent"""
  SENT
}

enum ApplicationSectionOrderSet {
  allocationsAsc
  allocationsDesc
  applicantAsc
  applicantDesc
  applicationAsc
  applicationDesc
  applicationStatusAsc
  applicationStatusDesc
  hasAllocationsAsc
  hasAllocationsDesc
  nameAsc
  nameDesc
  pkAsc
  pkDesc
  preferredUnitNameEnAsc
  preferredUnitNameEnDesc
  preferredUnitNameFiAsc
  preferredUnitNameFiDesc
  preferredUnitNameSvAsc
  preferredUnitNameSvDesc
  statusAsc
  statusDesc
}

enum ApplicationSectionStatusChoice {
  """Unallocated"""
  UNALLOCATED
  """In Allocation"""
  IN_ALLOCATION
  """Handled"""
  HANDLED
  """Rejected"""
  REJECTED
}

enum ApplicationStatusChoice {
  """Draft"""
  DRAFT
  """Received"""
  RECEIVED
  """In Allocation"""
  IN_ALLOCATION
  """Handled"""
  HANDLED
  """Results Sent"""
  RESULTS_SENT
  """Expired"""
  EXPIRED
  """Cancelled"""
  CANCELLED
}

enum AuthenticationType {
  """Weak"""
  weak
  """Strong"""
  strong
}

enum BannerNotificationLevel {
  """Exception"""
  EXCEPTION
  """Warning"""
  WARNING
  """Normal"""
  NORMAL
}

enum BannerNotificationOrderSet {
  endsAsc
  endsDesc
  levelAsc
  levelDesc
  nameAsc
  nameDesc
  pkAsc
  pkDesc
  startsAsc
  startsDesc
  stateAsc
  stateDesc
  targetAsc
  targetDesc
}

enum BannerNotificationState {
  """Draft"""
  DRAFT
  """Scheduled"""
  SCHEDULED
  """Active"""
  ACTIVE
}

enum BannerNotificationTarget {
  """All"""
  ALL
  """Staff"""
  STAFF
  """User"""
  USER
}

enum EquipmentCategoryOrderSet {
  pkAsc
  pkDesc
}

enum EquipmentOrderSet {
  categoryRankAsc
  categoryRankDesc
  nameAsc
  nameDesc
  nameEnAsc
  nameEnDesc
  nameFiAsc
  nameFiDesc
  nameSvAsc
  nameSvDesc
}

enum LoginMethod {
  """PROFILE"""
  PROFILE
  """AD"""
  AD
  """OTHER"""
  OTHER
}

"""Municipality choices"""
enum MunicipalityChoice {
  """Helsinki"""
  HELSINKI
  """Other"""
  OTHER
}

enum OrderStatus {
  """Draft"""
  DRAFT
  """Pending"""
  PENDING
  """Expired"""
  EXPIRED
  """Cancelled"""
  CANCELLED
  """Paid"""
  PAID
  """Paid by invoice"""
  PAID_BY_INVOICE
  """Paid manually"""
  PAID_MANUALLY
  """Refunded"""
  REFUNDED
}

"""
Same as OrderStatus, but includes the 'FREE' option used for filtering reservations without payments.
"""
enum OrderStatusWithFree {
  """Draft"""
  DRAFT
  """Pending"""
  PENDING
  """Expired"""
  EXPIRED
  """Cancelled"""
  CANCELLED
  """Paid"""
  PAID
  """Paid manually"""
  PAID_MANUALLY
  """Paid by invoice"""
  PAID_BY_INVOICE
  """Refunded"""
  REFUNDED
  """Free"""
  FREE
}

enum PaymentType {
  """On site"""
  ON_SITE
  """Online"""
  ONLINE
  """Online or invoice"""
  ONLINE_OR_INVOICE
}

enum PriceUnit {
  """per 15 minutes"""
  per_15_mins
  """per 30 minutes"""
  per_30_mins
  """per hour"""
  per_hour
  """per half a day"""
  per_half_day
  """per day"""
  per_day
  """per week"""
  per_week
  """fixed"""
  fixed
}

enum Priority {
  """Primary"""
  PRIMARY
  """Secondary"""
  SECONDARY
}

enum PurposeOrderSet {
  nameEnAsc
  nameEnDesc
  nameFiAsc
  nameFiDesc
  nameSvAsc
  nameSvDesc
  pkAsc
  pkDesc
  rankAsc
  rankDesc
}

enum RejectedOccurrenceOrderSet {
  applicantAsc
  applicantDesc
  applicationPkAsc
  applicationPkDesc
  applicationSectionNameAsc
  applicationSectionNameDesc
  applicationSectionPkAsc
  applicationSectionPkDesc
  beginDatetimeAsc
  beginDatetimeDesc
  endDatetimeAsc
  endDatetimeDesc
  pkAsc
  pkDesc
  rejectionReasonAsc
  rejectionReasonDesc
  reservationUnitNameAsc
  reservationUnitNameDesc
  reservationUnitPkAsc
  reservationUnitPkDesc
  unitNameAsc
  unitNameDesc
  unitPkAsc
  unitPkDesc
}

enum RejectionReadinessChoice {
  """Interval not allowed"""
  INTERVAL_NOT_ALLOWED
  """Overlapping reservations"""
  OVERLAPPING_RESERVATIONS
  """Reservation unit closed"""
  RESERVATION_UNIT_CLOSED
}

"""Reasons why user has cancelled their reservation"""
enum ReservationCancelReasonChoice {
  """My plans have changed"""
  CHANGE_OF_PLANS
  """I found another space somewhere else"""
  FOUND_ANOTHER_SPACE_ELSEWHERE
  """I found another space through Varaamo"""
  FOUND_ANOTHER_SPACE_VARAAMO
  """The space is not suitable for my purpose"""
  UNSUITABLE_SPACE
  """The booking processing time is too long"""
  PROCESSING_TIME_TOO_LONG
  """Other reason"""
  OTHER
  """
  The booking was not paid for or invoice was not selected as the payment method by the deadline.
  """
  NOT_PAID
}

enum ReservationDenyReasonOrderSet {
  pkAsc
  pkDesc
  rankAsc
  rankDesc
  reasonAsc
  reasonDesc
}

"""Reservation forms for that are supported by the system."""
enum ReservationFormType {
  """Contact information only"""
  CONTACT_INFO_FORM
  """Contact information and event description"""
  RESERVEE_INFO_FORM
  """Purpose of use"""
  PURPOSE_FORM
  """Age group"""
  AGE_GROUP_FORM
  """Purpose of use + discount"""
  PURPOSE_SUBVENTION_FORM
  """Age group + discount"""
  AGE_GROUP_SUBVENTION_FORM
}

enum ReservationKind {
  """Direct"""
  DIRECT
  """Season"""
  SEASON
  """Direct and season"""
  DIRECT_AND_SEASON
}

"""When user wants to receive reservation notification emails."""
enum ReservationNotification {
  """All"""
  all
  """Only Handling Required"""
  only_handling_required
  """None"""
  none
}

enum ReservationOrderSet {
  beginsAtAsc
  beginsAtDesc
  createdAtAsc
  createdAtDesc
  endsAtAsc
  endsAtDesc
  nameAsc
  nameDesc
  orderStatusAsc
  orderStatusDesc
  pkAsc
  pkDesc
  priceAsc
  priceDesc
  reservationUnitNameEnAsc
  reservationUnitNameEnDesc
  reservationUnitNameFiAsc
  reservationUnitNameFiDesc
  reservationUnitNameSvAsc
  reservationUnitNameSvDesc
  reserveeNameAsc
  reserveeNameDesc
  stateAsc
  stateDesc
  unitNameEnAsc
  unitNameEnDesc
  unitNameFiAsc
  unitNameFiDesc
  unitNameSvAsc
  unitNameSvDesc
}

enum ReservationPurposeOrderSet {
  nameEnAsc
  nameEnDesc
  nameFiAsc
  nameFiDesc
  nameSvAsc
  nameSvDesc
  pkAsc
  pkDesc
  rankAsc
  rankDesc
}

enum ReservationStartInterval {
  """15 minutes"""
  interval_15_mins
  """30 minutes"""
  interval_30_mins
  """60 minutes"""
  interval_60_mins
  """90 minutes"""
  interval_90_mins
  """2 hours"""
  interval_120_mins
  """3 hours"""
  interval_180_mins
  """4 hours"""
  interval_240_mins
  """5 hours"""
  interval_300_mins
  """6 hours"""
  interval_360_mins
  """7 hours"""
  interval_420_mins
}

enum ReservationStateChoice {
  """Created"""
  CREATED
  """Cancelled"""
  CANCELLED
  """Requires handling"""
  REQUIRES_HANDLING
  """Waiting for payment"""
  WAITING_FOR_PAYMENT
  """Confirmed"""
  CONFIRMED
  """Denied"""
  DENIED
}

enum ReservationTypeChoice {
  """Normal"""
  NORMAL
  """Blocked"""
  BLOCKED
  """Staff"""
  STAFF
  """Behalf"""
  BEHALF
  """Seasonal"""
  SEASONAL
}

enum ReservationTypeStaffChoice {
  """Blocked"""
  BLOCKED
  """Staff"""
  STAFF
  """Behalf"""
  BEHALF
}

enum ReservationUnitAccessTypeOrderSet {
  beginDateAsc
  beginDateDesc
  pkAsc
  pkDesc
}

enum ReservationUnitAllOrderSet {
  nameEnAsc
  nameEnDesc
  nameFiAsc
  nameFiDesc
  nameSvAsc
  nameSvDesc
  pkAsc
  pkDesc
  rankAsc
  rankDesc
}

enum ReservationUnitCancellationRuleOrderSet {
  pkAsc
  pkDesc
}

enum ReservationUnitImageType {
  """Main image"""
  main
  """Other"""
  other
}

enum ReservationUnitOptionOrderSet {
  pkAsc
  pkDesc
}

enum ReservationUnitOrderSet {
  maxPersonsAsc
  maxPersonsDesc
  nameEnAsc
  nameEnDesc
  nameFiAsc
  nameFiDesc
  nameSvAsc
  nameSvDesc
  pkAsc
  pkDesc
  rankAsc
  rankDesc
  surfaceAreaAsc
  surfaceAreaDesc
  typeEnAsc
  typeEnDesc
  typeFiAsc
  typeFiDesc
  typeRankAsc
  typeRankDesc
  typeSvAsc
  typeSvDesc
  unitNameEnAsc
  unitNameEnDesc
  unitNameFiAsc
  unitNameFiDesc
  unitNameSvAsc
  unitNameSvDesc
}

enum ReservationUnitPublishingState {
  """Draft"""
  DRAFT
  """Scheduled publishing"""
  SCHEDULED_PUBLISHING
  """Scheduled hiding"""
  SCHEDULED_HIDING
  """Scheduled period"""
  SCHEDULED_PERIOD
  """Hidden"""
  HIDDEN
  """Published"""
  PUBLISHED
  """Archived"""
  ARCHIVED
}

enum ReservationUnitReservationState {
  """Scheduled reservation"""
  SCHEDULED_RESERVATION
  """Scheduled period"""
  SCHEDULED_PERIOD
  """Reservable"""
  RESERVABLE
  """Scheduled closing"""
  SCHEDULED_CLOSING
  """Reservation closed"""
  RESERVATION_CLOSED
}

enum ReservationUnitTypeOrderSet {
  nameEnAsc
  nameEnDesc
  nameFiAsc
  nameFiDesc
  nameSvAsc
  nameSvDesc
  pkAsc
  pkDesc
  rankAsc
  rankDesc
}

enum ReserveeType {
  """Individual"""
  INDIVIDUAL
  """Company"""
  COMPANY
  """Nonprofit"""
  NONPROFIT
}

enum ResourceLocationType {
  """Fixed"""
  fixed
  """Movable"""
  movable
}

enum ResourceOrderSet {
  locationTypeAsc
  locationTypeDesc
  nameAsc
  nameDesc
  pkAsc
  pkDesc
  spaceAsc
  spaceDesc
}

enum SpaceOrderSet {
  pkAsc
  pkDesc
}

enum SuitableTimeRangeOrderSet {
  pkAsc
  pkDesc
}

enum TaxPercentageOrderSet {
  pkAsc
  pkDesc
}

enum TermsOfUseOrderSet {
  pkAsc
  pkDesc
}

enum TermsOfUseTypeChoices {
  """Generic terms"""
  generic_terms
  """Payment terms"""
  payment_terms
  """Cancellation terms"""
  cancellation_terms
  """Reservation series terms"""
  recurring_terms
  """Service-specific terms"""
  service_terms
  """Pricing terms"""
  pricing_terms
}

enum UnitOrderSet {
  nameEnAsc
  nameEnDesc
  nameFiAsc
  nameFiDesc
  nameSvAsc
  nameSvDesc
  pkAsc
  pkDesc
  rankAsc
  rankDesc
  reservationCountAsc
  reservationCountDesc
  reservationUnitsCountAsc
  reservationUnitsCountDesc
  unitGroupNameEnAsc
  unitGroupNameEnDesc
  unitGroupNameFiAsc
  unitGroupNameFiDesc
  unitGroupNameSvAsc
  unitGroupNameSvDesc
}

enum UserPermissionChoice {
  """
  Permission required to create different types of reservations,
  like those on behalf of another user, or once that block reservable time.,
  or to create or modify reservation series.
  """
  CAN_CREATE_STAFF_RESERVATIONS
  """
  This permission is required to modify applications and application sections
  that are not the user's own, as well as any application rounds.
  """
  CAN_MANAGE_APPLICATIONS
  """Permission required to manage banner notifications."""
  CAN_MANAGE_NOTIFICATIONS
  """
  Permission required to modify reservations that are not the user's own.
  """
  CAN_MANAGE_RESERVATIONS
  """
  Permission required to create and modify data related to reservations,
  like equipment, categories, purposes, and age groups.
  """
  CAN_MANAGE_RESERVATION_RELATED_DATA
  """
  Permission required to create and modify data related to reservation units
  like reservation units, images, payment info, units, spaces, and resources.
  """
  CAN_MANAGE_RESERVATION_UNITS
  """
  Permission required to view applications and application sections
  that are not the user's own.
  """
  CAN_VIEW_APPLICATIONS
  """
  Permission required to view reservation data, and comment on them,
  as well as to view some restricted information on reservation series.
  """
  CAN_VIEW_RESERVATIONS
  """Permission required to view user data."""
  CAN_VIEW_USERS
}

"""Which roles a user can have."""
enum UserRoleChoice {
  """Admin"""
  ADMIN
  """Handler"""
  HANDLER
  """Viewer"""
  VIEWER
  """Reserver"""
  RESERVER
  """Notification manager"""
  NOTIFICATION_MANAGER
}

enum Weekday {
  """Monday"""
  MONDAY
  """Tuesday"""
  TUESDAY
  """Wednesday"""
  WEDNESDAY
  """Thursday"""
  THURSDAY
  """Friday"""
  FRIDAY
  """Saturday"""
  SATURDAY
  """Sunday"""
  SUNDAY
}

"""An interface for objects with Global IDs."""
interface Node {
  """The Global ID of an object."""
  id: ID!
}

type AgeGroupNode implements Node {
  """The Global ID of an object."""
  id: ID!
  maximum: Int
  minimum: Int!
  pk: Int!
}

type AllocatedTimeSlotDeleteMutationOutput {
  pk: Int!
}

type AllocatedTimeSlotNode implements Node {
  beginTime: Time!
  dayOfTheWeek: Weekday!
  endTime: Time!
  """The Global ID of an object."""
  id: ID!
  pk: Int!
  reservationSeries: ReservationSeriesNode @complexity(value: 1)
  reservationUnitOption: ReservationUnitOptionNode! @complexity(value: 1)
}

"""A connection to a list of items."""
type AllocatedTimeSlotNodeConnection {
  """Total number of items in the connection."""
  totalCount: Int!
  """Information about the current state of the pagination."""
  pageInfo: PageInfo!
  """The items in the connection."""
  edges: [AllocatedTimeSlotNodeEdge]
}

"""An object describing an item in the connection."""
type AllocatedTimeSlotNodeEdge {
  """A value identifying this edge for pagination purposes."""
  cursor: String!
  """An item in the connection."""
  node: AllocatedTimeSlotNode
}

type ApplicationNode implements Node {
  additionalInformation: String!
  applicantType: ReserveeType
  applicationRound: ApplicationRoundNode! @complexity(value: 1)
  applicationSections(
    filter: ApplicationSectionFilterSet
    orderBy: [ApplicationSectionOrderSet!]
  ): [ApplicationSectionNode!]! @complexity(value: 1)
  billingCity: String!
  billingPostCode: String!
  billingStreetAddress: String!
  cancelledAt: DateTime
  contactPersonEmail: Email
  contactPersonFirstName: String!
  contactPersonLastName: String!
  contactPersonPhoneNumber: String!
  createdAt: DateTime!
  """The Global ID of an object."""
  id: ID!
  municipality: MunicipalityChoice
  organisationActiveMembers: Int
  organisationCity: String!
  organisationCoreBusiness: String!
  organisationEmail: Email
  organisationIdentifier: String!
  organisationName: String!
  organisationPostCode: String!
  organisationStreetAddress: String!
  organisationYearEstablished: Int
  pk: Int!
  sentAt: DateTime
  status: ApplicationStatusChoice!
  updatedAt: DateTime!
  user: UserNode! @complexity(value: 1)
  workingMemo: String!
}

"""A connection to a list of items."""
type ApplicationNodeConnection {
  """Total number of items in the connection."""
  totalCount: Int!
  """Information about the current state of the pagination."""
  pageInfo: PageInfo!
  """The items in the connection."""
  edges: [ApplicationNodeEdge]
}

"""An object describing an item in the connection."""
type ApplicationNodeEdge {
  """A value identifying this edge for pagination purposes."""
  cursor: String!
  """An item in the connection."""
  node: ApplicationNode
}

type ApplicationRoundNode implements Node {
  applicationPeriodBeginsAt: DateTime!
  applicationPeriodEndsAt: DateTime!
  applicationsCount: Int!
  criteriaEn: String
  criteriaFi: String
  criteriaSv: String
  handledAt: DateTime
  """The Global ID of an object."""
  id: ID!
  isSettingHandledAllowed: Boolean!
  nameEn: String
  nameFi: String
  nameSv: String
  notesWhenApplyingEn: String
  notesWhenApplyingFi: String
  notesWhenApplyingSv: String
  pk: Int!
  publicDisplayBeginsAt: DateTime!
  publicDisplayEndsAt: DateTime!
  purposes(
    filter: ReservationPurposeFilterSet
    orderBy: [ReservationPurposeOrderSet!]
  ): [ReservationPurposeNode!]! @complexity(value: 1)
  reservationCreationStatus: ApplicationRoundReservationCreationStatusChoice!
  reservationPeriodBeginDate: Date!
  reservationPeriodEndDate: Date!
  reservationUnitCount: Int!
  reservationUnits(
    filter: ReservationUnitFilterSet
    orderBy: [ReservationUnitOrderSet!]
  ): [ReservationUnitNode!]! @complexity(value: 1)
  sentAt: DateTime
  status: ApplicationRoundStatusChoice!
  statusTimestamp: DateTime
  termsOfUse: TermsOfUseNode @complexity(value: 1)
}

"""A connection to a list of items."""
type ApplicationRoundNodeConnection {
  """Total number of items in the connection."""
  totalCount: Int!
  """Information about the current state of the pagination."""
  pageInfo: PageInfo!
  """The items in the connection."""
  edges: [ApplicationRoundNodeEdge]
}

"""An object describing an item in the connection."""
type ApplicationRoundNodeEdge {
  """A value identifying this edge for pagination purposes."""
  cursor: String!
  """An item in the connection."""
  node: ApplicationRoundNode
}

type ApplicationRoundTimeSlotNode implements Node {
  """The Global ID of an object."""
  id: ID!
  isClosed: Boolean!
  pk: Int!
  reservableTimes: [TimeSlotType!]!
  weekday: Weekday!
}

type ApplicationSectionNode implements Node {
  ageGroup: AgeGroupNode @complexity(value: 1)
  allocations: Int!
  application: ApplicationNode! @complexity(value: 1)
  appliedReservationsPerWeek: Int!
  extUuid: UUID!
  hasReservations: Boolean!
  """The Global ID of an object."""
  id: ID!
  name: String!
  numPersons: Int!
  """
  Info fetched from Pindora API. Cached per reservation for 30s.
  Please don't use this when filtering multiple sections, queries to Pindora are not optimized.
  """
  pindoraInfo: PindoraSectionInfoType
  pk: Int!
  purpose: ReservationPurposeNode @complexity(value: 1)
  reservationMaxDuration: Duration!
  reservationMinDuration: Duration!
  reservationUnitOptions(
    filter: ReservationUnitOptionFilterSet
    orderBy: [ReservationUnitOptionOrderSet!]
  ): [ReservationUnitOptionNode!]! @complexity(value: 1)
  reservationsBeginDate: Date!
  reservationsEndDate: Date!
  shouldHaveActiveAccessCode: Boolean!
  status: ApplicationSectionStatusChoice!
  suitableTimeRanges(
    filter: SuitableTimeRangeFilterSet
    orderBy: [SuitableTimeRangeOrderSet!]
  ): [SuitableTimeRangeNode!]! @complexity(value: 1)
}

"""A connection to a list of items."""
type ApplicationSectionNodeConnection {
  """Total number of items in the connection."""
  totalCount: Int!
  """Information about the current state of the pagination."""
  pageInfo: PageInfo!
  """The items in the connection."""
  edges: [ApplicationSectionNodeEdge]
}

"""An object describing an item in the connection."""
type ApplicationSectionNodeEdge {
  """A value identifying this edge for pagination purposes."""
  cursor: String!
  """An item in the connection."""
  node: ApplicationSectionNode
}

type ApplicationSectionReservationCancellationMutationOutputType {
  future: Int!
  cancelled: Int!
}

type AppliedPricingInfoType {
  begins: Date!
  priceUnit: PriceUnit!
  lowestPrice: Decimal!
  highestPrice: Decimal!
  taxPercentage: Decimal!
  materialPriceDescriptionFi: String!
  materialPriceDescriptionEn: String!
  materialPriceDescriptionSv: String!
}

type BannerNotificationDeleteMutationOutput {
  pk: Int!
}

type BannerNotificationNode implements Node {
  activeFrom: DateTime
  activeUntil: DateTime
  draft: Boolean!
  """The Global ID of an object."""
  id: ID!
  level: BannerNotificationLevel!
  messageEn: String
  messageFi: String
  messageSv: String
  name: String!
  pk: Int!
  state: BannerNotificationState!
  target: BannerNotificationTarget!
}

"""A connection to a list of items."""
type BannerNotificationNodeConnection {
  """Total number of items in the connection."""
  totalCount: Int!
  """Information about the current state of the pagination."""
  pageInfo: PageInfo!
  """The items in the connection."""
  edges: [BannerNotificationNodeEdge]
}

"""An object describing an item in the connection."""
type BannerNotificationNodeEdge {
  """A value identifying this edge for pagination purposes."""
  cursor: String!
  """An item in the connection."""
  node: BannerNotificationNode
}

type EquipmentCategoryNode implements Node {
  """The Global ID of an object."""
  id: ID!
  nameEn: String
  nameFi: String
  nameSv: String
  pk: Int!
  rank: Int!
}

type EquipmentNode implements Node {
  category: EquipmentCategoryNode! @complexity(value: 1)
  """The Global ID of an object."""
  id: ID!
  nameEn: String
  nameFi: String
  nameSv: String
  pk: Int!
}

type GeneralRoleNode implements Node {
  assigner: UserNode @complexity(value: 1)
  createdAt: DateTime!
  """The Global ID of an object."""
  id: ID!
  permissions: [UserPermissionChoice!]!
  pk: Int!
  role: UserRoleChoice!
  updatedAt: DateTime!
  user: UserNode! @complexity(value: 1)
}

"""Information about the current state of the pagination."""
type PageInfo {
  """Are there more items after the current page?"""
  hasNextPage: Boolean!
  """Are there more items before the current page?"""
  hasPreviousPage: Boolean!
  """
  Value of the first cursor in the current page. Use as the value for the `before` argument to paginate backwards.
  """
  startCursor: String
  """
  Value of the last cursor in the current page. Use as the value for the `after` argument to paginate forwards.
  """
  endCursor: String
}

type PaymentMerchantNode implements Node {
  """The Global ID of an object."""
  id: ID!
  name: String!
  pk: UUID!
}

type PaymentOrderNode implements Node {
  checkoutUrl: String
  createdAt: DateTime!
  expiresInMinutes: Int
  handledPaymentDueBy: DateTime
  """The Global ID of an object."""
  id: ID!
  orderUuid: UUID
  paymentType: PaymentType!
  processedAt: DateTime
  receiptUrl: String
  refundUuid: UUID
  reservation: ReservationNode @complexity(value: 1)
  status: OrderStatus!
}

type PaymentProductNode implements Node {
  """The Global ID of an object."""
  id: ID!
  merchant: PaymentMerchantNode @complexity(value: 1)
  pk: UUID!
}

type PermissionCheckResultType {
  hasPermission: Boolean!
}

type PindoraReservationInfoDataType {
  accessCode: String!
  accessCodeGeneratedAt: DateTime!
  accessCodeIsActive: Boolean!
  accessCodeKeypadUrl: String!
  accessCodePhoneNumber: String!
  accessCodeSmsNumber: String!
  accessCodeSmsMessage: String!
  accessCodeBeginsAt: DateTime!
  accessCodeEndsAt: DateTime!
}

type PindoraSectionInfoType {
  accessCode: String!
  accessCodeGeneratedAt: DateTime!
  accessCodeIsActive: Boolean!
  accessCodeKeypadUrl: String!
  accessCodePhoneNumber: String!
  accessCodeSmsNumber: String!
  accessCodeSmsMessage: String!
  accessCodeValidity: [PindoraSectionValidityInfoType!]!
}

type PindoraSectionValidityInfoType {
  reservationId: Int!
  reservationSeriesId: Int!
  accessCodeBeginsAt: DateTime!
  accessCodeEndsAt: DateTime!
}

type PindoraSeriesInfoDataType {
  accessCode: String!
  accessCodeGeneratedAt: DateTime!
  accessCodeIsActive: Boolean!
  accessCodeKeypadUrl: String!
  accessCodePhoneNumber: String!
  accessCodeSmsNumber: String!
  accessCodeSmsMessage: String!
  accessCodeValidity: [PindoraValidityInfoDataType!]!
}

type PindoraValidityInfoDataType {
  reservationId: Int!
  reservationSeriesId: Int!
  accessCodeBeginsAt: DateTime!
  accessCodeEndsAt: DateTime!
}

type PurposeNode implements Node {
  """The Global ID of an object."""
  id: ID!
  imageUrl: String
  nameEn: String
  nameFi: String
  nameSv: String
  pk: Int!
  rank: Int!
  smallUrl: String
}

type RejectedOccurrenceNode implements Node {
  beginDatetime: DateTime!
  createdAt: DateTime!
  endDatetime: DateTime!
  """The Global ID of an object."""
  id: ID!
  pk: Int!
  rejectionReason: RejectionReadinessChoice!
  reservationSeries: ReservationSeriesNode! @complexity(value: 1)
}

"""A connection to a list of items."""
type RejectedOccurrenceNodeConnection {
  """Total number of items in the connection."""
  totalCount: Int!
  """Information about the current state of the pagination."""
  pageInfo: PageInfo!
  """The items in the connection."""
  edges: [RejectedOccurrenceNodeEdge]
}

"""An object describing an item in the connection."""
type RejectedOccurrenceNodeEdge {
  """A value identifying this edge for pagination purposes."""
  cursor: String!
  """An item in the connection."""
  node: RejectedOccurrenceNode
}

type ReservableTimeSpanType {
  startDatetime: DateTime!
  endDatetime: DateTime!
}

type ReservationCancelReasonType {
  value: ReservationCancelReasonChoice!
  reasonFi: String!
  reasonEn: String!
  reasonSv: String!
}

type ReservationDeleteTentativeMutationOutput {
  pk: Int!
}

type ReservationDenyReasonNode implements Node {
  """The Global ID of an object."""
  id: ID!
  pk: Int!
  reasonEn: String
  reasonFi: String
  reasonSv: String
}

type ReservationMetadataFieldNode implements Node {
  fieldName: String!
  """The Global ID of an object."""
  id: ID!
  pk: Int!
}

type ReservationMetadataSetNode implements Node {
  """The Global ID of an object."""
  id: ID!
  name: String!
  pk: Int!
  requiredFields: [ReservationMetadataFieldNode!]! @complexity(value: 1)
  supportedFields: [ReservationMetadataFieldNode!]! @complexity(value: 1)
}

type ReservationNode implements Node {
  accessCodeGeneratedAt: DateTime
  accessCodeIsActive: Boolean
  accessCodeShouldBeActive: Boolean
  accessType: AccessType
  """
  Which reservation units' reserveability is affected by this reservation?
  """
  affectedReservationUnits: [Int!]!
  ageGroup: AgeGroupNode @complexity(value: 1)
  """
  Details on the pricing that should be currently applied to this reservation.
  """
  appliedPricing: AppliedPricingInfoType
  applyingForFreeOfCharge: Boolean
  beginsAt: DateTime!
  bufferTimeAfter: Duration!
  bufferTimeBefore: Duration!
  calendarUrl: String
  cancelDetails: String
  cancelReason: ReservationCancelReasonChoice
  createdAt: DateTime
  denyReason: ReservationDenyReasonNode @complexity(value: 1)
  description: String
  endsAt: DateTime!
  extUuid: UUID!
  freeOfChargeReason: String
  handledAt: DateTime
  handlingDetails: String
  """The Global ID of an object."""
  id: ID!
  isAccessCodeIsActiveCorrect: Boolean
  isBlocked: Boolean!
  isHandled: Boolean
  municipality: MunicipalityChoice
  name: String
  numPersons: Int
  paymentOrder: PaymentOrderNode @complexity(value: 1)
  """
  Info fetched from Pindora API. Cached per reservation for 30s.
  Please don't use this when filtering multiple reservations, queries to Pindora are not optimized.
  """
  pindoraInfo: PindoraReservationInfoDataType
  pk: Int!
  price: Decimal
  priceNet: Decimal
  purpose: ReservationPurposeNode @complexity(value: 1)
  reservationSeries: ReservationSeriesNode @complexity(value: 1)
  reservationUnit: ReservationUnitNode! @complexity(value: 1)
  reserveeAddressCity: String
  reserveeAddressStreet: String
  reserveeAddressZip: String
  reserveeEmail: Email
  reserveeFirstName: String
  reserveeIdentifier: String
  reserveeLastName: String
  reserveeName: String
  reserveeOrganisationName: String
  reserveePhone: String
  reserveeType: ReserveeType
  state: ReservationStateChoice!
  taxPercentageValue: Decimal
  type: ReservationTypeChoice
  unitPrice: Decimal
  user: UserNode @complexity(value: 1)
  workingMemo: String
}

"""A connection to a list of items."""
type ReservationNodeConnection {
  """Total number of items in the connection."""
  totalCount: Int!
  """Information about the current state of the pagination."""
  pageInfo: PageInfo!
  """The items in the connection."""
  edges: [ReservationNodeEdge]
}

"""An object describing an item in the connection."""
type ReservationNodeEdge {
  """A value identifying this edge for pagination purposes."""
  cursor: String!
  """An item in the connection."""
  node: ReservationNode
}

type ReservationPurposeNode implements Node {
  """The Global ID of an object."""
  id: ID!
  nameEn: String
  nameFi: String
  nameSv: String
  pk: Int!
  rank: Int!
}

type ReservationSeriesChangeAccessCodeMutationOutputType {
  pk: Int!
  accessCodeGeneratedAt: DateTime
  accessCodeIsActive: Boolean!
}

type ReservationSeriesDenyMutationOutputType {
  denied: Int!
  future: Int!
}

type ReservationSeriesNode implements Node {
  accessType: AccessTypeWithMultivalued!
  ageGroup: AgeGroupNode @complexity(value: 1)
  allocatedTimeSlot: AllocatedTimeSlotNode @complexity(value: 1)
  beginDate: Date!
  beginTime: Time!
  createdAt: DateTime!
  description: String!
  endDate: Date!
  endTime: Time!
  extUuid: UUID!
  """The Global ID of an object."""
  id: ID!
  isAccessCodeIsActiveCorrect: Boolean!
  name: String!
  """
  Info fetched from Pindora API. Cached per reservation for 30s.
  Please don't use this when filtering multiple series, queries to Pindora are not optimized.
  """
  pindoraInfo: PindoraSeriesInfoDataType
  pk: Int!
  recurrenceInDays: Int
  rejectedOccurrences(
    filter: RejectedOccurrenceFilterSet
    orderBy: [RejectedOccurrenceOrderSet!]
  ): [RejectedOccurrenceNode!]! @complexity(value: 1)
  reservationUnit: ReservationUnitNode! @complexity(value: 1)
  reservations(
    filter: ReservationFilterSet
    orderBy: [ReservationOrderSet!]
  ): [ReservationNode!]! @complexity(value: 1)
  shouldHaveActiveAccessCode: Boolean!
  usedAccessTypes: [AccessType!]!
  user: UserNode! @complexity(value: 1)
  weekdays: [Weekday!]!
}

type ReservationSeriesRepairAccessCodeMutationOutputType {
  accessCodeGeneratedAt: DateTime
  accessCodeIsActive: Boolean!
}

type ReservationUnitAccessTypeNode implements Node {
  accessType: AccessType!
  beginDate: Date!
  """The Global ID of an object."""
  id: ID!
  pk: Int!
}

"""
This Node should be kept to the bare minimum and never expose any relations to avoid performance issues.
"""
type ReservationUnitAllNode implements Node {
  """The Global ID of an object."""
  id: ID!
  nameEn: String
  nameFi: String
  nameSv: String
  pk: Int!
}

type ReservationUnitCancellationRuleNode implements Node {
  canBeCancelledTimeBefore: Duration
  """The Global ID of an object."""
  id: ID!
  nameEn: String
  nameFi: String
  nameSv: String
  pk: Int!
}

"""A connection to a list of items."""
type ReservationUnitCancellationRuleNodeConnection {
  """Total number of items in the connection."""
  totalCount: Int!
  """Information about the current state of the pagination."""
  pageInfo: PageInfo!
  """The items in the connection."""
  edges: [ReservationUnitCancellationRuleNodeEdge]
}

"""An object describing an item in the connection."""
type ReservationUnitCancellationRuleNodeEdge {
  """A value identifying this edge for pagination purposes."""
  cursor: String!
  """An item in the connection."""
  node: ReservationUnitCancellationRuleNode
}

type ReservationUnitImageDeleteMutationOutput {
  pk: Int!
}

type ReservationUnitImageNode implements Node {
  """The Global ID of an object."""
  id: ID!
  imageType: ReservationUnitImageType!
  imageUrl: String
  largeUrl: String
  mediumUrl: String
  pk: Int!
  smallUrl: String
}

type ReservationUnitNode implements Node {
  accessTypes(
    filter: ReservationUnitAccessTypeFilterSet
    orderBy: [ReservationUnitAccessTypeOrderSet!]
  ): [ReservationUnitAccessTypeNode!]! @complexity(value: 1)
  allowReservationsWithoutOpeningHours: Boolean!
  applicationRoundTimeSlots: [ApplicationRoundTimeSlotNode!]! @complexity(value: 1)
  applicationRounds(
    filter: ApplicationRoundFilterSet
    orderBy: [ApplicationRoundOrderSet!]
  ): [ApplicationRoundNode!]! @complexity(value: 1)
  authentication: AuthenticationType!
  bufferTimeAfter: Duration!
  bufferTimeBefore: Duration!
  calculatedSurfaceArea: Int
  canApplyFreeOfCharge: Boolean!
  cancellationRule: ReservationUnitCancellationRuleNode @complexity(value: 1)
  cancellationTerms: TermsOfUseNode @complexity(value: 1)
  contactInformation: String!
  currentAccessType: AccessType
  descriptionEn: String
  descriptionFi: String
  descriptionSv: String
  effectiveAccessType: AccessType
  equipments(
    filter: EquipmentFilterSet
    orderBy: [EquipmentOrderSet!]
  ): [EquipmentNode!]! @complexity(value: 1)
  extUuid: UUID!
  firstReservableDatetime: DateTime
  haukiUrl: String
  """The Global ID of an object."""
  id: ID!
  images: [ReservationUnitImageNode!]! @complexity(value: 1)
  isArchived: Boolean!
  isClosed: Boolean!
  isDraft: Boolean!
  maxPersons: Int
  maxReservationDuration: Duration
  maxReservationsPerUser: Int
  metadataSet: ReservationMetadataSetNode @complexity(value: 1)
  minPersons: Int
  minReservationDuration: Duration
  nameEn: String
  nameFi: String
  nameSv: String
  notesWhenApplyingEn: String
  notesWhenApplyingFi: String
  notesWhenApplyingSv: String
  """
  Number of active reservations made by the user to this ReservationUnit.
  This is used to determine if the user can make a new reservation based on the 'maxReservationsPerUser'.
  """
  numActiveUserReservations: Int!
  paymentMerchant: PaymentMerchantNode @complexity(value: 1)
  paymentProduct: PaymentProductNode @complexity(value: 1)
  paymentTerms: TermsOfUseNode @complexity(value: 1)
  pk: Int!
  pricingTerms: TermsOfUseNode @complexity(value: 1)
  pricings: [ReservationUnitPricingNode!]! @complexity(value: 1)
  publishBeginsAt: DateTime
  publishEndsAt: DateTime
  publishingState: ReservationUnitPublishingState!
  purposes(
    filter: PurposeFilterSet
    orderBy: [PurposeOrderSet!]
  ): [PurposeNode!]! @complexity(value: 1)
  rank: Int!
  requireAdultReservee: Boolean!
  requireReservationHandling: Boolean!
  """
  Get all reservable time spans for this reservation unit's unit that fall within the given period.
  """
  reservableTimeSpans(
    """Start date of the period."""
    startDate: Date!
    """End date of the period."""
    endDate: Date!
  ): [ReservableTimeSpanType!]
  reservationBeginsAt: DateTime
  reservationBlockWholeDay: Boolean!
  reservationCancelledInstructionsEn: String
  reservationCancelledInstructionsFi: String
  reservationCancelledInstructionsSv: String
  reservationConfirmedInstructionsEn: String
  reservationConfirmedInstructionsFi: String
  reservationConfirmedInstructionsSv: String
  reservationEndsAt: DateTime
  reservationForm: ReservationFormType!
  reservationKind: ReservationKind!
  reservationPendingInstructionsEn: String
  reservationPendingInstructionsFi: String
  reservationPendingInstructionsSv: String
  reservationStartInterval: ReservationStartInterval!
  reservationState: ReservationUnitReservationState!
  reservationUnitType: ReservationUnitTypeNode @complexity(value: 1)
  reservations(
    filter: ReservationFilterSet
    orderBy: [ReservationOrderSet!]
  ): [ReservationNode!]! @complexity(value: 1)
  reservationsMaxDaysBefore: Int
  reservationsMinDaysBefore: Int
  resources(
    filter: ResourceFilterSet
    orderBy: [ResourceOrderSet!]
  ): [ResourceNode!]! @complexity(value: 1)
  searchTerms: [String!]!
  serviceSpecificTerms: TermsOfUseNode @complexity(value: 1)
  spaces(
    filter: SpaceFilterSet
    orderBy: [SpaceOrderSet!]
  ): [SpaceNode!]! @complexity(value: 1)
  surfaceArea: Int
  unit: UnitNode! @complexity(value: 1)
}

"""A connection to a list of items."""
type ReservationUnitNodeConnection {
  """Total number of items in the connection."""
  totalCount: Int!
  """Information about the current state of the pagination."""
  pageInfo: PageInfo!
  """The items in the connection."""
  edges: [ReservationUnitNodeEdge]
}

"""An object describing an item in the connection."""
type ReservationUnitNodeEdge {
  """A value identifying this edge for pagination purposes."""
  cursor: String!
  """An item in the connection."""
  node: ReservationUnitNode
}

type ReservationUnitOptionNode implements Node {
  allocatedTimeSlots(
    filter: AllocatedTimeSlotFilterSet
    orderBy: [AllocatedTimeSlotOrderSet!]
  ): [AllocatedTimeSlotNode!]! @complexity(value: 1)
  applicationSection: ApplicationSectionNode! @complexity(value: 1)
  """The Global ID of an object."""
  id: ID!
  isLocked: Boolean!
  isRejected: Boolean!
  pk: Int!
  preferredOrder: Int!
  reservationUnit: ReservationUnitNode! @complexity(value: 1)
}

type ReservationUnitPricingNode implements Node {
  begins: Date!
  highestPrice: Decimal!
  highestPriceNet: Decimal!
  """The Global ID of an object."""
  id: ID!
  lowestPrice: Decimal!
  lowestPriceNet: Decimal!
  materialPriceDescriptionEn: String
  materialPriceDescriptionFi: String
  materialPriceDescriptionSv: String
  paymentType: PaymentType
  pk: Int!
  priceUnit: PriceUnit!
  taxPercentage: TaxPercentageNode! @complexity(value: 1)
}

type ReservationUnitTypeNode implements Node {
  """The Global ID of an object."""
  id: ID!
  nameEn: String
  nameFi: String
  nameSv: String
  pk: Int!
  rank: Int!
}

type ResourceDeleteMutationOutput {
  pk: Int!
}

type ResourceNode implements Node {
  """The Global ID of an object."""
  id: ID!
  locationType: ResourceLocationType!
  nameEn: String
  nameFi: String
  nameSv: String
  pk: Int!
  space: SpaceNode @complexity(value: 1)
}

type SpaceDeleteMutationOutput {
  pk: Int!
}

type SpaceNode implements Node {
  children(
    filter: SpaceFilterSet
    orderBy: [SpaceOrderSet!]
  ): [SpaceNode!]! @complexity(value: 1)
  code: String!
  """The Global ID of an object."""
  id: ID!
  maxPersons: Int
  nameEn: String
  nameFi: String
  nameSv: String
  parent: SpaceNode @complexity(value: 1)
  pk: Int!
  resources(
    filter: ResourceFilterSet
    orderBy: [ResourceOrderSet!]
  ): [ResourceNode!]! @complexity(value: 1)
  surfaceArea: Int
  unit: UnitNode! @complexity(value: 1)
}

type SuitableTimeRangeNode implements Node {
  applicationSection: ApplicationSectionNode! @complexity(value: 1)
  beginTime: Time!
  dayOfTheWeek: Weekday!
  endTime: Time!
  fulfilled: Boolean!
  """The Global ID of an object."""
  id: ID!
  pk: Int!
  priority: Priority!
}

type TaxPercentageNode implements Node {
  """The Global ID of an object."""
  id: ID!
  pk: Int!
  value: Decimal!
}

type TermsOfUseNode implements Node {
  """The Global ID of an object."""
  id: ID!
  nameEn: String
  nameFi: String
  nameSv: String
  pk: String!
  termsType: TermsOfUseTypeChoices!
  textEn: String
  textFi: String
  textSv: String
}

type TimeSlotType {
  begin: Time!
  end: Time!
}

"""
This Node should be kept to the bare minimum and never expose any relations to avoid performance issues.
"""
type UnitAllNode implements Node {
  """The Global ID of an object."""
  id: ID!
  nameEn: String
  nameFi: String
  nameSv: String
  pk: Int!
  tprekId: String
}

type UnitGroupNode implements Node {
  """The Global ID of an object."""
  id: ID!
  nameEn: String
  nameFi: String
  nameSv: String
  pk: Int!
  units(
    filter: UnitFilterSet
    orderBy: [UnitOrderSet!]
  ): [UnitNode!]! @complexity(value: 1)
}

type UnitNode implements Node {
  addressCityEn: String
  addressCityFi: String
  addressCitySv: String
  addressStreetEn: String
  addressStreetFi: String
  addressStreetSv: String
  addressZip: String!
  descriptionEn: String
  descriptionFi: String
  descriptionSv: String
  email: Email!
  """The Global ID of an object."""
  id: ID!
  nameEn: String
  nameFi: String
  nameSv: String
  paymentMerchant: PaymentMerchantNode @complexity(value: 1)
  phone: String!
  pk: Int!
  reservationUnits(
    filter: ReservationUnitFilterSet
    orderBy: [ReservationUnitOrderSet!]
  ): [ReservationUnitNode!]! @complexity(value: 1)
  shortDescriptionEn: String
  shortDescriptionFi: String
  shortDescriptionSv: String
  spaces(
    filter: SpaceFilterSet
    orderBy: [SpaceOrderSet!]
  ): [SpaceNode!]! @complexity(value: 1)
  tprekId: String
  unitGroups(
    filter: UnitGroupFilterSet
  ): [UnitGroupNode!]! @complexity(value: 1)
  webPage: URL!
}

"""A connection to a list of items."""
type UnitNodeConnection {
  """Total number of items in the connection."""
  totalCount: Int!
  """Information about the current state of the pagination."""
  pageInfo: PageInfo!
  """The items in the connection."""
  edges: [UnitNodeEdge]
}

"""An object describing an item in the connection."""
type UnitNodeEdge {
  """A value identifying this edge for pagination purposes."""
  cursor: String!
  """An item in the connection."""
  node: UnitNode
}

type UnitRoleNode implements Node {
  assigner: UserNode @complexity(value: 1)
  createdAt: DateTime!
  """The Global ID of an object."""
  id: ID!
  permissions: [UserPermissionChoice!]!
  role: UserRoleChoice!
  unitGroups(
    filter: UnitGroupFilterSet
  ): [UnitGroupNode!]! @complexity(value: 1)
  units(
    filter: UnitFilterSet
    orderBy: [UnitOrderSet!]
  ): [UnitNode!]! @complexity(value: 1)
  updatedAt: DateTime!
  user: UserNode! @complexity(value: 1)
}

type UserNode implements Node {
  dateOfBirth: Date
  email: Email!
  firstName: String!
  generalRoles: [GeneralRoleNode!]! @complexity(value: 1)
  """The Global ID of an object."""
  id: ID!
  isAdAuthenticated: Boolean!
  isInternalUser: Boolean!
  isStronglyAuthenticated: Boolean!
  """
  Designates that this user has all permissions without explicitly assigning them.
  """
  isSuperuser: Boolean!
  lastName: String!
  name: String!
  pk: Int!
  reservationNotification: ReservationNotification
  unitRoles: [UnitRoleNode!]! @complexity(value: 1)
  """Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only."""
  username: String!
  uuid: UUID!
}

type UserProfileInfoType {
  pk: Int!
  firstName: String
  lastName: String
  email: String
  phone: String
  birthday: Date
  ssn: String
  streetAddress: String
  postalCode: String
  city: String
  countryCode: String
  additionalAddress: String
  municipalityCode: String
  municipalityName: String
  loginMethod: LoginMethod!
  isStrongLogin: Boolean!
}

input AccessTypeFilterDataInput {
  accessTypes: [AccessType!]!
  accessTypeBeginDate: Date
  accessTypeEndDate: Date
}

"""Create an allocated time slot for a reservation unit option."""
input AllocatedTimeSlotCreateMutation {
  beginTime: Time!
  dayOfTheWeek: Weekday!
  endTime: Time!
  force: Boolean! = false
  reservationUnitOption: Int!
}

input AllocatedTimeSlotDeleteMutation {
  pk: Int!
}

input AllocatedTimeSlotFilterSet {
  accessCodeState: [AccessCodeState!]
  allocatedReservationUnit: [Int!]
  allocatedUnit: [Int!]
  applicantType: [ReserveeType!]
  applicationRound: Int
  applicationSectionStatus: [ApplicationSectionStatusChoice!]
  dayOfTheWeek: [Weekday!]
  pk: [Int!]
  textSearch: String
  unitGroup: [Int!]
  NOT: AllocatedTimeSlotFilterSet
  AND: AllocatedTimeSlotFilterSet
  OR: AllocatedTimeSlotFilterSet
  XOR: AllocatedTimeSlotFilterSet
}

input ApplicationCancelMutation {
  pk: Int!
}

input ApplicationCreateMutation {
  additionalInformation: String! = ""
  applicantType: ReserveeType = null
  applicationRound: Int!
  applicationSections: [ApplicationSectionCreateInput!]! = []
  billingCity: String! = ""
  billingPostCode: String! = ""
  billingStreetAddress: String! = ""
  contactPersonEmail: Email = null
  contactPersonFirstName: String! = ""
  contactPersonLastName: String! = ""
  contactPersonPhoneNumber: String! = ""
  municipality: MunicipalityChoice = null
  organisationActiveMembers: Int = null
  organisationCity: String! = ""
  organisationCoreBusiness: String! = ""
  organisationEmail: Email = null
  organisationIdentifier: String! = ""
  organisationName: String! = ""
  organisationPostCode: String! = ""
  organisationStreetAddress: String! = ""
  organisationYearEstablished: Int = null
}

input ApplicationFilterSet {
  applicantType: [ReserveeType!]
  applicationRound: Int
  pk: [Int!]
  status: [ApplicationStatusChoice!]
  textSearch: String
  unit: [Int!]
  unitGroup: [Int!]
  user: Int
  NOT: ApplicationFilterSet
  AND: ApplicationFilterSet
  OR: ApplicationFilterSet
  XOR: ApplicationFilterSet
}

input ApplicationRoundFilterSet {
  active: Boolean
  name: String
  ongoing: Boolean
  onlyWithPermissions: Boolean
  pk: [Int!]
  NOT: ApplicationRoundFilterSet
  AND: ApplicationRoundFilterSet
  OR: ApplicationRoundFilterSet
  XOR: ApplicationRoundFilterSet
}

input ApplicationRoundTimeSlotCreateInput {
  isClosed: Boolean! = false
  reservableTimes: [TimeSlotInput!]! = []
  weekday: Weekday!
}

input ApplicationRoundTimeSlotUpdateInput {
  isClosed: Boolean
  pk: Int
  reservableTimes: [TimeSlotInput!]
  weekday: Weekday
}

input ApplicationSectionCreateInput {
  ageGroup: Int
  appliedReservationsPerWeek: Int!
  name: String!
  numPersons: Int!
  purpose: Int
  reservationMaxDuration: Duration!
  reservationMinDuration: Duration!
  reservationUnitOptions: [ReservationUnitOptionCreateInput!]! = []
  reservationsBeginDate: Date!
  reservationsEndDate: Date!
  suitableTimeRanges: [SuitableTimeRangeCreateInput!]! = []
}

input ApplicationSectionFilterSet {
  ageGroup: [Int!]
  applicantType: [ReserveeType!]
  application: Int
  applicationRound: Int
  applicationStatus: [ApplicationStatusChoice!]
  extUuid: UUID
  hasAllocations: Boolean
  municipality: [MunicipalityChoice!]
  name: String
  pk: [Int!]
  preferredOrder: PreferredOrderFilterInput
  priority: [Priority!]
  purpose: [Int!]
  reservationUnit: [Int!]
  status: [ApplicationSectionStatusChoice!]
  textSearch: String
  unit: [Int!]
  unitGroup: [Int!]
  user: Int
  NOT: ApplicationSectionFilterSet
  AND: ApplicationSectionFilterSet
  OR: ApplicationSectionFilterSet
  XOR: ApplicationSectionFilterSet
}

"""
Cancel all reservations in the given application section that can be cancelled.
"""
input ApplicationSectionReservationCancellationMutation {
  cancelDetails: String! = ""
  cancelReason: ReservationCancelReasonChoice!
  pk: Int!
}

input ApplicationSectionUpdateInput {
  ageGroup: Int
  appliedReservationsPerWeek: Int
  name: String
  numPersons: Int
  pk: Int
  purpose: Int
  reservationMaxDuration: Duration
  reservationMinDuration: Duration
  reservationUnitOptions: [ReservationUnitOptionUpdateInput!]
  reservationsBeginDate: Date
  reservationsEndDate: Date
  suitableTimeRanges: [SuitableTimeRangeUpdateInput!]
}

input ApplicationSendMutation {
  pk: Int!
}

input ApplicationUpdateMutation {
  additionalInformation: String
  applicantType: ReserveeType
  applicationSections: [ApplicationSectionUpdateInput!]
  billingCity: String
  billingPostCode: String
  billingStreetAddress: String
  contactPersonEmail: Email
  contactPersonFirstName: String
  contactPersonLastName: String
  contactPersonPhoneNumber: String
  municipality: MunicipalityChoice
  organisationActiveMembers: Int
  organisationCity: String
  organisationCoreBusiness: String
  organisationEmail: Email
  organisationIdentifier: String
  organisationName: String
  organisationPostCode: String
  organisationStreetAddress: String
  organisationYearEstablished: Int
  pk: Int!
}

input ApplicationWorkingMemoMutation {
  pk: Int!
  workingMemo: String!
}

input BannerNotificationCreateMutation {
  activeFrom: DateTime = null
  activeUntil: DateTime = null
  draft: Boolean! = true
  level: BannerNotificationLevel!
  messageEn: String = ""
  messageFi: String = ""
  messageSv: String = ""
  name: String!
  target: BannerNotificationTarget!
}

input BannerNotificationDeleteMutation {
  pk: Int!
}

input BannerNotificationFilterSet {
  isActive: Boolean
  isVisible: Boolean
  name: String
  target: BannerNotificationTarget
  NOT: BannerNotificationFilterSet
  AND: BannerNotificationFilterSet
  OR: BannerNotificationFilterSet
  XOR: BannerNotificationFilterSet
}

input BannerNotificationUpdateMutation {
  activeFrom: DateTime
  activeUntil: DateTime
  draft: Boolean
  level: BannerNotificationLevel
  messageEn: String
  messageFi: String
  messageSv: String
  name: String
  pk: Int!
  target: BannerNotificationTarget
}

input EquipmentCategoryFilterSet {
  pk: [Int!]
  NOT: EquipmentCategoryFilterSet
  AND: EquipmentCategoryFilterSet
  OR: EquipmentCategoryFilterSet
  XOR: EquipmentCategoryFilterSet
}

input EquipmentFilterSet {
  nameEnContains: String
  nameEnExact: String
  nameEnStartswith: String
  nameFiContains: String
  nameFiExact: String
  nameFiStartswith: String
  nameSvContains: String
  nameSvExact: String
  nameSvStartswith: String
  pk: [Int!]
  rankGte: Int
  rankLte: Int
  NOT: EquipmentFilterSet
  AND: EquipmentFilterSet
  OR: EquipmentFilterSet
  XOR: EquipmentFilterSet
}

input PreferredOrderFilterInput {
  values: [Int!]!
  allHigherThan10: Boolean!
}

input PurposeFilterSet {
  nameEn: String
  nameFi: String
  nameSv: String
  pk: [Int!]
  NOT: PurposeFilterSet
  AND: PurposeFilterSet
  OR: PurposeFilterSet
  XOR: PurposeFilterSet
}

input RejectAllApplicationOptionsMutation {
  pk: Int!
}

input RejectAllSectionOptionsMutation {
  pk: Int!
}

input RejectedOccurrenceFilterSet {
  applicationRound: Int
  pk: [Int!]
  reservationSeries: Int
  reservationUnit: [Int!]
  textSearch: String
  unit: [Int!]
  unitGroup: [Int!]
  NOT: RejectedOccurrenceFilterSet
  AND: RejectedOccurrenceFilterSet
  OR: RejectedOccurrenceFilterSet
  XOR: RejectedOccurrenceFilterSet
}

"""Adjust the time for a reservation."""
input ReservationAdjustTimeMutation {
  beginsAt: DateTime!
  endsAt: DateTime!
  pk: Int!
}

"""Approve a reservation during handling."""
input ReservationApproveMutation {
  handlingDetails: String!
  pk: Int!
  price: Decimal!
}

"""Cancel a reservation."""
input ReservationCancelMutation {
  cancelDetails: String! = ""
  cancelReason: ReservationCancelReasonChoice!
  pk: Int!
}

"""
Confirm a tentative reservation. Reservation might still require handling and/or payment.
"""
input ReservationConfirmMutation {
  pk: Int!
}

"""Create a tentative reservation before moving to the checkout flow."""
input ReservationCreateMutation {
  beginsAt: DateTime!
  endsAt: DateTime!
  reservationUnit: Int!
}

"""Delete a reservation before it's confirmed."""
input ReservationDeleteTentativeMutation {
  pk: Int!
}

"""Deny a reservation during handling."""
input ReservationDenyMutation {
  denyReason: Int!
  handlingDetails: String!
  pk: Int!
}

input ReservationDenyReasonFilterSet {
  pk: [Int!]
  reason: String
  NOT: ReservationDenyReasonFilterSet
  AND: ReservationDenyReasonFilterSet
  OR: ReservationDenyReasonFilterSet
  XOR: ReservationDenyReasonFilterSet
}

input ReservationFilterSet {
  applyingForFreeOfCharge: Boolean
  beginDate: Date
  createdAfter: Date
  createdBefore: Date
  endDate: Date
  extUuid: UUID
  isRecurring: Boolean
  onlyWithHandlingPermission: Boolean
  onlyWithPermission: Boolean
  orderStatus: [OrderStatusWithFree!]
  pk: [Int!]
  priceGte: Decimal
  priceLte: Decimal
  """
  Filter for displaying reservations which requires or had required handling.
  """
  requested: Boolean
  reservationSeries: [Int!]
  reservationType: [ReservationTypeChoice!]
  reservationUnit: [Int!]
  reservationUnitNameEn: String
  reservationUnitNameFi: String
  reservationUnitNameSv: String
  reservationUnitType: [Int!]
  state: [ReservationStateChoice!]
  textSearch: String
  unit: [Int!]
  user: [Int!]
  NOT: ReservationFilterSet
  AND: ReservationFilterSet
  OR: ReservationFilterSet
  XOR: ReservationFilterSet
}

input ReservationPurposeFilterSet {
  nameEn: String
  nameFi: String
  nameSv: String
  pk: [Int!]
  NOT: ReservationPurposeFilterSet
  AND: ReservationPurposeFilterSet
  OR: ReservationPurposeFilterSet
  XOR: ReservationPurposeFilterSet
}

"""Allows staff to refund a reservation after denying it."""
input ReservationRefundMutation {
  pk: Int!
}

"""
Move an 'approved' or 'denied' reservation back to 'requires handling' state.
"""
input ReservationRequiresHandlingMutation {
  pk: Int!
}

"""Add a reservation to a reservation series."""
input ReservationSeriesAddMutation {
  beginsAt: DateTime!
  bufferTimeAfter: Duration
  bufferTimeBefore: Duration
  endsAt: DateTime!
  pk: Int!
}

"""Change the access code of a reservation series."""
input ReservationSeriesChangeAccessCodeMutation {
  pk: Int!
}

"""Create the reservation series with all its reservations."""
input ReservationSeriesCreateMutation {
  ageGroup: Int = null
  beginDate: Date!
  beginTime: Time!
  checkOpeningHours: Boolean! = false
  description: String! = ""
  endDate: Date!
  endTime: Time!
  name: String! = ""
  recurrenceInDays: Int!
  reservationDetails: ReservationSeriesReservationCreateInput!
  reservationUnit: Int!
  skipDates: [Date!]! = []
  weekdays: [Weekday!]!
}

input ReservationSeriesDenyMutation {
  denyReason: Int!
  handlingDetails: String
  pk: Int!
}

"""
Synchronize the state of the reservation series' access code between Varaamo and Pindora
to what Varaamo thinks is should be its correct state.
"""
input ReservationSeriesRepairAccessCodeMutation {
  pk: Int!
}

"""Reschedule reservation series."""
input ReservationSeriesRescheduleMutation {
  beginDate: Date
  beginTime: Time
  bufferTimeAfter: Duration
  bufferTimeBefore: Duration
  endDate: Date
  endTime: Time
  pk: Int!
  skipDates: [Date!]! = []
  weekdays: [Weekday!]
}

input ReservationSeriesReservationCreateInput {
  applyingForFreeOfCharge: Boolean! = false
  bufferTimeAfter: Duration
  bufferTimeBefore: Duration
  confirmedAt: DateTime = null
  description: String! = ""
  freeOfChargeReason: String = null
  handledAt: DateTime = null
  municipality: MunicipalityChoice = null
  name: String! = ""
  numPersons: Int = null
  purpose: Int
  reserveeAddressCity: String! = ""
  reserveeAddressStreet: String! = ""
  reserveeAddressZip: String! = ""
  reserveeEmail: Email = null
  reserveeFirstName: String! = ""
  reserveeIdentifier: String! = ""
  reserveeLastName: String! = ""
  reserveeOrganisationName: String! = ""
  reserveePhone: String! = ""
  reserveeType: ReserveeType = null
  state: ReservationStateChoice! = CONFIRMED
  type: ReservationTypeStaffChoice! = STAFF
  workingMemo: String! = ""
}

input ReservationSeriesReservationUpdateInput {
  ageGroup: Int
  applyingForFreeOfCharge: Boolean
  description: String
  freeOfChargeReason: String
  municipality: MunicipalityChoice
  name: String
  numPersons: Int
  purpose: Int
  reserveeAddressCity: String
  reserveeAddressStreet: String
  reserveeAddressZip: String
  reserveeEmail: Email
  reserveeFirstName: String
  reserveeIdentifier: String
  reserveeLastName: String
  reserveeOrganisationName: String
  reserveePhone: String
  reserveeType: ReserveeType
  workingMemo: String
}

"""Update reservation series and its reservation data."""
input ReservationSeriesUpdateMutation {
  ageGroup: Int
  description: String
  name: String
  pk: Int!
  reservationDetails: ReservationSeriesReservationUpdateInput! = {}
  skipReservations: [Int!]! = []
}

"""Adjust a reservation's time as a staff member."""
input ReservationStaffAdjustTimeMutation {
  beginsAt: DateTime!
  bufferTimeAfter: Duration
  bufferTimeBefore: Duration
  endsAt: DateTime!
  pk: Int!
}

"""Change the access code of a reservation."""
input ReservationStaffChangeAccessCodeMutation {
  pk: Int!
}

"""Create a reservation as a staff user."""
input ReservationStaffCreateMutation {
  ageGroup: Int = null
  applyingForFreeOfCharge: Boolean! = false
  beginsAt: DateTime!
  bufferTimeAfter: Duration! = 0
  bufferTimeBefore: Duration! = 0
  description: String! = ""
  endsAt: DateTime!
  freeOfChargeReason: String = null
  municipality: MunicipalityChoice = null
  name: String! = ""
  numPersons: Int = null
  purpose: Int = null
  reservationUnit: Int!
  reserveeAddressCity: String! = ""
  reserveeAddressStreet: String! = ""
  reserveeAddressZip: String! = ""
  reserveeEmail: Email = null
  reserveeFirstName: String! = ""
  reserveeIdentifier: String! = ""
  reserveeLastName: String! = ""
  reserveeOrganisationName: String! = ""
  reserveePhone: String! = ""
  reserveeType: ReserveeType = null
  type: ReservationTypeChoice! = STAFF
  workingMemo: String! = ""
}

"""Modify a reservation as a staff member."""
input ReservationStaffModifyMutation {
  ageGroup: Int
  applyingForFreeOfCharge: Boolean
  description: String
  freeOfChargeReason: String
  municipality: MunicipalityChoice
  name: String
  numPersons: Int
  pk: Int!
  purpose: Int
  reserveeAddressCity: String
  reserveeAddressStreet: String
  reserveeAddressZip: String
  reserveeEmail: Email
  reserveeFirstName: String
  reserveeIdentifier: String
  reserveeLastName: String
  reserveeOrganisationName: String
  reserveePhone: String
  reserveeType: ReserveeType
  type: ReservationTypeChoice
}

"""
Synchronize the state of the reservation's access code between Varaamo and Pindora
to what Varaamo thinks is should be its correct state.
"""
input ReservationStaffRepairAccessCodeMutation {
  pk: Int!
}

input ReservationUnitAccessTypeCreateInput {
  accessType: AccessType! = UNRESTRICTED
  beginDate: Date!
}

input ReservationUnitAccessTypeFilterSet {
  isActiveOrFuture: Boolean
  pk: [Int!]
  NOT: ReservationUnitAccessTypeFilterSet
  AND: ReservationUnitAccessTypeFilterSet
  OR: ReservationUnitAccessTypeFilterSet
  XOR: ReservationUnitAccessTypeFilterSet
}

input ReservationUnitAccessTypeUpdateInput {
  accessType: AccessType
  beginDate: Date
  pk: Int
}

input ReservationUnitAllFilterSet {
  nameEnContains: String
  nameEnExact: String
  nameEnStartswith: String
  nameFiContains: String
  nameFiExact: String
  nameFiStartswith: String
  nameSvContains: String
  nameSvExact: String
  nameSvStartswith: String
  """
  Returns reservation units where the user has any kind of permissions in its unit
  """
  onlyWithPermission: Boolean
  unit: [Int!]
  NOT: ReservationUnitAllFilterSet
  AND: ReservationUnitAllFilterSet
  OR: ReservationUnitAllFilterSet
  XOR: ReservationUnitAllFilterSet
}

"""Archive a reservation unit."""
input ReservationUnitArchiveMutation {
  pk: Int!
}

input ReservationUnitCancellationRuleFilterSet {
  name: String
  pk: [Int!]
  NOT: ReservationUnitCancellationRuleFilterSet
  AND: ReservationUnitCancellationRuleFilterSet
  OR: ReservationUnitCancellationRuleFilterSet
  XOR: ReservationUnitCancellationRuleFilterSet
}

"""Create a new ReservationUnit."""
input ReservationUnitCreateMutation {
  accessTypes: [ReservationUnitAccessTypeCreateInput!]
  allowReservationsWithoutOpeningHours: Boolean! = false
  applicationRoundTimeSlots: [ApplicationRoundTimeSlotCreateInput!]
  authentication: AuthenticationType! = weak
  bufferTimeAfter: Duration! = 0
  bufferTimeBefore: Duration! = 0
  canApplyFreeOfCharge: Boolean! = false
  cancellationRule: Int = null
  cancellationTerms: String = null
  contactInformation: String! = ""
  descriptionEn: String
  descriptionFi: String
  descriptionSv: String
  equipments: [Int!]
  images: [ReservationUnitImageCreateInput!]
  isDraft: Boolean! = false
  maxPersons: Int = null
  maxReservationDuration: Duration = null
  maxReservationsPerUser: Int = null
  metadataSet: Int = null
  minPersons: Int = null
  minReservationDuration: Duration = null
  nameEn: String
  nameFi: String!
  nameSv: String
  notesWhenApplyingEn: String
  notesWhenApplyingFi: String
  notesWhenApplyingSv: String
  paymentTerms: String = null
  pricingTerms: String = null
  pricings: [ReservationUnitPricingCreateInput!]
  publishBeginsAt: DateTime = null
  publishEndsAt: DateTime = null
  purposes: [Int!]
  requireAdultReservee: Boolean! = false
  requireReservationHandling: Boolean! = false
  reservationBeginsAt: DateTime = null
  reservationBlockWholeDay: Boolean! = false
  reservationCancelledInstructionsEn: String
  reservationCancelledInstructionsFi: String
  reservationCancelledInstructionsSv: String
  reservationConfirmedInstructionsEn: String
  reservationConfirmedInstructionsFi: String
  reservationConfirmedInstructionsSv: String
  reservationEndsAt: DateTime = null
  reservationForm: ReservationFormType! = CONTACT_INFO_FORM
  reservationKind: ReservationKind! = DIRECT_AND_SEASON
  reservationPendingInstructionsEn: String
  reservationPendingInstructionsFi: String
  reservationPendingInstructionsSv: String
  reservationStartInterval: ReservationStartInterval! = interval_15_mins
  reservationUnitType: Int = null
  reservationsMaxDaysBefore: Int = null
  reservationsMinDaysBefore: Int = null
  resources: [Int!]
  searchTerms: [String!]! = []
  serviceSpecificTerms: String = null
  spaces: [Int!]
  surfaceArea: Int = null
  unit: Int!
}

"""
Filter arguments for calculating first reservable time for reservation units.
"""
input ReservationUnitFilterDataInput {
  reservableDateStart: Date
  reservableDateEnd: Date
  reservableTimeStart: Time
  reservableTimeEnd: Time
  reservableMinimumDurationMinutes: Int
  showOnlyReservable: Boolean!
}

input ReservationUnitFilterSet {
  accessType: AccessTypeFilterDataInput
  applicationRound: [Int!]
  descriptionEnContains: String
  descriptionEnStartswith: String
  descriptionFiContains: String
  descriptionFiStartswith: String
  descriptionSvContains: String
  descriptionSvStartswith: String
  equipments: [Int!]
  isDraft: Boolean
  isVisible: Boolean
  maxPersonsGte: Int
  maxPersonsLte: Int
  minPersonsGte: Int
  minPersonsLte: Int
  nameEnContains: String
  nameEnExact: String
  nameEnStartswith: String
  nameFiContains: String
  nameFiExact: String
  nameFiStartswith: String
  nameSvContains: String
  nameSvExact: String
  nameSvStartswith: String
  """
  Returns reservation units where the user has any kind of permissions in its unit
  """
  onlyWithPermission: Boolean
  personsAllowed: Int
  pk: [Int!]
  publishingState: [ReservationUnitPublishingState!]
  purposes: [Int!]
  rankGte: Int
  rankLte: Int
  reservationForm: [ReservationFormType!]
  reservationKind: ReservationKind
  reservationState: [ReservationUnitReservationState!]
  reservationUnitType: [Int!]
  surfaceAreaGte: Int
  surfaceAreaLte: Int
  textSearch: String
  tprekDepartmentId: String
  tprekId: String
  typeRankGte: Int
  typeRankLte: Int
  unit: [Int!]
  unitGroup: [Int!]
  uuid: UUID
  NOT: ReservationUnitFilterSet
  AND: ReservationUnitFilterSet
  OR: ReservationUnitFilterSet
  XOR: ReservationUnitFilterSet
}

input ReservationUnitImageCreateInput {
  image: Image!
  imageType: ReservationUnitImageType!
}

input ReservationUnitImageCreateMutation {
  image: Image!
  imageType: ReservationUnitImageType!
  reservationUnit: Int!
}

input ReservationUnitImageDeleteMutation {
  pk: Int!
}

input ReservationUnitImageUpdateInput {
  image: Image
  imageType: ReservationUnitImageType
  pk: Int
}

input ReservationUnitImageUpdateMutation {
  imageType: ReservationUnitImageType!
  pk: Int!
}

input ReservationUnitOptionCreateInput {
  preferredOrder: Int!
  reservationUnit: Int!
}

input ReservationUnitOptionFilterSet {
  pk: [Int!]
  preferredOrder: [Int!]
  reservationUnit: [Int!]
  NOT: ReservationUnitOptionFilterSet
  AND: ReservationUnitOptionFilterSet
  OR: ReservationUnitOptionFilterSet
  XOR: ReservationUnitOptionFilterSet
}

input ReservationUnitOptionUpdateInput {
  pk: Int
  preferredOrder: Int
  reservationUnit: Int
}

input ReservationUnitOptionUpdateMutation {
  isLocked: Boolean
  isRejected: Boolean
  pk: Int!
}

input ReservationUnitPricingCreateInput {
  begins: Date!
  highestPrice: Decimal! = "0"
  isActivatedOnBegins: Boolean! = false
  lowestPrice: Decimal! = "0"
  materialPriceDescriptionEn: String
  materialPriceDescriptionFi: String
  materialPriceDescriptionSv: String
  paymentType: PaymentType!
  priceUnit: PriceUnit! = per_hour
  taxPercentage: Int!
}

input ReservationUnitPricingUpdateInput {
  begins: Date
  highestPrice: Decimal
  isActivatedOnBegins: Boolean
  lowestPrice: Decimal
  materialPriceDescriptionEn: String
  materialPriceDescriptionFi: String
  materialPriceDescriptionSv: String
  paymentType: PaymentType
  pk: Int
  priceUnit: PriceUnit
  taxPercentage: Int
}

input ReservationUnitTypeFilterSet {
  nameEnContains: String
  nameEnExact: String
  nameEnIstartswith: String
  nameFiContains: String
  nameFiExact: String
  nameFiIstartswith: String
  nameSvContains: String
  nameSvExact: String
  nameSvIstartswith: String
  pk: [Int!]
  NOT: ReservationUnitTypeFilterSet
  AND: ReservationUnitTypeFilterSet
  OR: ReservationUnitTypeFilterSet
  XOR: ReservationUnitTypeFilterSet
}

"""Update a ReservationUnit."""
input ReservationUnitUpdateMutation {
  accessTypes: [ReservationUnitAccessTypeUpdateInput!]
  allowReservationsWithoutOpeningHours: Boolean
  applicationRoundTimeSlots: [ApplicationRoundTimeSlotUpdateInput!]
  authentication: AuthenticationType
  bufferTimeAfter: Duration
  bufferTimeBefore: Duration
  canApplyFreeOfCharge: Boolean
  cancellationRule: Int
  cancellationTerms: String
  contactInformation: String
  descriptionEn: String
  descriptionFi: String
  descriptionSv: String
  equipments: [Int!]
  images: [ReservationUnitImageUpdateInput!]
  isDraft: Boolean
  maxPersons: Int
  maxReservationDuration: Duration
  maxReservationsPerUser: Int
  metadataSet: Int
  minPersons: Int
  minReservationDuration: Duration
  nameEn: String
  nameFi: String
  nameSv: String
  notesWhenApplyingEn: String
  notesWhenApplyingFi: String
  notesWhenApplyingSv: String
  paymentTerms: String
  pk: Int!
  pricingTerms: String
  pricings: [ReservationUnitPricingUpdateInput!]
  publishBeginsAt: DateTime
  publishEndsAt: DateTime
  purposes: [Int!]
  requireAdultReservee: Boolean
  requireReservationHandling: Boolean
  reservationBeginsAt: DateTime
  reservationBlockWholeDay: Boolean
  reservationCancelledInstructionsEn: String
  reservationCancelledInstructionsFi: String
  reservationCancelledInstructionsSv: String
  reservationConfirmedInstructionsEn: String
  reservationConfirmedInstructionsFi: String
  reservationConfirmedInstructionsSv: String
  reservationEndsAt: DateTime
  reservationForm: ReservationFormType
  reservationKind: ReservationKind
  reservationPendingInstructionsEn: String
  reservationPendingInstructionsFi: String
  reservationPendingInstructionsSv: String
  reservationStartInterval: ReservationStartInterval
  reservationUnitType: Int
  reservationsMaxDaysBefore: Int
  reservationsMinDaysBefore: Int
  resources: [Int!]
  searchTerms: [String!]
  serviceSpecificTerms: String
  spaces: [Int!]
  surfaceArea: Int
}

"""Update reservation during checkout."""
input ReservationUpdateMutation {
  ageGroup: Int
  applyingForFreeOfCharge: Boolean
  description: String
  freeOfChargeReason: String
  municipality: MunicipalityChoice
  name: String
  numPersons: Int
  pk: Int!
  purpose: Int
  reserveeAddressCity: String
  reserveeAddressStreet: String
  reserveeAddressZip: String
  reserveeEmail: Email
  reserveeFirstName: String
  reserveeIdentifier: String
  reserveeLastName: String
  reserveeOrganisationName: String
  reserveePhone: String
  reserveeType: ReserveeType
}

"""Update the working memo of a reservation."""
input ReservationWorkingMemoMutation {
  pk: Int!
  workingMemo: String!
}

input ResourceCreateMutation {
  locationType: ResourceLocationType! = fixed
  nameEn: String = null
  nameFi: String!
  nameSv: String = null
  space: Int = null
}

input ResourceDeleteMutation {
  pk: Int!
}

input ResourceFilterSet {
  nameEnContains: String
  nameEnExact: String
  nameEnStartswith: String
  nameFiContains: String
  nameFiExact: String
  nameFiStartswith: String
  nameSvContains: String
  nameSvExact: String
  nameSvStartswith: String
  """Returns resources where the user has resource management permissions"""
  onlyWithPermission: Boolean
  pk: [Int!]
  NOT: ResourceFilterSet
  AND: ResourceFilterSet
  OR: ResourceFilterSet
  XOR: ResourceFilterSet
}

input ResourceUpdateMutation {
  locationType: ResourceLocationType
  nameEn: String
  nameFi: String
  nameSv: String
  pk: Int!
  space: Int
}

input RestoreAllApplicationOptionsMutation {
  pk: Int!
}

input RestoreAllSectionOptionsMutation {
  pk: Int!
}

input SetApplicationRoundHandledMutation {
  pk: Int!
}

input SetApplicationRoundResultsSentMutation {
  pk: Int!
}

input SpaceCreateMutation {
  code: String! = ""
  maxPersons: Int = null
  nameEn: String = null
  nameFi: String!
  nameSv: String = null
  parent: Int = null
  surfaceArea: Int = null
  unit: Int!
}

input SpaceDeleteMutation {
  pk: Int!
}

input SpaceFilterSet {
  nameEnContains: String
  nameEnExact: String
  nameEnStartswith: String
  nameFiContains: String
  nameFiExact: String
  nameFiStartswith: String
  nameSvContains: String
  nameSvExact: String
  nameSvStartswith: String
  """Returns spaces where the user has space management permissions"""
  onlyWithPermission: Boolean
  pk: [Int!]
  NOT: SpaceFilterSet
  AND: SpaceFilterSet
  OR: SpaceFilterSet
  XOR: SpaceFilterSet
}

input SpaceUpdateMutation {
  code: String
  maxPersons: Int
  nameEn: String
  nameFi: String
  nameSv: String
  parent: Int
  pk: Int!
  surfaceArea: Int
}

input SuitableTimeRangeCreateInput {
  beginTime: Time!
  dayOfTheWeek: Weekday!
  endTime: Time!
  priority: Priority!
}

input SuitableTimeRangeFilterSet {
  fulfilled: Boolean
  pk: [Int!]
  priority: [Priority!]
  NOT: SuitableTimeRangeFilterSet
  AND: SuitableTimeRangeFilterSet
  OR: SuitableTimeRangeFilterSet
  XOR: SuitableTimeRangeFilterSet
}

input SuitableTimeRangeUpdateInput {
  beginTime: Time
  dayOfTheWeek: Weekday
  endTime: Time
  pk: Int
  priority: Priority
}

input TaxPercentageFilterSet {
  pk: [Int!]
  value: Decimal
  NOT: TaxPercentageFilterSet
  AND: TaxPercentageFilterSet
  OR: TaxPercentageFilterSet
  XOR: TaxPercentageFilterSet
}

input TermsOfUseFilterSet {
  pk: [String!]
  termsType: TermsOfUseTypeChoices
  NOT: TermsOfUseFilterSet
  AND: TermsOfUseFilterSet
  OR: TermsOfUseFilterSet
  XOR: TermsOfUseFilterSet
}

input TimeSlotInput {
  begin: Time!
  end: Time!
}

input UnitFilterSet {
  nameEnContains: String
  nameEnExact: String
  nameEnStartswith: String
  nameFiContains: String
  nameFiExact: String
  nameFiStartswith: String
  nameSvContains: String
  nameSvExact: String
  nameSvStartswith: String
  onlyDirectBookable: Boolean
  onlySeasonalBookable: Boolean
  onlyWithPermission: Boolean
  ownReservations: Boolean
  pk: [Int!]
  publishedReservationUnits: Boolean
  unitGroup: [Int!]
  NOT: UnitFilterSet
  AND: UnitFilterSet
  OR: UnitFilterSet
  XOR: UnitFilterSet
}

input UnitGroupFilterSet {
  applicationRound: Int
  nameEnContains: String
  nameEnExact: String
  nameEnStartswith: String
  nameFiContains: String
  nameFiExact: String
  nameFiStartswith: String
  nameSvContains: String
  nameSvExact: String
  nameSvStartswith: String
  """
  Returns UnitGroups that the user has direct permission to and UnitGroups
  that contain at least one unit that the user has permission to.
  """
  onlyWithPermission: Boolean
  pk: [Int!]
  NOT: UnitGroupFilterSet
  AND: UnitGroupFilterSet
  OR: UnitGroupFilterSet
  XOR: UnitGroupFilterSet
}

type Query {
  """
  Return all allocations that affect allocations for the given reservation unit
  (through space hierarchy or common resource) during the given time period.
  """
  affectingAllocatedTimeSlots(
    reservationUnit: Int!
    beginDate: Date!
    endDate: Date!
  ): [AllocatedTimeSlotNode!]!
  """
  Find all reservations that affect other reservations through the space hierarchy or a common resource.
  """
  affectingReservations(
    beginDate: Date!
    endDate: Date!
    state: [ReservationStateChoice!] = null
    forUnits: [Int!] = null
    forReservationUnits: [Int!] = null
  ): [ReservationNode!]!
  allAgeGroups: [AgeGroupNode!]!
  allEquipmentCategories(
    filter: EquipmentCategoryFilterSet
    orderBy: [EquipmentCategoryOrderSet!]
  ): [EquipmentCategoryNode!]!
  allEquipments(
    filter: EquipmentFilterSet
    orderBy: [EquipmentOrderSet!]
  ): [EquipmentNode!]!
  allMetadataSets: [ReservationMetadataSetNode!]!
  allPurposes(
    filter: PurposeFilterSet
    orderBy: [PurposeOrderSet!]
  ): [PurposeNode!]!
  allReservationCancelReasons: [ReservationCancelReasonType!]!
  allReservationDenyReasons(
    filter: ReservationDenyReasonFilterSet
    orderBy: [ReservationDenyReasonOrderSet!]
  ): [ReservationDenyReasonNode!]!
  allReservationPurposes(
    filter: ReservationPurposeFilterSet
    orderBy: [ReservationPurposeOrderSet!]
  ): [ReservationPurposeNode!]!
  allReservationUnitTypes(
    filter: ReservationUnitTypeFilterSet
    orderBy: [ReservationUnitTypeOrderSet!]
  ): [ReservationUnitTypeNode!]!
  """
  This Node should be kept to the bare minimum and never expose any relations to avoid performance issues.
  """
  allReservationUnits(
    filter: ReservationUnitAllFilterSet
    orderBy: [ReservationUnitAllOrderSet!]
  ): [ReservationUnitAllNode!]!
  allTaxPercentages(
    filter: TaxPercentageFilterSet
    orderBy: [TaxPercentageOrderSet!]
  ): [TaxPercentageNode!]!
  allTermsOfUse(
    filter: TermsOfUseFilterSet
    orderBy: [TermsOfUseOrderSet!]
  ): [TermsOfUseNode!]!
  allUnitGroups(
    filter: UnitGroupFilterSet
  ): [UnitGroupNode!]!
  """
  This Node should be kept to the bare minimum and never expose any relations to avoid performance issues.
  """
  allUnits(
    filter: UnitFilterSet
    orderBy: [UnitOrderSet!]
  ): [UnitAllNode!]!
  allocatedTimeSlots(
    """Only return items in the connection that come after this cursor."""
    after: String
    """Only return items in the connection that come before this cursor."""
    before: String
    """Number of items to return from the start."""
    first: Int
    """Number of items to return from the end (after evaluating first)."""
    last: Int
    """Number of items to skip from the start."""
    offset: Int
    filter: AllocatedTimeSlotFilterSet
    orderBy: [AllocatedTimeSlotOrderSet!]
  ): AllocatedTimeSlotNodeConnection!
  applicationRounds(
    """Only return items in the connection that come after this cursor."""
    after: String
    """Only return items in the connection that come before this cursor."""
    before: String
    """Number of items to return from the start."""
    first: Int
    """Number of items to return from the end (after evaluating first)."""
    last: Int
    """Number of items to skip from the start."""
    offset: Int
    filter: ApplicationRoundFilterSet
    orderBy: [ApplicationRoundOrderSet!]
  ): ApplicationRoundNodeConnection!
  applicationSections(
    """Only return items in the connection that come after this cursor."""
    after: String
    """Only return items in the connection that come before this cursor."""
    before: String
    """Number of items to return from the start."""
    first: Int
    """Number of items to return from the end (after evaluating first)."""
    last: Int
    """Number of items to skip from the start."""
    offset: Int
    filter: ApplicationSectionFilterSet
    orderBy: [ApplicationSectionOrderSet!]
  ): ApplicationSectionNodeConnection!
  applications(
    """Only return items in the connection that come after this cursor."""
    after: String
    """Only return items in the connection that come before this cursor."""
    before: String
    """Number of items to return from the start."""
    first: Int
    """Number of items to return from the end (after evaluating first)."""
    last: Int
    """Number of items to skip from the start."""
    offset: Int
    filter: ApplicationFilterSet
    orderBy: [ApplicationOrderSet!]
  ): ApplicationNodeConnection!
  bannerNotifications(
    """Only return items in the connection that come after this cursor."""
    after: String
    """Only return items in the connection that come before this cursor."""
    before: String
    """Number of items to return from the start."""
    first: Int
    """Number of items to return from the end (after evaluating first)."""
    last: Int
    """Number of items to skip from the start."""
    offset: Int
    filter: BannerNotificationFilterSet
    orderBy: [BannerNotificationOrderSet!]
  ): BannerNotificationNodeConnection!
  checkPermissions(
    permission: UserPermissionChoice!
    units: [Int!] = null
    requireAll: Boolean! = false
  ): PermissionCheckResultType!
  currentUser: UserNode
  """An interface for objects with Global IDs."""
  node(
    """The Global ID of an object."""
    id: ID!
  ): Node
  order(
    orderUuid: UUID!
  ): PaymentOrderNode!
  """
  Get information about a user from Helsinki profile.
  If user is not a profile user, still return data stored in our database, e.g. first and last name.

  Use only one of 'reservationPk' or 'applicationPk' to select the user.
  This determines the required permissions to view the user's data.
  If neither is given, the user is the currently logged in user.
  """
  profileData(
    """View profile data for this application's user."""
    applicationPk: Int = null
    """View profile data for this reservation's user."""
    reservationPk: Int = null
  ): UserProfileInfoType!
  rejectedOccurrences(
    """Only return items in the connection that come after this cursor."""
    after: String
    """Only return items in the connection that come before this cursor."""
    before: String
    """Number of items to return from the start."""
    first: Int
    """Number of items to return from the end (after evaluating first)."""
    last: Int
    """Number of items to skip from the start."""
    offset: Int
    filter: RejectedOccurrenceFilterSet
    orderBy: [RejectedOccurrenceOrderSet!]
  ): RejectedOccurrenceNodeConnection!
  reservationUnitCancellationRules(
    """Only return items in the connection that come after this cursor."""
    after: String
    """Only return items in the connection that come before this cursor."""
    before: String
    """Number of items to return from the start."""
    first: Int
    """Number of items to return from the end (after evaluating first)."""
    last: Int
    """Number of items to skip from the start."""
    offset: Int
    filter: ReservationUnitCancellationRuleFilterSet
    orderBy: [ReservationUnitCancellationRuleOrderSet!]
  ): ReservationUnitCancellationRuleNodeConnection!
  reservationUnits(
    """Only return items in the connection that come after this cursor."""
    after: String
    """Only return items in the connection that come before this cursor."""
    before: String
    """Number of items to return from the start."""
    first: Int
    """Number of items to return from the end (after evaluating first)."""
    last: Int
    """Number of items to skip from the start."""
    offset: Int
    """
    Filter reservation units by their reservability.

    If 'showOnlyReservable' is True, then only reservation units,
    which are reservable with the given filters are returned.
    Otherwise, all reservation units are returned.
    """
    firstReservableTime: ReservationUnitFilterDataInput
    filter: ReservationUnitFilterSet
    orderBy: [ReservationUnitOrderSet!]
  ): ReservationUnitNodeConnection!
  reservations(
    """Only return items in the connection that come after this cursor."""
    after: String
    """Only return items in the connection that come before this cursor."""
    before: String
    """Number of items to return from the start."""
    first: Int
    """Number of items to return from the end (after evaluating first)."""
    last: Int
    """Number of items to skip from the start."""
    offset: Int
    filter: ReservationFilterSet
    orderBy: [ReservationOrderSet!]
  ): ReservationNodeConnection!
  units(
    """Only return items in the connection that come after this cursor."""
    after: String
    """Only return items in the connection that come before this cursor."""
    before: String
    """Number of items to return from the start."""
    first: Int
    """Number of items to return from the end (after evaluating first)."""
    last: Int
    """Number of items to skip from the start."""
    offset: Int
    filter: UnitFilterSet
    orderBy: [UnitOrderSet!]
  ): UnitNodeConnection!
}

type Mutation {
  """Add a reservation to a reservation series."""
  addReservationToSeries(
    input: ReservationSeriesAddMutation!
  ): ReservationSeriesNode!
  """Adjust the time for a reservation."""
  adjustReservationTime(
    input: ReservationAdjustTimeMutation!
  ): ReservationNode!
  """Approve a reservation during handling."""
  approveReservation(
    input: ReservationApproveMutation!
  ): ReservationNode!
  """Archive a reservation unit."""
  archiveReservationUnit(
    input: ReservationUnitArchiveMutation!
  ): ReservationUnitNode!
  """
  Cancel all reservations in the given application section that can be cancelled.
  """
  cancelAllApplicationSectionReservations(
    input: ApplicationSectionReservationCancellationMutation!
  ): ApplicationSectionReservationCancellationMutationOutputType!
  cancelApplication(
    input: ApplicationCancelMutation!
  ): ApplicationNode!
  """Cancel a reservation."""
  cancelReservation(
    input: ReservationCancelMutation!
  ): ReservationNode!
  """Change the access code of a reservation series."""
  changeReservationSeriesAccessCode(
    input: ReservationSeriesChangeAccessCodeMutation!
  ): ReservationSeriesChangeAccessCodeMutationOutputType!
  """
  Confirm a tentative reservation. Reservation might still require handling and/or payment.
  """
  confirmReservation(
    input: ReservationConfirmMutation!
  ): ReservationNode!
  """Create an allocated time slot for a reservation unit option."""
  createAllocatedTimeslot(
    input: AllocatedTimeSlotCreateMutation!
  ): AllocatedTimeSlotNode!
  createApplication(
    input: ApplicationCreateMutation!
  ): ApplicationNode!
  createBannerNotification(
    input: BannerNotificationCreateMutation!
  ): BannerNotificationNode!
  """Create a tentative reservation before moving to the checkout flow."""
  createReservation(
    input: ReservationCreateMutation!
  ): ReservationNode!
  """Create the reservation series with all its reservations."""
  createReservationSeries(
    input: ReservationSeriesCreateMutation!
  ): ReservationSeriesNode!
  """Create a new ReservationUnit."""
  createReservationUnit(
    input: ReservationUnitCreateMutation!
  ): ReservationUnitNode!
  createReservationUnitImage(
    input: ReservationUnitImageCreateMutation!
  ): ReservationUnitImageNode!
  createResource(
    input: ResourceCreateMutation!
  ): ResourceNode!
  createSpace(
    input: SpaceCreateMutation!
  ): SpaceNode!
  """Create a reservation as a staff user."""
  createStaffReservation(
    input: ReservationStaffCreateMutation!
  ): ReservationNode!
  deleteAllocatedTimeslot(
    input: AllocatedTimeSlotDeleteMutation!
  ): AllocatedTimeSlotDeleteMutationOutput!
  deleteBannerNotification(
    input: BannerNotificationDeleteMutation!
  ): BannerNotificationDeleteMutationOutput!
  deleteReservationUnitImage(
    input: ReservationUnitImageDeleteMutation!
  ): ReservationUnitImageDeleteMutationOutput!
  deleteResource(
    input: ResourceDeleteMutation!
  ): ResourceDeleteMutationOutput!
  deleteSpace(
    input: SpaceDeleteMutation!
  ): SpaceDeleteMutationOutput!
  """Delete a reservation before it's confirmed."""
  deleteTentativeReservation(
    input: ReservationDeleteTentativeMutation!
  ): ReservationDeleteTentativeMutationOutput!
  """Deny a reservation during handling."""
  denyReservation(
    input: ReservationDenyMutation!
  ): ReservationNode!
  denyReservationSeries(
    input: ReservationSeriesDenyMutation!
  ): ReservationSeriesDenyMutationOutputType!
  """Allows staff to refund a reservation after denying it."""
  refundReservation(
    input: ReservationRefundMutation!
  ): ReservationNode!
  rejectAllApplicationOptions(
    input: RejectAllApplicationOptionsMutation!
  ): ApplicationNode!
  rejectAllSectionOptions(
    input: RejectAllSectionOptionsMutation!
  ): ApplicationSectionNode!
  """
  Synchronize the state of the reservation series' access code between Varaamo and Pindora
  to what Varaamo thinks is should be its correct state.
  """
  repairReservationSeriesAccessCode(
    input: ReservationSeriesRepairAccessCodeMutation!
  ): ReservationSeriesRepairAccessCodeMutationOutputType!
  """
  Move an 'approved' or 'denied' reservation back to 'requires handling' state.
  """
  requireHandlingForReservation(
    input: ReservationRequiresHandlingMutation!
  ): ReservationNode!
  """Reschedule reservation series."""
  rescheduleReservationSeries(
    input: ReservationSeriesRescheduleMutation!
  ): ReservationSeriesNode!
  restoreAllApplicationOptions(
    input: RestoreAllApplicationOptionsMutation!
  ): ApplicationNode!
  restoreAllSectionOptions(
    input: RestoreAllSectionOptionsMutation!
  ): ApplicationSectionNode!
  sendApplication(
    input: ApplicationSendMutation!
  ): ApplicationNode!
  setApplicationRoundHandled(
    input: SetApplicationRoundHandledMutation!
  ): ApplicationRoundNode!
  setApplicationRoundResultsSent(
    input: SetApplicationRoundResultsSentMutation!
  ): ApplicationRoundNode!
  """Adjust a reservation's time as a staff member."""
  staffAdjustReservationTime(
    input: ReservationStaffAdjustTimeMutation!
  ): ReservationNode!
  """Change the access code of a reservation."""
  staffChangeReservationAccessCode(
    input: ReservationStaffChangeAccessCodeMutation!
  ): ReservationNode!
  """
  Synchronize the state of the reservation's access code between Varaamo and Pindora
  to what Varaamo thinks is should be its correct state.
  """
  staffRepairReservationAccessCode(
    input: ReservationStaffRepairAccessCodeMutation!
  ): ReservationNode!
  """Modify a reservation as a staff member."""
  staffReservationModify(
    input: ReservationStaffModifyMutation!
  ): ReservationNode!
  updateApplication(
    input: ApplicationUpdateMutation!
  ): ApplicationNode!
  updateApplicationWorkingMemo(
    input: ApplicationWorkingMemoMutation!
  ): ApplicationNode!
  updateBannerNotification(
    input: BannerNotificationUpdateMutation!
  ): BannerNotificationNode!
  """Update reservation during checkout."""
  updateReservation(
    input: ReservationUpdateMutation!
  ): ReservationNode!
  """Update reservation series and its reservation data."""
  updateReservationSeries(
    input: ReservationSeriesUpdateMutation!
  ): ReservationSeriesNode!
  """Update a ReservationUnit."""
  updateReservationUnit(
    input: ReservationUnitUpdateMutation!
  ): ReservationUnitNode!
  updateReservationUnitImage(
    input: ReservationUnitImageUpdateMutation!
  ): ReservationUnitImageNode!
  updateReservationUnitOption(
    input: ReservationUnitOptionUpdateMutation!
  ): ReservationUnitOptionNode!
  """Update the working memo of a reservation."""
  updateReservationWorkingMemo(
    input: ReservationWorkingMemoMutation!
  ): ReservationNode!
  updateResource(
    input: ResourceUpdateMutation!
  ): ResourceNode!
  updateSpace(
    input: SpaceUpdateMutation!
  ): SpaceNode!
}
