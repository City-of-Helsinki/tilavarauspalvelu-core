"""Exposes a URL that specifies the behaviour of this scalar."""
directive @specifiedBy(
  """The URL that specifies the behaviour of this scalar."""
  url: String!
) on SCALAR

type AbilityGroupType {
  name: String!
  pk: Int
}

input AddressCreateSerializerInput {
  pk: Int
  streetAddress: String!
  postCode: String!
  city: String!
}

input AddressSerializerInput {
  id: Int
  streetAddress: String!
  postCode: String!
  city: String!
}

type AddressType implements Node {
  streetAddress: String!
  postCode: String!
  city: String!

  """The ID of the object"""
  id: ID!
  pk: Int
}

type AgeGroupType implements Node {
  minimum: Int!
  maximum: Int

  """The ID of the object"""
  id: ID!
  pk: Int
}

type AgeGroupTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [AgeGroupTypeEdge]!
}

"""A Relay edge containing a `AgeGroupType` and its cursor."""
type AgeGroupTypeEdge {
  """The item at the end of the edge"""
  node: AgeGroupType

  """A cursor for use in pagination"""
  cursor: String!
}

type ApplicationAggregatedDataType {
  appliedMinDurationTotal: Float
  appliedReservationsTotal: Float
  createdReservationsTotal: Float
  reservationsDurationTotal: Float
}

input ApplicationCreateMutationInput {
  applicantType: String!

  """Organisation information for the application"""
  organisation: OrganisationCreateSerializerInput

  """Id of the application period for which this application is targeted to"""
  applicationRoundPk: Int!

  """Contact person information for the application"""
  contactPerson: PersonCreateSerializerInput!
  user: String

  """List of applications events"""
  applicationEvents: [ApplicationEventInApplicationSerializerInput]!

  """Status of this application"""
  status: String!

  """Billing address for the application"""
  billingAddress: AddressCreateSerializerInput!
  homeCityPk: Int

  """Additional information about the application"""
  additionalInformation: String
  clientMutationId: String
}

type ApplicationCreateMutationPayload {
  pk: Int
  applicantType: String
  applicantName: String
  applicantEmail: String

  """Organisation information for the application"""
  organisation: OrganisationType

  """Id of the application period for which this application is targeted to"""
  applicationRoundPk: Int

  """Contact person information for the application"""
  contactPerson: PersonType

  """List of applications events"""
  applicationEvents: [ApplicationEventType]

  """Status of this application"""
  status: String

  """Billing address for the application"""
  billingAddress: AddressType
  homeCityPk: Int
  createdDate: DateTime
  lastModifiedDate: DateTime

  """Additional information about the application"""
  additionalInformation: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  application: ApplicationType
  clientMutationId: String
}

input ApplicationDeclineMutationInput {
  pk: Int
  clientMutationId: String
}

type ApplicationDeclineMutationPayload {
  pk: Int
  status: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  clientMutationId: String
}

type ApplicationEventAggregatedDataType {
  durationTotal: Float
  reservationsTotal: Float
  allocationResultsDurationTotal: Float
  allocationResultsReservationsTotal: Float
}

input ApplicationEventCreateMutationInput {
  name: String
  applicationEventSchedules: [ApplicationEventScheduleCreateSerializerInput]!
  numPersons: Int

  """Age group pk for this event"""
  ageGroup: Int!

  """AbilityGroup pk for this event"""
  abilityGroup: Int!
  minDuration: String
  maxDuration: String

  """Application pk for this event"""
  application: Int!
  eventsPerWeek: Int
  biweekly: Boolean
  begin: Date
  end: Date

  """ReservationPurpose pk for this event"""
  purpose: Int!
  eventReservationUnits: [EventReservationUnitCreateSerializerInput]!

  """Status of this application event"""
  status: String!
  clientMutationId: String
}

type ApplicationEventCreateMutationPayload {
  pk: Int
  name: String
  applicationEventSchedules: [ApplicationEventScheduleType]
  numPersons: Int

  """Age group pk for this event"""
  ageGroup: Int

  """AbilityGroup pk for this event"""
  abilityGroup: Int
  minDuration: String
  maxDuration: String

  """Application pk for this event"""
  application: Int
  eventsPerWeek: Int
  biweekly: Boolean
  begin: Date
  end: Date

  """ReservationPurpose pk for this event"""
  purpose: Int
  eventReservationUnits: [EventReservationUnitType]

  """Status of this application event"""
  status: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  applicationEvent: ApplicationEventType
  clientMutationId: String
}

input ApplicationEventDeclineMutationInput {
  pk: Int
  clientMutationId: String
}

type ApplicationEventDeclineMutationPayload {
  pk: Int
  status: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  clientMutationId: String
}

input ApplicationEventDeleteMutationInput {
  pk: Int!
  clientMutationId: String
}

type ApplicationEventDeleteMutationPayload {
  deleted: Boolean
  errors: String
  clientMutationId: String
}

input ApplicationEventFlagMutationInput {
  pk: Int
  flagged: Boolean
  clientMutationId: String
}

type ApplicationEventFlagMutationPayload {
  pk: Int
  flagged: Boolean

  """May contain more than one error for same field."""
  errors: [ErrorType]
  clientMutationId: String
}

input ApplicationEventInApplicationSerializerInput {
  pk: Int
  name: String
  applicationEventSchedules: [ApplicationEventScheduleCreateSerializerInput]!
  numPersons: Int

  """Age group pk for this event"""
  ageGroup: Int!

  """AbilityGroup pk for this event"""
  abilityGroup: Int!
  minDuration: String
  maxDuration: String

  """Application pk for this event"""
  application: Int
  eventsPerWeek: Int
  biweekly: Boolean
  begin: Date
  end: Date

  """ReservationPurpose pk for this event"""
  purpose: Int!
  eventReservationUnits: [EventReservationUnitCreateSerializerInput]!

  """Status of this application event"""
  status: String!
}

input ApplicationEventScheduleCreateSerializerInput {
  pk: Int
  day: Int!

  """Begin time of requested reservation allocation slot."""
  begin: Time!

  """End time of requested reservation allocation slot."""
  end: Time!

  """Priority of requested reservation allocation slot as an integer."""
  priority: priority
}

input ApplicationEventScheduleResultCreateMutationInput {
  accepted: Boolean
  declined: Boolean

  """Application schedule pk for this result"""
  applicationEventSchedule: Int!
  allocatedReservationUnit: Int!
  allocatedDay: Int
  allocatedBegin: Time
  allocatedEnd: Time
  basket: String
  clientMutationId: String
}

type ApplicationEventScheduleResultCreateMutationPayload {
  accepted: Boolean
  declined: Boolean

  """Application schedule pk for this result"""
  applicationEventSchedule: Int
  allocatedReservationUnit: Int
  allocatedDay: Int
  allocatedBegin: Time
  allocatedEnd: Time
  basket: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  applicationEventScheduleResult: ApplicationEventScheduleResultType
  clientMutationId: String
}

type ApplicationEventScheduleResultType implements Node {
  accepted: Boolean!
  declined: Boolean!
  allocatedReservationUnit: ReservationUnitType
  allocatedDay: Int
  allocatedBegin: Time!
  allocatedEnd: Time!
  basket: ApplicationRoundBasketType

  """The ID of the object"""
  id: ID!
  pk: Int
}

input ApplicationEventScheduleResultUpdateMutationInput {
  accepted: Boolean
  declined: Boolean

  """Application schedule pk for this result"""
  applicationEventSchedule: Int!
  allocatedReservationUnit: Int!
  allocatedDay: Int
  allocatedBegin: Time
  allocatedEnd: Time
  basket: String
  clientMutationId: String
}

type ApplicationEventScheduleResultUpdateMutationPayload {
  accepted: Boolean
  declined: Boolean

  """Application schedule pk for this result"""
  applicationEventSchedule: Int
  allocatedReservationUnit: Int
  allocatedDay: Int
  allocatedBegin: Time
  allocatedEnd: Time
  basket: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  applicationEventScheduleResult: ApplicationEventScheduleResultType
  clientMutationId: String
}

type ApplicationEventScheduleType implements Node {
  """The ID of the object"""
  id: ID!
  day: Int
  begin: Time!
  end: Time!
  priority: Int
  applicationEventScheduleResult: ApplicationEventScheduleResultType
  pk: Int
}

"""An enumeration."""
enum applicationEventStatus {
  created
  approved
  reserved
  failed
  declined
}

type ApplicationEventType implements Node {
  """The ID of the object"""
  id: ID!
  name: String!
  numPersons: Int
  ageGroup: AgeGroupType
  abilityGroup: AbilityGroupType
  minDuration: Float
  maxDuration: Float
  eventsPerWeek: Int
  biweekly: Boolean!
  begin: Date
  end: Date
  application: ApplicationType!
  purpose: ReservationPurposeType
  declinedReservationUnits: [ReservationUnitType!]
  uuid: UUID!
  flagged: Boolean!
  aggregatedData: ApplicationEventAggregatedDataType
  eventReservationUnits: [EventReservationUnitType]
  applicationEventSchedules: [ApplicationEventScheduleType]
  pk: Int
  status: applicationEventStatus
  weeklyAmountReductionsCount: Int
}

type ApplicationEventTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ApplicationEventTypeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `ApplicationEventType` and its cursor."""
type ApplicationEventTypeEdge {
  """The item at the end of the edge"""
  node: ApplicationEventType

  """A cursor for use in pagination"""
  cursor: String!
}

input ApplicationEventUpdateMutationInput {
  pk: Int
  name: String
  applicationEventSchedules: [ApplicationEventScheduleCreateSerializerInput]
  numPersons: Int

  """Age group pk for this event"""
  ageGroup: Int

  """AbilityGroup pk for this event"""
  abilityGroup: Int
  minDuration: String
  maxDuration: String

  """Application pk for this event"""
  application: Int
  eventsPerWeek: Int
  biweekly: Boolean
  begin: Date
  end: Date

  """ReservationPurpose pk for this event"""
  purpose: Int
  eventReservationUnits: [EventReservationUnitCreateSerializerInput]

  """Status of this application event"""
  status: String
  clientMutationId: String
}

type ApplicationEventUpdateMutationPayload {
  pk: Int
  name: String
  applicationEventSchedules: [ApplicationEventScheduleType]
  numPersons: Int

  """Age group pk for this event"""
  ageGroup: Int

  """AbilityGroup pk for this event"""
  abilityGroup: Int
  minDuration: String
  maxDuration: String

  """Application pk for this event"""
  application: Int
  eventsPerWeek: Int
  biweekly: Boolean
  begin: Date
  end: Date

  """ReservationPurpose pk for this event"""
  purpose: Int
  eventReservationUnits: [EventReservationUnitType]

  """Status of this application event"""
  status: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  applicationEvent: ApplicationEventType
  clientMutationId: String
}

input ApplicationFlagMutationInput {
  pk: Int
  flagged: Boolean!
  clientMutationId: String
}

type ApplicationFlagMutationPayload {
  pk: Int
  flagged: Boolean

  """May contain more than one error for same field."""
  errors: [ErrorType]
  clientMutationId: String
}

type ApplicationRoundAggregatedDataType {
  allocationResultEventsCount: Int
  allocationDurationTotal: Int
  totalReservationDuration: Int
  totalHourCapacity: Int
}

type ApplicationRoundBasketType implements Node {
  """The ID of the object"""
  id: ID!
  name: String!
  mustBeMainPurposeOfApplicant: Boolean!
  customerType: [String]!
  allocationPercentage: Int!
  orderNumber: Int!
  pk: Int
  purposeIds: [Int]
  ageGroupIds: [Int]
  homeCityId: Int
}

"""An enumeration."""
enum applicationRoundStatus {
  draft
  in_review
  review_done
  allocated
  reserving
  handled
  sending
  sent
  archived
}

type ApplicationRoundType implements Node {
  """The ID of the object"""
  id: ID!
  nameFi: String
  nameEn: String
  nameSv: String
  targetGroup: ApplicationsApplicationRoundTargetGroupChoices!
  allocating: Boolean!
  reservationUnits: [ReservationUnitType]
  applicationPeriodBegin: DateTime!
  applicationPeriodEnd: DateTime!
  reservationPeriodBegin: Date!
  reservationPeriodEnd: Date!
  publicDisplayBegin: DateTime!
  publicDisplayEnd: DateTime!
  purposes: [ReservationPurposeType]
  serviceSector: ServiceSectorType
  criteriaFi: String
  criteriaEn: String
  criteriaSv: String
  aggregatedData: ApplicationRoundAggregatedDataType
  applicationRoundBaskets: [ApplicationRoundBasketType]
  pk: Int
  status: applicationRoundStatus
  statusTimestamp: DateTime
  applicationsSent: Boolean
  applicationsCount: Int
  reservationUnitCount: Int
}

type ApplicationRoundTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ApplicationRoundTypeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `ApplicationRoundType` and its cursor."""
type ApplicationRoundTypeEdge {
  """The item at the end of the edge"""
  node: ApplicationRoundType

  """A cursor for use in pagination"""
  cursor: String!
}

"""An enumeration."""
enum ApplicationsApplicationApplicantTypeChoices {
  """Individual"""
  INDIVIDUAL

  """Association"""
  ASSOCIATION

  """Community"""
  COMMUNITY

  """Company"""
  COMPANY
}

"""An enumeration."""
enum ApplicationsApplicationRoundTargetGroupChoices {
  """Internal"""
  INTERNAL

  """Public"""
  PUBLIC

  """Kaikki"""
  ALL
}

"""An enumeration."""
enum ApplicationsOrganisationOrganisationTypeChoices {
  """Company"""
  COMPANY

  """Registered association"""
  REGISTERED_ASSOCIATION

  """Public association"""
  PUBLIC_ASSOCIATION

  """Unregistered association"""
  UNREGISTERED_ASSOCIATION

  """Municipality consortium"""
  MUNICIPALITY_CONSORTIUM

  """Religious community"""
  RELIGIOUS_COMMUNITY
}

"""An enumeration."""
enum applicationStatus {
  draft
  received
  in_review
  review_done
  allocated
  handled
  sent
  expired
  cancelled
}

type ApplicationType implements Node {
  """The ID of the object"""
  id: ID!
  applicantType: ApplicationsApplicationApplicantTypeChoices
  organisation: OrganisationType
  contactPerson: PersonType
  applicationRound: ApplicationRoundType!
  billingAddress: AddressType
  homeCity: CityType

  """Additional information about the application"""
  additionalInformation: String
  createdDate: DateTime!
  lastModifiedDate: DateTime!
  aggregatedData: ApplicationAggregatedDataType
  applicationEvents: [ApplicationEventType]
  pk: Int
  status: applicationStatus
  applicantPk: Int
  applicantName: String
  applicantEmail: String
  applicantUser: UserType
}

type ApplicationTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ApplicationTypeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `ApplicationType` and its cursor."""
type ApplicationTypeEdge {
  """The item at the end of the edge"""
  node: ApplicationType

  """A cursor for use in pagination"""
  cursor: String!
}

input ApplicationUpdateMutationInput {
  pk: Int
  applicantType: String

  """Organisation information for the application"""
  organisation: OrganisationCreateSerializerInput

  """Id of the application period for which this application is targeted to"""
  applicationRoundPk: Int

  """Contact person information for the application"""
  contactPerson: PersonCreateSerializerInput
  user: String

  """Application events in application"""
  applicationEvents: [ApplicationEventInApplicationSerializerInput]

  """Status of this application"""
  status: String

  """Billing address for the application"""
  billingAddress: AddressCreateSerializerInput
  homeCityPk: Int

  """Additional information about the application"""
  additionalInformation: String
  clientMutationId: String
}

type ApplicationUpdateMutationPayload {
  pk: Int
  applicantType: String
  applicantName: String
  applicantEmail: String

  """Organisation information for the application"""
  organisation: OrganisationType

  """Id of the application period for which this application is targeted to"""
  applicationRoundPk: Int

  """Contact person information for the application"""
  contactPerson: PersonType

  """Application events in application"""
  applicationEvents: [ApplicationEventType]

  """Status of this application"""
  status: String

  """Billing address for the application"""
  billingAddress: AddressType
  homeCityPk: Int
  createdDate: DateTime
  lastModifiedDate: DateTime

  """Additional information about the application"""
  additionalInformation: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  application: ApplicationType
  clientMutationId: String
}

type BuildingType implements Node {
  nameFi: String
  nameEn: String
  nameSv: String
  district: DistrictType
  realEstate: RealEstateType
  surfaceArea: Decimal

  """The ID of the object"""
  id: ID!
  pk: Int
}

type CityType implements Node {
  name: String!
  nameFi: String
  nameEn: String
  nameSv: String

  """The ID of the object"""
  id: ID!
  pk: Int
}

type CityTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [CityTypeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `CityType` and its cursor."""
type CityTypeEdge {
  """The item at the end of the edge"""
  node: CityType

  """A cursor for use in pagination"""
  cursor: String!
}

"""
The `Date` scalar type represents a Date
value as specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar Date

"""
The `DateTime` scalar type represents a DateTime
value as specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar DateTime

"""The `Decimal` scalar type represents a python Decimal."""
scalar Decimal

type DistrictType implements Node {
  nameFi: String
  nameEn: String
  nameSv: String

  """The ID of the object"""
  id: ID!
  pk: Int
}

"""
The `Duration` scalar type represents a duration value as an integer in seconds.
For example, a value of 900 means a duration of 15 minutes.
"""
scalar Duration

input EquipmentCategoryCreateMutationInput {
  nameFi: String
  nameEn: String
  nameSv: String
  clientMutationId: String
}

type EquipmentCategoryCreateMutationPayload {
  pk: Int
  nameFi: String
  nameEn: String
  nameSv: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  equipmentCategory: EquipmentCategoryType
  clientMutationId: String
}

input EquipmentCategoryDeleteMutationInput {
  pk: Int!
  clientMutationId: String
}

type EquipmentCategoryDeleteMutationPayload {
  deleted: Boolean
  errors: String
  clientMutationId: String
}

type EquipmentCategoryType implements Node {
  nameFi: String
  nameEn: String
  nameSv: String

  """The ID of the object"""
  id: ID!
  pk: Int
}

type EquipmentCategoryTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [EquipmentCategoryTypeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `EquipmentCategoryType` and its cursor."""
type EquipmentCategoryTypeEdge {
  """The item at the end of the edge"""
  node: EquipmentCategoryType

  """A cursor for use in pagination"""
  cursor: String!
}

input EquipmentCategoryUpdateMutationInput {
  pk: Int!
  nameFi: String
  nameEn: String
  nameSv: String
  clientMutationId: String
}

type EquipmentCategoryUpdateMutationPayload {
  pk: Int
  nameFi: String
  nameEn: String
  nameSv: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  equipmentCategory: EquipmentCategoryType
  clientMutationId: String
}

input EquipmentCreateMutationInput {
  categoryPk: Int!
  nameFi: String
  nameEn: String
  nameSv: String
  clientMutationId: String
}

type EquipmentCreateMutationPayload {
  pk: Int
  categoryPk: Int
  nameFi: String
  nameEn: String
  nameSv: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  equipment: EquipmentType
  clientMutationId: String
}

input EquipmentDeleteMutationInput {
  pk: Int!
  clientMutationId: String
}

type EquipmentDeleteMutationPayload {
  deleted: Boolean
  errors: String
  clientMutationId: String
}

type EquipmentType implements Node {
  nameFi: String
  nameEn: String
  nameSv: String

  """The ID of the object"""
  id: ID!
  pk: Int
  category: EquipmentCategoryType
}

type EquipmentTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [EquipmentTypeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `EquipmentType` and its cursor."""
type EquipmentTypeEdge {
  """The item at the end of the edge"""
  node: EquipmentType

  """A cursor for use in pagination"""
  cursor: String!
}

input EquipmentUpdateMutationInput {
  pk: Int!
  categoryPk: Int!
  nameFi: String
  nameEn: String
  nameSv: String
  clientMutationId: String
}

type EquipmentUpdateMutationPayload {
  pk: Int
  categoryPk: Int
  nameFi: String
  nameEn: String
  nameSv: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  equipment: EquipmentType
  clientMutationId: String
}

type ErrorType {
  field: String!
  messages: [String!]!
}

input EventReservationUnitCreateSerializerInput {
  pk: Int

  """
  Priority of this reservation unit for the event. Lower the number, higher the priority.
  """
  priority: Int

  """pk of the reservation unit requested for the event."""
  reservationUnit: Int!
}

type EventReservationUnitType implements Node {
  """The ID of the object"""
  id: ID!
  priority: Int
  reservationUnit: ReservationUnitType
  pk: Int
}

type GeneralRolePermissionType {
  permission: String
}

type GeneralRoleType implements Node {
  role: RoleType

  """The ID of the object"""
  id: ID!
  pk: Int
  permissions: [GeneralRolePermissionType]
}

type KeywordCategoryType implements Node {
  nameFi: String
  nameEn: String
  nameSv: String

  """The ID of the object"""
  id: ID!
  pk: Int
  keywordGroups: [KeywordGroupType]
}

type KeywordCategoryTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [KeywordCategoryTypeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `KeywordCategoryType` and its cursor."""
type KeywordCategoryTypeEdge {
  """The item at the end of the edge"""
  node: KeywordCategoryType

  """A cursor for use in pagination"""
  cursor: String!
}

type KeywordGroupType implements Node {
  nameFi: String
  nameEn: String
  nameSv: String

  """The ID of the object"""
  id: ID!
  pk: Int
  keywords: [KeywordType]
}

type KeywordGroupTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [KeywordGroupTypeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `KeywordGroupType` and its cursor."""
type KeywordGroupTypeEdge {
  """The item at the end of the edge"""
  node: KeywordGroupType

  """A cursor for use in pagination"""
  cursor: String!
}

type KeywordType implements Node {
  nameFi: String
  nameEn: String
  nameSv: String

  """The ID of the object"""
  id: ID!
  pk: Int
}

type KeywordTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [KeywordTypeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `KeywordType` and its cursor."""
type KeywordTypeEdge {
  """The item at the end of the edge"""
  node: KeywordType

  """A cursor for use in pagination"""
  cursor: String!
}

type LocationType implements Node {
  addressStreetFi: String
  addressStreetEn: String
  addressStreetSv: String
  addressZip: String!
  addressCityFi: String
  addressCityEn: String
  addressCitySv: String

  """The ID of the object"""
  id: ID!
  pk: Int
  longitude: String
  latitude: String
}

type Mutation {
  createApplication(input: ApplicationCreateMutationInput!): ApplicationCreateMutationPayload
  updateApplication(input: ApplicationUpdateMutationInput!): ApplicationUpdateMutationPayload
  declineApplication(input: ApplicationDeclineMutationInput!): ApplicationDeclineMutationPayload
  flagApplication(input: ApplicationFlagMutationInput!): ApplicationFlagMutationPayload
  createApplicationEvent(input: ApplicationEventCreateMutationInput!): ApplicationEventCreateMutationPayload
  updateApplicationEvent(input: ApplicationEventUpdateMutationInput!): ApplicationEventUpdateMutationPayload
  deleteApplicationEvent(input: ApplicationEventDeleteMutationInput!): ApplicationEventDeleteMutationPayload
  declineApplicationEvent(input: ApplicationEventDeclineMutationInput!): ApplicationEventDeclineMutationPayload
  flagApplicationEvent(input: ApplicationEventFlagMutationInput!): ApplicationEventFlagMutationPayload
  createApplicationEventScheduleResult(input: ApplicationEventScheduleResultCreateMutationInput!): ApplicationEventScheduleResultCreateMutationPayload
  updateApplicationEventScheduleResult(input: ApplicationEventScheduleResultUpdateMutationInput!): ApplicationEventScheduleResultUpdateMutationPayload
  createRecurringReservation(input: RecurringReservationCreateMutationInput!): RecurringReservationCreateMutationPayload
  updateRecurringReservation(input: RecurringReservationUpdateMutationInput!): RecurringReservationUpdateMutationPayload
  createReservation(input: ReservationCreateMutationInput!): ReservationCreateMutationPayload
  createStaffReservation(input: ReservationStaffCreateMutationInput!): ReservationStaffCreateMutationPayload
  updateReservation(input: ReservationUpdateMutationInput!): ReservationUpdateMutationPayload
  confirmReservation(input: ReservationConfirmMutationInput!): ReservationConfirmMutationPayload
  cancelReservation(input: ReservationCancellationMutationInput!): ReservationCancellationMutationPayload
  denyReservation(input: ReservationDenyMutationInput!): ReservationDenyMutationPayload
  deleteReservation(input: ReservationDeleteMutationInput!): ReservationDeleteMutationPayload
  approveReservation(input: ReservationApproveMutationInput!): ReservationApproveMutationPayload
  requireHandlingForReservation(input: ReservationRequiresHandlingMutationInput!): ReservationRequiresHandlingMutationPayload
  updateReservationWorkingMemo(input: ReservationWorkingMemoMutationInput!): ReservationWorkingMemoMutationPayload
  adjustReservationTime(input: ReservationAdjustTimeMutationInput!): ReservationAdjustTimeMutationPayload
  createReservationUnit(input: ReservationUnitCreateMutationInput!): ReservationUnitCreateMutationPayload
  updateReservationUnit(input: ReservationUnitUpdateMutationInput!): ReservationUnitUpdateMutationPayload
  createReservationUnitImage(input: ReservationUnitImageCreateMutationInput!): ReservationUnitImageCreateMutationPayload
  updateReservationUnitImage(input: ReservationUnitImageUpdateMutationInput!): ReservationUnitImageUpdateMutationPayload
  deleteReservationUnitImage(input: ReservationUnitImageDeleteMutationInput!): ReservationUnitImageDeleteMutationPayload
  createPurpose(input: PurposeCreateMutationInput!): PurposeCreateMutationPayload
  updatePurpose(input: PurposeUpdateMutationInput!): PurposeUpdateMutationPayload
  createEquipment(input: EquipmentCreateMutationInput!): EquipmentCreateMutationPayload
  updateEquipment(input: EquipmentUpdateMutationInput!): EquipmentUpdateMutationPayload
  deleteEquipment(input: EquipmentDeleteMutationInput!): EquipmentDeleteMutationPayload
  createEquipmentCategory(input: EquipmentCategoryCreateMutationInput!): EquipmentCategoryCreateMutationPayload
  updateEquipmentCategory(input: EquipmentCategoryUpdateMutationInput!): EquipmentCategoryUpdateMutationPayload
  deleteEquipmentCategory(input: EquipmentCategoryDeleteMutationInput!): EquipmentCategoryDeleteMutationPayload
  createSpace(input: SpaceCreateMutationInput!): SpaceCreateMutationPayload
  updateSpace(input: SpaceUpdateMutationInput!): SpaceUpdateMutationPayload
  deleteSpace(input: SpaceDeleteMutationInput!): SpaceDeleteMutationPayload
  createResource(input: ResourceCreateMutationInput!): ResourceCreateMutationPayload
  updateResource(input: ResourceUpdateMutationInput!): ResourceUpdateMutationPayload
  deleteResource(input: ResourceDeleteMutationInput!): ResourceDeleteMutationPayload
  updateUnit(input: UnitUpdateMutationInput!): UnitUpdateMutationPayload
  updateUser(input: UserUpdateMutationInput!): UserUpdateMutationPayload
  refreshOrder(input: RefreshOrderMutationInput!): RefreshOrderMutationPayload
}

"""An object with an ID"""
interface Node {
  """The ID of the object"""
  id: ID!
}

type OpeningHoursType {
  openingTimes: [OpeningTimesType]
  openingTimePeriods: [PeriodType]
}

type OpeningTimesType {
  date: Date
  startTime: Time
  endTime: Time
  state: String
  periods: [Int]
  isReservable: Boolean
}

"""An enumeration."""
enum organisation_type {
  """Company"""
  COMPANY

  """Registered association"""
  REGISTERED_ASSOCIATION

  """Public association"""
  PUBLIC_ASSOCIATION

  """Unregistered association"""
  UNREGISTERED_ASSOCIATION

  """Municipality consortium"""
  MUNICIPALITY_CONSORTIUM

  """Religious community"""
  RELIGIOUS_COMMUNITY
}

input OrganisationCreateSerializerInput {
  pk: Int
  name: String!
  identifier: String
  yearEstablished: Int
  activeMembers: Int
  organisationType: organisation_type
  coreBusiness: String
  email: String

  """Address object of this organisation"""
  address: AddressSerializerInput!
}

type OrganisationType implements Node {
  """The ID of the object"""
  id: ID!
  name: String!
  identifier: String
  yearEstablished: Int
  address: AddressType
  activeMembers: Int
  coreBusiness: String!
  organisationType: ApplicationsOrganisationOrganisationTypeChoices!
  email: String!
  pk: Int
}

"""
The Relay compliant `PageInfo` type, containing data necessary to paginate this connection.
"""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String

  """When paginating forwards, the cursor to continue."""
  endCursor: String
}

type PaymentMerchantType implements Node {
  name: String!

  """The ID of the object"""
  id: ID!
  pk: String
}

type PaymentOrderType implements Node {
  paymentType: String
  status: String
  processedAt: DateTime
  checkoutUrl: String
  receiptUrl: String

  """The ID of the object"""
  id: ID!
  pk: Int
  orderUuid: String
  reservationPk: String
}

type PaymentProductType implements Node {
  """The ID of the object"""
  id: ID!
  pk: String
  merchantPk: String
}

type PeriodType {
  periodId: Int
  startDate: Date
  endDate: Date
  resourceState: String
  timeSpans: [TimeSpanType]
  nameFi: String
  nameEn: String
  nameSv: String
  descriptionFi: String
  descriptionEn: String
  descriptionSv: String
}

input PersonCreateSerializerInput {
  pk: Int
  firstName: String!
  lastName: String!
  email: String
  phoneNumber: String
}

type PersonType implements Node {
  """The ID of the object"""
  id: ID!
  email: String
  phoneNumber: String
  firstName: String!
  lastName: String!
  pk: Int
}

"""An enumeration."""
enum priority {
  """Low"""
  A_100

  """Medium"""
  A_200

  """High"""
  A_300
}

input PurposeCreateMutationInput {
  nameFi: String
  nameEn: String
  nameSv: String
  clientMutationId: String
}

type PurposeCreateMutationPayload {
  nameFi: String
  nameEn: String
  nameSv: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  purpose: PurposeType
  clientMutationId: String
}

type PurposeType implements Node {
  nameFi: String
  nameEn: String
  nameSv: String

  """Order number to be used in api sorting."""
  rank: Int

  """The ID of the object"""
  id: ID!
  pk: Int
  imageUrl: String
  smallUrl: String
}

type PurposeTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [PurposeTypeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `PurposeType` and its cursor."""
type PurposeTypeEdge {
  """The item at the end of the edge"""
  node: PurposeType

  """A cursor for use in pagination"""
  cursor: String!
}

input PurposeUpdateMutationInput {
  pk: Int!
  nameFi: String
  nameEn: String
  nameSv: String
  clientMutationId: String
}

type PurposeUpdateMutationPayload {
  pk: Int
  nameFi: String
  nameEn: String
  nameSv: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  purpose: PurposeType
  clientMutationId: String
}

type QualifierType implements Node {
  nameFi: String
  nameEn: String
  nameSv: String

  """The ID of the object"""
  id: ID!
  pk: Int
}

type QualifierTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [QualifierTypeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `QualifierType` and its cursor."""
type QualifierTypeEdge {
  """The item at the end of the edge"""
  node: QualifierType

  """A cursor for use in pagination"""
  cursor: String!
}

type Query {
  applications(
    offset: Int
    before: String
    after: String
    first: Int
    last: Int
    applicationRound: ID
    status: [String]
    unit: [ID]
    user: ID
    pk: [ID]
    applicantType: [String]

    """Järjestys"""
    orderBy: String
  ): ApplicationTypeConnection
  applicationEvents(
    offset: Int
    before: String
    after: String
    first: Int
    last: Int
    applicationRound: ID
    status: String
    unit: [ID]
    user: ID
    pk: [ID]
    application: ID
    applicationStatus: String
    reservationUnit: [ID]
    applicantType: [String]

    """Järjestys"""
    orderBy: String
  ): ApplicationEventTypeConnection
  applicationRounds(offset: Int, before: String, after: String, first: Int, last: Int, nameFi: String, nameFi_Icontains: String, nameFi_Istartswith: String, nameSv: String, nameSv_Icontains: String, nameSv_Istartswith: String, nameEn: String, nameEn_Icontains: String, nameEn_Istartswith: String): ApplicationRoundTypeConnection
  reservations(
    offset: Int
    before: String
    after: String
    first: Int
    last: Int
    begin: DateTime
    end: DateTime
    priceGte: Decimal
    priceLte: Decimal
    state: [String]
    requested: Boolean
    onlyWithPermission: Boolean
    user: ID
    reservationUnitNameFi: String
    reservationUnitNameEn: String
    reservationUnitNameSv: String
    unit: [ID]
    reservationUnit: [ID]
    reservationUnitType: [ID]
    textSearch: String

    """
    PaymentOrder's statuses; DRAFT, EXPIRED, CANCELLED, PAID, PAID_MANUALLY, REFUNDED
    """
    orderStatus: [String]

    """Järjestys"""
    orderBy: String
  ): ReservationTypeConnection
  reservationByPk(pk: Int): ReservationType
  recurringReservations(
    offset: Int
    before: String
    after: String
    first: Int
    last: Int
    begin: DateTime
    end: DateTime
    beginDate: Date
    endDate: Date
    beginTime: Time
    endTime: Time
    user: ID
    reservationUnitNameFi: String
    reservationUnitNameEn: String
    reservationUnitNameSv: String
    unit: [ID]
    reservationUnit: [ID]
    reservationUnitType: [ID]

    """Järjestys"""
    orderBy: String
  ): RecurringReservationTypeConnection
  reservationCancelReasons(offset: Int, before: String, after: String, first: Int, last: Int, reason: String): ReservationCancelReasonTypeConnection
  reservationDenyReasons(offset: Int, before: String, after: String, first: Int, last: Int, reason: String): ReservationDenyReasonTypeConnection
  reservationUnits(
    offset: Int
    before: String
    after: String
    first: Int
    last: Int
    pk: [ID]
    unit: [ID]
    keywordGroups: [ID]
    reservationUnitType: [ID]
    minPersonsGte: Decimal
    minPersonsLte: Decimal
    maxPersonsGte: Decimal
    maxPersonsLte: Decimal
    textSearch: String
    purposes: [ID]
    qualifiers: [ID]
    isDraft: Boolean
    isVisible: Boolean
    applicationRound: [ID]
    nameFi: String
    nameEn: String
    nameSv: String
    surfaceAreaGte: Decimal
    surfaceAreaLte: Decimal
    rankGte: Decimal
    rankLte: Decimal
    typeRankGte: Decimal
    typeRankLte: Decimal
    reservationKind: String
    state: [String]
    onlyWithPermission: Boolean

    """Järjestys"""
    orderBy: String
  ): ReservationUnitTypeConnection
  reservationUnit(
    """The ID of the object"""
    id: ID!
  ): ReservationUnitType
  reservationUnitByPk(pk: Int): ReservationUnitByPkType
  reservationUnitCancellationRules(offset: Int, before: String, after: String, first: Int, last: Int, name: String): ReservationUnitCancellationRuleTypeConnection
  reservationUnitTypes(
    offset: Int
    before: String
    after: String
    first: Int
    last: Int

    """Järjestys"""
    orderBy: String
  ): ReservationUnitTypeTypeConnection
  resources(offset: Int, before: String, after: String, first: Int, last: Int, nameFi: String, nameFi_Icontains: String, nameFi_Istartswith: String, nameSv: String, nameSv_Icontains: String, nameSv_Istartswith: String, nameEn: String, nameEn_Icontains: String, nameEn_Istartswith: String): ResourceTypeConnection
  resource(
    """The ID of the object"""
    id: ID!
  ): ResourceType
  resourceByPk(pk: Int): ResourceType
  equipments(
    offset: Int
    before: String
    after: String
    first: Int
    last: Int
    name: String
    rankGte: Decimal
    rankLte: Decimal

    """Järjestys"""
    orderBy: String
  ): EquipmentTypeConnection
  equipment(
    """The ID of the object"""
    id: ID!
  ): EquipmentType
  equipmentByPk(pk: Int): EquipmentType
  equipmentCategories(offset: Int, before: String, after: String, first: Int, last: Int, nameFi: String, nameFi_Icontains: String, nameFi_Istartswith: String, nameSv: String, nameSv_Icontains: String, nameSv_Istartswith: String, nameEn: String, nameEn_Icontains: String, nameEn_Istartswith: String): EquipmentCategoryTypeConnection
  equipmentCategory(
    """The ID of the object"""
    id: ID!
  ): EquipmentCategoryType
  equipmentCategoryByPk(pk: Int): EquipmentCategoryType
  spaces(offset: Int, before: String, after: String, first: Int, last: Int, nameFi: String, nameFi_Icontains: String, nameFi_Istartswith: String, nameSv: String, nameSv_Icontains: String, nameSv_Istartswith: String, nameEn: String, nameEn_Icontains: String, nameEn_Istartswith: String): SpaceTypeConnection
  space(
    """The ID of the object"""
    id: ID!
  ): SpaceType
  spaceByPk(pk: Int): SpaceType
  serviceSectors(offset: Int, before: String, after: String, first: Int, last: Int): ServiceSectorTypeConnection
  units(
    offset: Int
    before: String
    after: String
    first: Int
    last: Int
    pk: [ID]
    nameFi: String
    nameEn: String
    nameSv: String
    serviceSector: Decimal
    onlyWithPermission: Boolean
    publishedReservationUnits: Boolean
    ownReservations: Boolean

    """Järjestys"""
    orderBy: String
  ): UnitTypeConnection
  unit(
    """The ID of the object"""
    id: ID!
  ): UnitType
  unitByPk(pk: Int): UnitByPkType
  currentUser: UserType
  user(pk: Int): UserType
  keywordCategories(offset: Int, before: String, after: String, first: Int, last: Int, nameFi: String, nameSv: String, nameEn: String): KeywordCategoryTypeConnection
  keywordGroups(offset: Int, before: String, after: String, first: Int, last: Int, nameFi: String, nameSv: String, nameEn: String): KeywordGroupTypeConnection
  keywords(offset: Int, before: String, after: String, first: Int, last: Int, nameFi: String, nameSv: String, nameEn: String): KeywordTypeConnection
  purposes(
    offset: Int
    before: String
    after: String
    first: Int
    last: Int

    """Järjestys"""
    orderBy: String
  ): PurposeTypeConnection
  qualifiers(offset: Int, before: String, after: String, first: Int, last: Int, nameFi: String, nameEn: String, nameSv: String): QualifierTypeConnection
  reservationPurposes(offset: Int, before: String, after: String, first: Int, last: Int, nameFi: String, nameEn: String, nameSv: String): ReservationPurposeTypeConnection
  termsOfUse(offset: Int, before: String, after: String, first: Int, last: Int, termsType: TermsOfUseTermsOfUseTermsTypeChoices): TermsOfUseTypeConnection
  taxPercentages(offset: Int, before: String, after: String, first: Int, last: Int, value: Decimal): TaxPercentageTypeConnection
  ageGroups(offset: Int, before: String, after: String, first: Int, last: Int): AgeGroupTypeConnection
  cities(offset: Int, before: String, after: String, first: Int, last: Int): CityTypeConnection
  metadataSets(offset: Int, before: String, after: String, first: Int, last: Int): ReservationMetadataSetTypeConnection
  order(orderUuid: String): PaymentOrderType
}

type RealEstateType implements Node {
  nameFi: String
  nameEn: String
  nameSv: String
  district: DistrictType
  surfaceArea: Decimal

  """The ID of the object"""
  id: ID!
  pk: Int
}

input RecurringReservationCreateMutationInput {
  user: String
  name: String
  description: String
  reservationUnitPk: Int!
  ageGroupPk: Int
  abilityGroupPk: Int
  recurrenceInDays: Int!

  """List of weekdays which days the reservations occurs"""
  weekdays: [Int]!

  """Time when reservations begins."""
  beginTime: Time!

  """Time when reservations ends."""
  endTime: Time!

  """Date when first reservation begins."""
  beginDate: Date!

  """Date when last reservation begins."""
  endDate: Date!
  clientMutationId: String
}

type RecurringReservationCreateMutationPayload {
  pk: Int
  user: String
  name: String
  description: String
  reservationUnitPk: Int
  ageGroupPk: Int
  abilityGroupPk: Int
  recurrenceInDays: Int

  """List of weekdays which days the reservations occurs"""
  weekdays: [Int]

  """Time when reservations begins."""
  beginTime: Time

  """Time when reservations ends."""
  endTime: Time

  """Date when first reservation begins."""
  beginDate: Date

  """Date when last reservation begins."""
  endDate: Date

  """May contain more than one error for same field."""
  errors: [ErrorType]
  recurringReservation: RecurringReservationType
  clientMutationId: String
}

type RecurringReservationType implements Node {
  user: String
  ageGroup: AgeGroupType
  abilityGroup: AbilityGroupType
  reservationUnit: ReservationUnitByPkType!
  created: DateTime!
  name: String!
  description: String!

  """
  How this recurring reservation's reservations occurs within days. E.g 7 means
  that it occurs every week. 14 every other week
  """
  recurrenceInDays: Int
  weekdays: [Int]
  beginTime: Time
  endTime: Time
  beginDate: Date
  endDate: Date

  """The ID of the object"""
  id: ID!
  pk: Int
  applicationPk: Int
  applicationEventPk: Int
}

type RecurringReservationTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [RecurringReservationTypeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `RecurringReservationType` and its cursor."""
type RecurringReservationTypeEdge {
  """The item at the end of the edge"""
  node: RecurringReservationType

  """A cursor for use in pagination"""
  cursor: String!
}

input RecurringReservationUpdateMutationInput {
  pk: Int!
  user: String
  name: String
  description: String
  ageGroupPk: Int
  abilityGroupPk: Int
  recurrenceInDays: Int

  """List of weekdays which days the reservations occurs"""
  weekdays: [Int]

  """Time when reservations begins."""
  beginTime: Time

  """Time when reservations ends."""
  endTime: Time

  """Date when first reservation begins."""
  beginDate: Date

  """Date when last reservation begins."""
  endDate: Date
  clientMutationId: String
}

type RecurringReservationUpdateMutationPayload {
  pk: Int
  user: String
  name: String
  description: String
  ageGroupPk: Int
  abilityGroupPk: Int
  recurrenceInDays: Int

  """List of weekdays which days the reservations occurs"""
  weekdays: [Int]

  """Time when reservations begins."""
  beginTime: Time

  """Time when reservations ends."""
  endTime: Time

  """Date when first reservation begins."""
  beginDate: Date

  """Date when last reservation begins."""
  endDate: Date

  """May contain more than one error for same field."""
  errors: [ErrorType]
  recurringReservation: RecurringReservationType
  clientMutationId: String
}

input RefreshOrderMutationInput {
  orderUuid: UUID!
  clientMutationId: String
}

type RefreshOrderMutationPayload {
  orderUuid: UUID
  status: String
  clientMutationId: String
}

input ReservationAdjustTimeMutationInput {
  pk: Int!
  begin: DateTime!
  end: DateTime!
  state: state
  clientMutationId: String
}

type ReservationAdjustTimeMutationPayload {
  pk: Int
  begin: DateTime
  end: DateTime
  state: state

  """May contain more than one error for same field."""
  errors: [ErrorType]
  clientMutationId: String
}

input ReservationApproveMutationInput {
  pk: Int

  """Additional information for approval."""
  handlingDetails: String!
  price: Float!
  priceNet: Float!
  clientMutationId: String
}

type ReservationApproveMutationPayload {
  pk: Int
  state: state

  """Additional information for approval."""
  handlingDetails: String

  """When this reservation was handled."""
  handledAt: DateTime
  price: Float
  priceNet: Float

  """May contain more than one error for same field."""
  errors: [ErrorType]
  clientMutationId: String
}

input ReservationCancellationMutationInput {
  pk: Int!

  """Primary key for the pre-defined cancel reason."""
  cancelReasonPk: Int!

  """Additional information for the cancellation."""
  cancelDetails: String
  clientMutationId: String
}

type ReservationCancellationMutationPayload {
  pk: Int

  """Primary key for the pre-defined cancel reason."""
  cancelReasonPk: Int

  """Additional information for the cancellation."""
  cancelDetails: String
  state: state

  """May contain more than one error for same field."""
  errors: [ErrorType]
  clientMutationId: String
}

type ReservationCancelReasonType implements Node {
  reason: String!
  reasonFi: String
  reasonEn: String
  reasonSv: String

  """The ID of the object"""
  id: ID!
  pk: Int
}

type ReservationCancelReasonTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ReservationCancelReasonTypeEdge]!
}

"""
A Relay edge containing a `ReservationCancelReasonType` and its cursor.
"""
type ReservationCancelReasonTypeEdge {
  """The item at the end of the edge"""
  node: ReservationCancelReasonType

  """A cursor for use in pagination"""
  cursor: String!
}

input ReservationConfirmMutationInput {
  """Type of the payment. Possible values are ONLINE, INVOICE, ON_SITE."""
  paymentType: String
  pk: Int!
  clientMutationId: String
}

type ReservationConfirmMutationPayload {
  """Type of the payment. Possible values are ONLINE, INVOICE, ON_SITE."""
  paymentType: String
  pk: Int
  reserveeFirstName: String
  reserveeLastName: String
  reserveePhone: String
  reserveeOrganisationName: String
  reserveeAddressStreet: String
  reserveeAddressCity: String
  reserveeAddressZip: String
  reserveeEmail: String

  """
  Type of the reservee. Possible values are BUSINESS, NONPROFIT, INDIVIDUAL.
  """
  reserveeType: String

  """Reservee's business or association identity code"""
  reserveeId: String
  reserveeIsUnregisteredAssociation: Boolean
  reserveeLanguage: String
  homeCityPk: Int
  applyingForFreeOfCharge: Boolean
  freeOfChargeReason: String
  ageGroupPk: Int
  billingFirstName: String
  billingLastName: String
  billingAddressStreet: String
  billingAddressCity: String
  billingAddressZip: String
  billingPhone: String
  billingEmail: String
  numPersons: Int
  name: String
  description: String

  """
  String value for ReservationType's ReservationState enum. Possible values are
  CREATED, CANCELLED, REQUIRES_HANDLING, WAITING_FOR_PAYMENT, CONFIRMED, DENIED.
  """
  state: String
  priority: Int
  begin: DateTime
  end: DateTime
  bufferTimeBefore: Int
  bufferTimeAfter: Int
  purposePk: Int
  confirmedAt: DateTime

  """The unit price of this particular reservation"""
  unitPrice: Decimal

  """The value of the tax percentage for this particular reservation"""
  taxPercentageValue: Decimal

  """The price of this particular reservation including VAT"""
  price: Decimal

  """The price of this particular reservation excluding VAT"""
  priceNet: Decimal

  """The non subsidised price of this reservation excluding VAT"""
  nonSubsidisedPrice: Decimal

  """The non subsidised price of this reservation excluding VAT"""
  nonSubsidisedPriceNet: Decimal

  """
  Reservation type. Mutation requires special permissions. Possible values are NORMAL, BLOCKED, STAFF.
  """
  type: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  order: PaymentOrderType
  clientMutationId: String
}

input ReservationCreateMutationInput {
  reserveeFirstName: String
  reserveeLastName: String
  reserveePhone: String
  reserveeOrganisationName: String
  reserveeAddressStreet: String
  reserveeAddressCity: String
  reserveeAddressZip: String
  reserveeEmail: String

  """
  Type of the reservee. Possible values are BUSINESS, NONPROFIT, INDIVIDUAL.
  """
  reserveeType: String

  """Reservee's business or association identity code"""
  reserveeId: String
  reserveeIsUnregisteredAssociation: Boolean
  reserveeLanguage: String
  homeCityPk: Int
  applyingForFreeOfCharge: Boolean
  freeOfChargeReason: String
  ageGroupPk: Int
  billingFirstName: String
  billingLastName: String
  billingAddressStreet: String
  billingAddressCity: String
  billingAddressZip: String
  billingPhone: String
  billingEmail: String
  numPersons: Int
  name: String
  description: String
  priority: Int
  begin: DateTime!
  end: DateTime!
  bufferTimeBefore: Int
  bufferTimeAfter: Int
  reservationUnitPks: [Int]!
  purposePk: Int

  """
  Reservation type. Mutation requires special permissions. Possible values are NORMAL, BLOCKED, STAFF.
  """
  type: String
  clientMutationId: String
}

type ReservationCreateMutationPayload {
  pk: Int
  reserveeFirstName: String
  reserveeLastName: String
  reserveePhone: String
  reserveeOrganisationName: String
  reserveeAddressStreet: String
  reserveeAddressCity: String
  reserveeAddressZip: String
  reserveeEmail: String

  """
  Type of the reservee. Possible values are BUSINESS, NONPROFIT, INDIVIDUAL.
  """
  reserveeType: String

  """Reservee's business or association identity code"""
  reserveeId: String
  reserveeIsUnregisteredAssociation: Boolean
  reserveeLanguage: String
  homeCityPk: Int
  applyingForFreeOfCharge: Boolean
  freeOfChargeReason: String
  ageGroupPk: Int
  billingFirstName: String
  billingLastName: String
  billingAddressStreet: String
  billingAddressCity: String
  billingAddressZip: String
  billingPhone: String
  billingEmail: String
  numPersons: Int
  name: String
  description: String

  """Read only string value for ReservationType's ReservationState enum."""
  state: String
  priority: Int
  begin: DateTime
  end: DateTime
  bufferTimeBefore: Int
  bufferTimeAfter: Int
  purposePk: Int
  confirmedAt: DateTime

  """The unit price of this particular reservation"""
  unitPrice: Decimal

  """The value of the tax percentage for this particular reservation"""
  taxPercentageValue: Decimal

  """The price of this particular reservation including VAT"""
  price: Decimal

  """The price of this particular reservation excluding VAT"""
  priceNet: Decimal

  """The non subsidised price of this reservation excluding VAT"""
  nonSubsidisedPrice: Decimal

  """The non subsidised price of this reservation excluding VAT"""
  nonSubsidisedPriceNet: Decimal

  """
  Reservation type. Mutation requires special permissions. Possible values are NORMAL, BLOCKED, STAFF.
  """
  type: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  reservation: ReservationType
  clientMutationId: String
}

input ReservationDeleteMutationInput {
  pk: Int!
  clientMutationId: String
}

type ReservationDeleteMutationPayload {
  deleted: Boolean
  errors: String
  clientMutationId: String
}

input ReservationDenyMutationInput {
  pk: Int

  """Additional information for denying."""
  handlingDetails: String

  """Primary key for the pre-defined deny reason."""
  denyReasonPk: Int!
  clientMutationId: String
}

type ReservationDenyMutationPayload {
  pk: Int
  state: state

  """Additional information for denying."""
  handlingDetails: String

  """When this reservation was handled."""
  handledAt: DateTime

  """Primary key for the pre-defined deny reason."""
  denyReasonPk: Int

  """May contain more than one error for same field."""
  errors: [ErrorType]
  clientMutationId: String
}

type ReservationDenyReasonType implements Node {
  reason: String!
  reasonFi: String
  reasonEn: String
  reasonSv: String

  """The ID of the object"""
  id: ID!
  pk: Int
}

type ReservationDenyReasonTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ReservationDenyReasonTypeEdge]!
}

"""A Relay edge containing a `ReservationDenyReasonType` and its cursor."""
type ReservationDenyReasonTypeEdge {
  """The item at the end of the edge"""
  node: ReservationDenyReasonType

  """A cursor for use in pagination"""
  cursor: String!
}

type ReservationMetadataSetType implements Node {
  name: String!
  supportedFields: [String]
  requiredFields: [String]

  """The ID of the object"""
  id: ID!
  pk: Int
}

type ReservationMetadataSetTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ReservationMetadataSetTypeEdge]!
}

"""A Relay edge containing a `ReservationMetadataSetType` and its cursor."""
type ReservationMetadataSetTypeEdge {
  """The item at the end of the edge"""
  node: ReservationMetadataSetType

  """A cursor for use in pagination"""
  cursor: String!
}

type ReservationPurposeType implements Node {
  nameFi: String
  nameEn: String
  nameSv: String

  """The ID of the object"""
  id: ID!
  pk: Int
}

type ReservationPurposeTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ReservationPurposeTypeEdge]!
}

"""A Relay edge containing a `ReservationPurposeType` and its cursor."""
type ReservationPurposeTypeEdge {
  """The item at the end of the edge"""
  node: ReservationPurposeType

  """A cursor for use in pagination"""
  cursor: String!
}

input ReservationRequiresHandlingMutationInput {
  pk: Int
  clientMutationId: String
}

type ReservationRequiresHandlingMutationPayload {
  pk: Int
  state: state

  """May contain more than one error for same field."""
  errors: [ErrorType]
  clientMutationId: String
}

"""An enumeration."""
enum ReservationsReservationPriorityChoices {
  """Low"""
  A_100

  """Medium"""
  A_200

  """High"""
  A_300
}

"""An enumeration."""
enum ReservationsReservationReserveeTypeChoices {
  """Business"""
  BUSINESS

  """Nonprofit"""
  NONPROFIT

  """Individual"""
  INDIVIDUAL
}

"""An enumeration."""
enum ReservationsReservationStateChoices {
  """created"""
  CREATED

  """cancelled"""
  CANCELLED

  """requires_handling"""
  REQUIRES_HANDLING

  """waiting_for_payment"""
  WAITING_FOR_PAYMENT

  """confirmed"""
  CONFIRMED

  """denied"""
  DENIED
}

input ReservationStaffCreateMutationInput {
  reserveeFirstName: String
  reserveeLastName: String
  reserveePhone: String
  reserveeOrganisationName: String
  reserveeAddressStreet: String
  reserveeAddressCity: String
  reserveeAddressZip: String
  reserveeEmail: String

  """
  Type of the reservee. Possible values are BUSINESS, NONPROFIT, INDIVIDUAL.
  """
  reserveeType: String

  """Reservee's business or association identity code"""
  reserveeId: String
  reserveeIsUnregisteredAssociation: Boolean
  reserveeLanguage: String
  billingFirstName: String
  billingLastName: String
  billingAddressStreet: String
  billingAddressCity: String
  billingAddressZip: String
  billingPhone: String
  billingEmail: String
  homeCityPk: Int
  applyingForFreeOfCharge: Boolean
  freeOfChargeReason: String
  ageGroupPk: Int
  numPersons: Int
  name: String
  description: String
  begin: DateTime!
  end: DateTime!
  bufferTimeBefore: String
  bufferTimeAfter: String
  reservationUnitPks: [Int]!
  purposePk: Int

  """The unit price of this particular reservation"""
  unitPrice: Decimal

  """
  Reservation type. Mutation requires special permissions. Possible values are NORMAL, BLOCKED, STAFF.
  """
  type: String!

  """Working memo for staff users."""
  workingMemo: String
  recurringReservationPk: Int
  clientMutationId: String
}

type ReservationStaffCreateMutationPayload {
  pk: Int
  reserveeFirstName: String
  reserveeLastName: String
  reserveePhone: String
  reserveeOrganisationName: String
  reserveeAddressStreet: String
  reserveeAddressCity: String
  reserveeAddressZip: String
  reserveeEmail: String

  """
  Type of the reservee. Possible values are BUSINESS, NONPROFIT, INDIVIDUAL.
  """
  reserveeType: String

  """Reservee's business or association identity code"""
  reserveeId: String
  reserveeIsUnregisteredAssociation: Boolean
  reserveeLanguage: String
  billingFirstName: String
  billingLastName: String
  billingAddressStreet: String
  billingAddressCity: String
  billingAddressZip: String
  billingPhone: String
  billingEmail: String
  homeCityPk: Int
  applyingForFreeOfCharge: Boolean
  freeOfChargeReason: String
  ageGroupPk: Int
  numPersons: Int
  name: String
  description: String
  state: state
  begin: DateTime
  end: DateTime
  bufferTimeBefore: String
  bufferTimeAfter: String
  reservationUnitPks: [Int]
  purposePk: Int
  confirmedAt: DateTime

  """When this reservation was handled."""
  handledAt: DateTime

  """The unit price of this particular reservation"""
  unitPrice: Decimal

  """
  Reservation type. Mutation requires special permissions. Possible values are NORMAL, BLOCKED, STAFF.
  """
  type: String

  """Working memo for staff users."""
  workingMemo: String
  recurringReservationPk: Int

  """May contain more than one error for same field."""
  errors: [ErrorType]
  reservation: ReservationType
  clientMutationId: String
}

type ReservationType implements Node {
  """Type of reservee"""
  reserveeType: ReservationsReservationReserveeTypeChoices
  reserveeFirstName: String
  reserveeLastName: String
  reserveeOrganisationName: String
  reserveePhone: String
  reserveeEmail: String
  reserveeId: String
  reserveeIsUnregisteredAssociation: Boolean!
  reserveeAddressStreet: String
  reserveeAddressCity: String
  reserveeAddressZip: String
  billingFirstName: String
  billingLastName: String
  billingPhone: String
  billingEmail: String
  billingAddressStreet: String
  billingAddressCity: String
  billingAddressZip: String

  """Home city of the group or association"""
  homeCity: CityType
  ageGroup: AgeGroupType
  applyingForFreeOfCharge: Boolean!
  freeOfChargeReason: String
  name: String
  description: String
  state: ReservationsReservationStateChoices!
  priority: ReservationsReservationPriorityChoices!
  user: UserType
  begin: DateTime!
  end: DateTime!
  bufferTimeBefore: Duration
  bufferTimeAfter: Duration
  recurringReservation: RecurringReservationType
  numPersons: Int
  purpose: ReservationPurposeType
  cancelDetails: String
  createdAt: String
  unitPrice: Float
  taxPercentageValue: Decimal
  price: Float

  """The price of this particular reservation excluding VAT"""
  priceNet: Decimal!
  handledAt: DateTime

  """Working memo for staff users."""
  workingMemo: String
  type: String

  """The ID of the object"""
  id: ID!
  pk: Int
  reservationUnits: [ReservationUnitType]
  staffEvent: Boolean @deprecated(reason: "Please refer to type.")
  orderUuid: String
  orderStatus: String
  calendarUrl: String
}

type ReservationTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ReservationTypeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `ReservationType` and its cursor."""
type ReservationTypeEdge {
  """The item at the end of the edge"""
  node: ReservationType

  """A cursor for use in pagination"""
  cursor: String!
}

type ReservationUnitByPkType implements Node {
  nameFi: String
  nameEn: String
  nameSv: String
  descriptionFi: String
  descriptionEn: String
  descriptionSv: String
  spaces: [SpaceType]
  resources: [ResourceType]
  services: [ServiceType]
  purposes: [PurposeType]
  reservationUnitType: ReservationUnitTypeType
  requireIntroduction: Boolean!
  termsOfUseFi: String
  termsOfUseEn: String
  termsOfUseSv: String
  paymentTerms: TermsOfUseType
  cancellationTerms: TermsOfUseType
  serviceSpecificTerms: TermsOfUseType
  pricingTerms: TermsOfUseType
  reservationPendingInstructionsFi: String
  reservationPendingInstructionsEn: String
  reservationPendingInstructionsSv: String
  reservationConfirmedInstructionsFi: String
  reservationConfirmedInstructionsEn: String
  reservationConfirmedInstructionsSv: String
  reservationCancelledInstructionsFi: String
  reservationCancelledInstructionsEn: String
  reservationCancelledInstructionsSv: String
  contactInformation: String!
  maxReservationDuration: Duration
  minReservationDuration: Duration
  uuid: UUID!
  isDraft: Boolean!
  maxPersons: Int
  minPersons: Int
  surfaceArea: Decimal
  bufferTimeBefore: Duration
  bufferTimeAfter: Duration
  cancellationRule: ReservationUnitCancellationRuleType

  """
  Determines the interval for the start time of the reservation. For example an
  interval of 15 minutes means a reservation can begin at minutes 15, 30, 60, or
  90. Possible values are interval_15_mins, interval_30_mins, interval_60_mins,
  interval_90_mins.
  """
  reservationStartInterval: ReservationUnitsReservationUnitReservationStartIntervalChoices!
  reservationsMaxDaysBefore: Int
  reservationsMinDaysBefore: Int

  """
  Time when making reservations become possible for this reservation unit.
  """
  reservationBegins: DateTime

  """
  Time when making reservations become not possible for this reservation unit
  """
  reservationEnds: DateTime

  """Time after this reservation unit should be publicly visible in UI."""
  publishBegins: DateTime

  """Time after this reservation unit should not be publicly visible in UI."""
  publishEnds: DateTime
  metadataSet: ReservationMetadataSetType
  maxReservationsPerUser: Int

  """
  Does reservations of this reservation unit need to be handled before they're confirmed.
  """
  requireReservationHandling: Boolean!

  """Authentication required for reserving this reservation unit."""
  authentication: ReservationUnitsReservationUnitAuthenticationChoices!

  """Order number to be use in api sorting."""
  rank: Int

  """What kind of reservations are to be booked with this reservation unit."""
  reservationKind: ReservationUnitsReservationUnitReservationKindChoices!
  paymentTypes: [ReservationUnitPaymentTypeType]

  """
  Can reservations to this reservation unit be able to apply free of charge.
  """
  canApplyFreeOfCharge: Boolean!

  """
  Is it possible to reserve this reservation unit when opening hours are not defined.
  """
  allowReservationsWithoutOpeningHours: Boolean!

  """Is reservation unit archived."""
  isArchived: Boolean!
  images: [ReservationUnitImageType]
  applicationRounds(active: Boolean): [ApplicationRoundType]

  """The ID of the object"""
  id: ID!
  reservations(from: Date, to: Date, state: [String], includeWithSameComponents: Boolean): [ReservationType]
  openingHours(openingTimes: Boolean, periods: Boolean, startDate: Date, endDate: Date): OpeningHoursType
  pk: Int
  qualifiers: [QualifierType]
  location: LocationType
  equipment: [EquipmentType]
  unit: UnitType
  keywordGroups: [KeywordGroupType]
  state: ReservationUnitState
  paymentMerchant: PaymentMerchantType
  paymentProduct: PaymentProductType
  pricings: [ReservationUnitPricingType]
  nextAvailableSlot: DateTime
  haukiUrl: ReservationUnitHaukiUrlType
}

type ReservationUnitCancellationRuleType implements Node {
  nameFi: String
  nameEn: String
  nameSv: String

  """
  Seconds before reservations related to this cancellation rule can be cancelled without handling.
  """
  canBeCancelledTimeBefore: Float
  needsHandling: Boolean!

  """The ID of the object"""
  id: ID!
  pk: Int
}

type ReservationUnitCancellationRuleTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ReservationUnitCancellationRuleTypeEdge]!
  totalCount: Int
}

"""
A Relay edge containing a `ReservationUnitCancellationRuleType` and its cursor.
"""
type ReservationUnitCancellationRuleTypeEdge {
  """The item at the end of the edge"""
  node: ReservationUnitCancellationRuleType

  """A cursor for use in pagination"""
  cursor: String!
}

input ReservationUnitCreateMutationInput {
  """
  Determines if introduction is required in order to reserve this reservation unit.
  """
  requireIntroduction: Boolean
  maxPersons: Int
  minPersons: Int
  equipmentPks: [Int]
  unitPk: Int

  """Contact information for this reservation unit."""
  contactInformation: String
  maxReservationDuration: Int
  minReservationDuration: Int
  isDraft: Boolean
  spacePks: [Int]
  resourcePks: [Int]
  purposePks: [Int]
  qualifierPks: [Int]
  servicePks: [Int]
  reservationUnitTypePk: Int
  surfaceArea: Decimal
  bufferTimeBefore: Int
  bufferTimeAfter: Int
  cancellationRulePk: Int
  paymentTermsPk: String
  cancellationTermsPk: String
  serviceSpecificTermsPk: String

  """
  Determines the interval for the start time of the reservation. For example an
  interval of 15 minutes means a reservation can begin at minutes 0, 15, 30, or
  45. Possible values are INTERVAL_15_MINS, INTERVAL_30_MINS, INTERVAL_60_MINS,
  INTERVAL_90_MINS.
  """
  reservationStartInterval: String

  """
  Time when making reservations become possible for this reservation unit.
  """
  reservationBegins: DateTime

  """
  Time when making reservations become not possible for this reservation unit
  """
  reservationEnds: DateTime

  """Time after this reservation unit should be publicly visible in UI."""
  publishBegins: DateTime

  """Time after this reservation unit should not be publicly visible in UI."""
  publishEnds: DateTime
  metadataSetPk: Int
  maxReservationsPerUser: Int

  """
  Does reservations of this reservation unit need to be handled before they're confirmed.
  """
  requireReservationHandling: Boolean

  """
  Authentication required for reserving this reservation unit. Possible values are WEAK, STRONG.
  """
  authentication: String

  """
  What kind of reservations are to be made to this is reservation unit. Possible
  values are: DIRECT, SEASON, DIRECT_AND_SEASON.
  """
  reservationKind: String

  """
  Can reservations to this reservation unit be able to apply free of charge.
  """
  canApplyFreeOfCharge: Boolean
  reservationsMaxDaysBefore: Int
  reservationsMinDaysBefore: Int

  """Allow reservations without opening hours. Used for testing."""
  allowReservationsWithoutOpeningHours: Boolean

  """Is reservation unit archived"""
  isArchived: Boolean
  pricingTermsPk: String
  pricingTerms: String
  paymentTypes: [String]
  pricings: [ReservationUnitPricingCreateSerializerInput]
  reservationPendingInstructionsFi: String
  reservationPendingInstructionsEn: String
  reservationPendingInstructionsSv: String
  reservationConfirmedInstructionsFi: String
  reservationConfirmedInstructionsEn: String
  reservationConfirmedInstructionsSv: String
  nameFi: String
  nameEn: String
  nameSv: String
  termsOfUseFi: String
  termsOfUseEn: String
  termsOfUseSv: String
  reservationCancelledInstructionsFi: String
  reservationCancelledInstructionsEn: String
  reservationCancelledInstructionsSv: String
  descriptionFi: String
  descriptionEn: String
  descriptionSv: String
  clientMutationId: String
}

type ReservationUnitCreateMutationPayload {
  pk: Int

  """Spaces included in the reservation unit as nested related objects."""
  spaces: [SpaceType]

  """Resources included in the reservation unit as nested related objects."""
  resources: [ResourceType]

  """Services included in the reservation unit as nested related objects."""
  services: [ServiceType]

  """
  Determines if introduction is required in order to reserve this reservation unit.
  """
  requireIntroduction: Boolean
  purposes: [PurposeType]

  """Images of the reservation unit as nested related objects. """
  images: [ReservationUnitImageType]

  """
  Location of this reservation unit. Dynamically determined from spaces of the reservation unit.
  """
  location: String
  maxPersons: Int
  minPersons: Int

  """Type of the reservation unit as nested related object."""
  reservationUnitType: ReservationUnitTypeType
  building: String
  unitPk: Int
  uuid: String

  """Contact information for this reservation unit."""
  contactInformation: String
  maxReservationDuration: Int
  minReservationDuration: Int
  isDraft: Boolean
  qualifierPks: [Int]
  reservationUnitTypePk: Int
  surfaceArea: Decimal
  bufferTimeBefore: Int
  bufferTimeAfter: Int
  cancellationRulePk: Int

  """
  Determines the interval for the start time of the reservation. For example an
  interval of 15 minutes means a reservation can begin at minutes 0, 15, 30, or
  45. Possible values are INTERVAL_15_MINS, INTERVAL_30_MINS, INTERVAL_60_MINS,
  INTERVAL_90_MINS.
  """
  reservationStartInterval: String

  """
  Time when making reservations become possible for this reservation unit.
  """
  reservationBegins: DateTime

  """
  Time when making reservations become not possible for this reservation unit
  """
  reservationEnds: DateTime

  """Time after this reservation unit should be publicly visible in UI."""
  publishBegins: DateTime

  """Time after this reservation unit should not be publicly visible in UI."""
  publishEnds: DateTime
  maxReservationsPerUser: Int

  """
  Does reservations of this reservation unit need to be handled before they're confirmed.
  """
  requireReservationHandling: Boolean

  """
  Authentication required for reserving this reservation unit. Possible values are WEAK, STRONG.
  """
  authentication: String

  """
  What kind of reservations are to be made to this is reservation unit. Possible
  values are: DIRECT, SEASON, DIRECT_AND_SEASON.
  """
  reservationKind: String

  """
  Can reservations to this reservation unit be able to apply free of charge.
  """
  canApplyFreeOfCharge: Boolean
  reservationsMaxDaysBefore: Int
  reservationsMinDaysBefore: Int

  """Allow reservations without opening hours. Used for testing."""
  allowReservationsWithoutOpeningHours: Boolean

  """Is reservation unit archived"""
  isArchived: Boolean
  state: String
  pricingTerms: String
  paymentTypes: [String]
  pricings: [ReservationUnitPricingType]
  reservationPendingInstructionsFi: String
  reservationPendingInstructionsEn: String
  reservationPendingInstructionsSv: String
  reservationConfirmedInstructionsFi: String
  reservationConfirmedInstructionsEn: String
  reservationConfirmedInstructionsSv: String
  nameFi: String
  nameEn: String
  nameSv: String
  termsOfUseFi: String
  termsOfUseEn: String
  termsOfUseSv: String
  reservationCancelledInstructionsFi: String
  reservationCancelledInstructionsEn: String
  reservationCancelledInstructionsSv: String
  descriptionFi: String
  descriptionEn: String
  descriptionSv: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  reservationUnit: ReservationUnitType
  clientMutationId: String
}

type ReservationUnitHaukiUrlType {
  url: String
}

input ReservationUnitImageCreateMutationInput {
  image: Upload
  reservationUnitPk: Int!

  """
  Type of image. Value is one of image_type enum values: MAIN, GROUND_PLAN, MAP, OTHER.
  """
  imageType: String!
  clientMutationId: String
}

type ReservationUnitImageCreateMutationPayload {
  pk: Int
  reservationUnitPk: Int

  """
  Type of image. Value is one of image_type enum values: MAIN, GROUND_PLAN, MAP, OTHER.
  """
  imageType: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  reservationUnitImage: ReservationUnitImageType
  clientMutationId: String
}

input ReservationUnitImageDeleteMutationInput {
  pk: Int!
  clientMutationId: String
}

type ReservationUnitImageDeleteMutationPayload {
  deleted: Boolean
  errors: String
  clientMutationId: String
}

type ReservationUnitImageType {
  imageType: ReservationUnitsReservationUnitImageImageTypeChoices!
  pk: Int
  imageUrl: String
  mediumUrl: String
  smallUrl: String
  largeUrl: String
}

input ReservationUnitImageUpdateMutationInput {
  pk: Int!

  """
  Type of image. Value is one of image_type enum values: MAIN, GROUND_PLAN, MAP, OTHER.
  """
  imageType: String
  clientMutationId: String
}

type ReservationUnitImageUpdateMutationPayload {
  pk: Int
  reservationUnitPk: Int

  """
  Type of image. Value is one of image_type enum values: MAIN, GROUND_PLAN, MAP, OTHER.
  """
  imageType: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  reservationUnitImage: ReservationUnitImageType
  clientMutationId: String
}

type ReservationUnitPaymentTypeType implements Node {
  """Available values: ONLINE, INVOICE, ON_SITE"""
  code: String

  """The ID of the object"""
  id: ID!
  pk: Int
}

input ReservationUnitPricingCreateSerializerInput {
  """When pricing is activated"""
  begins: Date!

  """
  What kind of pricing type this pricing has. Possible values are PAID, FREE.
  """
  pricingType: String!

  """
  Unit of the price. Possible values are PER_15_MINS, PER_30_MINS, PER_HOUR, PER_HALF_DAY, PER_DAY, PER_WEEK, FIXED.
  """
  priceUnit: String
  lowestPrice: Float
  lowestPriceNet: Float
  highestPrice: Float
  highestPriceNet: Float
  taxPercentagePk: Int

  """Pricing status. Possible values are PAST, ACTIVE, FUTURE."""
  status: String!
}

type ReservationUnitPricingType {
  """When pricing is activated"""
  begins: Date!

  """What kind of pricing types are available with this reservation unit."""
  pricingType: ReservationUnitsReservationUnitPricingPricingTypeChoices

  """Unit of the price"""
  priceUnit: ReservationUnitsReservationUnitPricingPriceUnitChoices!

  """Minimum price of the reservation unit including VAT"""
  lowestPrice: Decimal!

  """Minimum price of the reservation unit excluding VAT"""
  lowestPriceNet: Decimal!

  """Maximum price of the reservation unit including VAT"""
  highestPrice: Decimal!

  """Maximum price of the reservation unit excluding VAT"""
  highestPriceNet: Decimal!

  """The percentage of tax included in the price"""
  taxPercentage: TaxPercentageType!

  """Status of the pricing"""
  status: ReservationUnitsReservationUnitPricingStatusChoices!
  pk: Int
}

input ReservationUnitPricingUpdateSerializerInput {
  pk: Int

  """When pricing is activated"""
  begins: Date!

  """
  What kind of pricing type this pricing has. Possible values are PAID, FREE.
  """
  pricingType: String!

  """
  Unit of the price. Possible values are PER_15_MINS, PER_30_MINS, PER_HOUR, PER_HALF_DAY, PER_DAY, PER_WEEK, FIXED.
  """
  priceUnit: String
  lowestPrice: Float
  lowestPriceNet: Float
  highestPrice: Float
  highestPriceNet: Float
  taxPercentagePk: Int

  """Pricing status. Possible values are PAST, ACTIVE, FUTURE."""
  status: String!
}

"""An enumeration."""
enum ReservationUnitsReservationUnitAuthenticationChoices {
  """Weak"""
  WEAK

  """Strong"""
  STRONG
}

"""An enumeration."""
enum ReservationUnitsReservationUnitImageImageTypeChoices {
  """Main image"""
  MAIN

  """Ground plan"""
  GROUND_PLAN

  """Map"""
  MAP

  """Other"""
  OTHER
}

"""An enumeration."""
enum ReservationUnitsReservationUnitPricingPriceUnitChoices {
  """per 15 minutes"""
  PER_15_MINS

  """per 30 minutes"""
  PER_30_MINS

  """per hour"""
  PER_HOUR

  """per half a day"""
  PER_HALF_DAY

  """per day"""
  PER_DAY

  """per week"""
  PER_WEEK

  """fixed"""
  FIXED
}

"""An enumeration."""
enum ReservationUnitsReservationUnitPricingPricingTypeChoices {
  """Paid"""
  PAID

  """Free"""
  FREE
}

"""An enumeration."""
enum ReservationUnitsReservationUnitPricingStatusChoices {
  """past"""
  PAST

  """voimassa"""
  ACTIVE

  """future"""
  FUTURE
}

"""An enumeration."""
enum ReservationUnitsReservationUnitReservationKindChoices {
  """Direct"""
  DIRECT

  """Season"""
  SEASON

  """Direct And Season"""
  DIRECT_AND_SEASON
}

"""An enumeration."""
enum ReservationUnitsReservationUnitReservationStartIntervalChoices {
  """15 minutes"""
  INTERVAL_15_MINS

  """30 minutes"""
  INTERVAL_30_MINS

  """60 minutes"""
  INTERVAL_60_MINS

  """90 minutes"""
  INTERVAL_90_MINS
}

"""An enumeration."""
enum ReservationUnitState {
  DRAFT
  SCHEDULED_PUBLISHING
  SCHEDULED_RESERVATION
  PUBLISHED
  ARCHIVED
}

type ReservationUnitType implements Node {
  nameFi: String
  nameEn: String
  nameSv: String
  descriptionFi: String
  descriptionEn: String
  descriptionSv: String
  spaces: [SpaceType]
  resources: [ResourceType]
  services: [ServiceType]
  purposes: [PurposeType]
  qualifiers: [QualifierType]
  reservationUnitType: ReservationUnitTypeType
  requireIntroduction: Boolean!
  termsOfUseFi: String
  termsOfUseEn: String
  termsOfUseSv: String
  paymentTerms: TermsOfUseType
  cancellationTerms: TermsOfUseType
  serviceSpecificTerms: TermsOfUseType
  pricingTerms: TermsOfUseType
  reservationPendingInstructionsFi: String
  reservationPendingInstructionsEn: String
  reservationPendingInstructionsSv: String
  reservationConfirmedInstructionsFi: String
  reservationConfirmedInstructionsEn: String
  reservationConfirmedInstructionsSv: String
  reservationCancelledInstructionsFi: String
  reservationCancelledInstructionsEn: String
  reservationCancelledInstructionsSv: String
  contactInformation: String!
  maxReservationDuration: Duration
  minReservationDuration: Duration
  uuid: UUID!
  isDraft: Boolean!
  maxPersons: Int
  minPersons: Int
  surfaceArea: Decimal
  bufferTimeBefore: Duration
  bufferTimeAfter: Duration
  cancellationRule: ReservationUnitCancellationRuleType

  """
  Determines the interval for the start time of the reservation. For example an
  interval of 15 minutes means a reservation can begin at minutes 15, 30, 60, or
  90. Possible values are interval_15_mins, interval_30_mins, interval_60_mins,
  interval_90_mins.
  """
  reservationStartInterval: ReservationUnitsReservationUnitReservationStartIntervalChoices!
  reservationsMaxDaysBefore: Int
  reservationsMinDaysBefore: Int

  """
  Time when making reservations become possible for this reservation unit.
  """
  reservationBegins: DateTime

  """
  Time when making reservations become not possible for this reservation unit
  """
  reservationEnds: DateTime

  """Time after this reservation unit should be publicly visible in UI."""
  publishBegins: DateTime

  """Time after this reservation unit should not be publicly visible in UI."""
  publishEnds: DateTime
  metadataSet: ReservationMetadataSetType
  maxReservationsPerUser: Int

  """
  Does reservations of this reservation unit need to be handled before they're confirmed.
  """
  requireReservationHandling: Boolean!

  """Authentication required for reserving this reservation unit."""
  authentication: ReservationUnitsReservationUnitAuthenticationChoices!

  """Order number to be use in api sorting."""
  rank: Int

  """What kind of reservations are to be booked with this reservation unit."""
  reservationKind: ReservationUnitsReservationUnitReservationKindChoices!
  paymentTypes: [ReservationUnitPaymentTypeType]

  """
  Can reservations to this reservation unit be able to apply free of charge.
  """
  canApplyFreeOfCharge: Boolean!

  """
  Is it possible to reserve this reservation unit when opening hours are not defined.
  """
  allowReservationsWithoutOpeningHours: Boolean!

  """Is reservation unit archived."""
  isArchived: Boolean!
  paymentMerchant: PaymentMerchantType
  paymentProduct: PaymentProductType
  images: [ReservationUnitImageType]
  applicationRounds(active: Boolean): [ApplicationRoundType]

  """The ID of the object"""
  id: ID!
  reservations(from: Date, to: Date, state: [String], includeWithSameComponents: Boolean): [ReservationType]
  pk: Int
  location: LocationType
  equipment: [EquipmentType]
  unit: UnitType
  keywordGroups: [KeywordGroupType]
  state: ReservationUnitState
  pricings: [ReservationUnitPricingType]
}

type ReservationUnitTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ReservationUnitTypeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `ReservationUnitType` and its cursor."""
type ReservationUnitTypeEdge {
  """The item at the end of the edge"""
  node: ReservationUnitType

  """A cursor for use in pagination"""
  cursor: String!
}

type ReservationUnitTypeType implements Node {
  nameFi: String
  nameEn: String
  nameSv: String

  """Order number to be used in api sorting."""
  rank: Int

  """The ID of the object"""
  id: ID!
  pk: Int
}

type ReservationUnitTypeTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ReservationUnitTypeTypeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `ReservationUnitTypeType` and its cursor."""
type ReservationUnitTypeTypeEdge {
  """The item at the end of the edge"""
  node: ReservationUnitTypeType

  """A cursor for use in pagination"""
  cursor: String!
}

input ReservationUnitUpdateMutationInput {
  pk: Int!

  """
  Determines if introduction is required in order to reserve this reservation unit.
  """
  requireIntroduction: Boolean
  maxPersons: Int
  minPersons: Int
  equipmentPks: [Int]
  unitPk: Int

  """Contact information for this reservation unit."""
  contactInformation: String
  maxReservationDuration: Int
  minReservationDuration: Int
  isDraft: Boolean
  spacePks: [Int]
  resourcePks: [Int]
  purposePks: [Int]
  qualifierPks: [Int]
  servicePks: [Int]
  reservationUnitTypePk: Int
  surfaceArea: Decimal
  bufferTimeBefore: Int
  bufferTimeAfter: Int
  cancellationRulePk: Int
  paymentTermsPk: String
  cancellationTermsPk: String
  serviceSpecificTermsPk: String

  """
  Determines the interval for the start time of the reservation. For example an
  interval of 15 minutes means a reservation can begin at minutes 0, 15, 30, or
  45. Possible values are INTERVAL_15_MINS, INTERVAL_30_MINS, INTERVAL_60_MINS,
  INTERVAL_90_MINS.
  """
  reservationStartInterval: String

  """
  Time when making reservations become possible for this reservation unit.
  """
  reservationBegins: DateTime

  """
  Time when making reservations become not possible for this reservation unit
  """
  reservationEnds: DateTime

  """Time after this reservation unit should be publicly visible in UI."""
  publishBegins: DateTime

  """Time after this reservation unit should not be publicly visible in UI."""
  publishEnds: DateTime
  metadataSetPk: Int
  maxReservationsPerUser: Int

  """
  Does reservations of this reservation unit need to be handled before they're confirmed.
  """
  requireReservationHandling: Boolean

  """
  Authentication required for reserving this reservation unit. Possible values are WEAK, STRONG.
  """
  authentication: String

  """
  What kind of reservations are to be made to this is reservation unit. Possible
  values are: DIRECT, SEASON, DIRECT_AND_SEASON.
  """
  reservationKind: String

  """
  Can reservations to this reservation unit be able to apply free of charge.
  """
  canApplyFreeOfCharge: Boolean
  reservationsMaxDaysBefore: Int
  reservationsMinDaysBefore: Int

  """Allow reservations without opening hours. Used for testing."""
  allowReservationsWithoutOpeningHours: Boolean

  """Is reservation unit archived"""
  isArchived: Boolean
  pricingTermsPk: String
  pricingTerms: String
  paymentTypes: [String]
  pricings: [ReservationUnitPricingUpdateSerializerInput]!
  reservationPendingInstructionsFi: String
  reservationPendingInstructionsEn: String
  reservationPendingInstructionsSv: String
  reservationConfirmedInstructionsFi: String
  reservationConfirmedInstructionsEn: String
  reservationConfirmedInstructionsSv: String
  nameFi: String
  nameEn: String
  nameSv: String
  termsOfUseFi: String
  termsOfUseEn: String
  termsOfUseSv: String
  reservationCancelledInstructionsFi: String
  reservationCancelledInstructionsEn: String
  reservationCancelledInstructionsSv: String
  descriptionFi: String
  descriptionEn: String
  descriptionSv: String
  clientMutationId: String
}

type ReservationUnitUpdateMutationPayload {
  pk: Int

  """Spaces included in the reservation unit as nested related objects."""
  spaces: [SpaceType]

  """Resources included in the reservation unit as nested related objects."""
  resources: [ResourceType]

  """Services included in the reservation unit as nested related objects."""
  services: [ServiceType]

  """
  Determines if introduction is required in order to reserve this reservation unit.
  """
  requireIntroduction: Boolean
  purposes: [PurposeType]

  """Images of the reservation unit as nested related objects. """
  images: [ReservationUnitImageType]

  """
  Location of this reservation unit. Dynamically determined from spaces of the reservation unit.
  """
  location: String
  maxPersons: Int
  minPersons: Int

  """Type of the reservation unit as nested related object."""
  reservationUnitType: ReservationUnitTypeType
  building: String
  unitPk: Int
  uuid: String

  """Contact information for this reservation unit."""
  contactInformation: String
  maxReservationDuration: Int
  minReservationDuration: Int
  isDraft: Boolean
  qualifierPks: [Int]
  reservationUnitTypePk: Int
  surfaceArea: Decimal
  bufferTimeBefore: Int
  bufferTimeAfter: Int
  cancellationRulePk: Int

  """
  Determines the interval for the start time of the reservation. For example an
  interval of 15 minutes means a reservation can begin at minutes 0, 15, 30, or
  45. Possible values are INTERVAL_15_MINS, INTERVAL_30_MINS, INTERVAL_60_MINS,
  INTERVAL_90_MINS.
  """
  reservationStartInterval: String

  """
  Time when making reservations become possible for this reservation unit.
  """
  reservationBegins: DateTime

  """
  Time when making reservations become not possible for this reservation unit
  """
  reservationEnds: DateTime

  """Time after this reservation unit should be publicly visible in UI."""
  publishBegins: DateTime

  """Time after this reservation unit should not be publicly visible in UI."""
  publishEnds: DateTime
  maxReservationsPerUser: Int

  """
  Does reservations of this reservation unit need to be handled before they're confirmed.
  """
  requireReservationHandling: Boolean

  """
  Authentication required for reserving this reservation unit. Possible values are WEAK, STRONG.
  """
  authentication: String

  """
  What kind of reservations are to be made to this is reservation unit. Possible
  values are: DIRECT, SEASON, DIRECT_AND_SEASON.
  """
  reservationKind: String

  """
  Can reservations to this reservation unit be able to apply free of charge.
  """
  canApplyFreeOfCharge: Boolean
  reservationsMaxDaysBefore: Int
  reservationsMinDaysBefore: Int

  """Allow reservations without opening hours. Used for testing."""
  allowReservationsWithoutOpeningHours: Boolean

  """Is reservation unit archived"""
  isArchived: Boolean
  state: String
  pricingTerms: String
  paymentTypes: [String]
  reservationPendingInstructionsFi: String
  reservationPendingInstructionsEn: String
  reservationPendingInstructionsSv: String
  reservationConfirmedInstructionsFi: String
  reservationConfirmedInstructionsEn: String
  reservationConfirmedInstructionsSv: String
  nameFi: String
  nameEn: String
  nameSv: String
  termsOfUseFi: String
  termsOfUseEn: String
  termsOfUseSv: String
  reservationCancelledInstructionsFi: String
  reservationCancelledInstructionsEn: String
  reservationCancelledInstructionsSv: String
  descriptionFi: String
  descriptionEn: String
  descriptionSv: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  reservationUnit: ReservationUnitType
  clientMutationId: String
}

input ReservationUpdateMutationInput {
  pk: Int!
  reserveeFirstName: String
  reserveeLastName: String
  reserveePhone: String
  reserveeOrganisationName: String
  reserveeAddressStreet: String
  reserveeAddressCity: String
  reserveeAddressZip: String
  reserveeEmail: String

  """
  Type of the reservee. Possible values are BUSINESS, NONPROFIT, INDIVIDUAL.
  """
  reserveeType: String

  """Reservee's business or association identity code"""
  reserveeId: String
  reserveeIsUnregisteredAssociation: Boolean
  reserveeLanguage: String
  homeCityPk: Int
  applyingForFreeOfCharge: Boolean
  freeOfChargeReason: String
  ageGroupPk: Int
  billingFirstName: String
  billingLastName: String
  billingAddressStreet: String
  billingAddressCity: String
  billingAddressZip: String
  billingPhone: String
  billingEmail: String
  numPersons: Int
  name: String
  description: String

  """
  String value for ReservationType's ReservationState enum. Possible values are
  CREATED, CANCELLED, REQUIRES_HANDLING, WAITING_FOR_PAYMENT, CONFIRMED, DENIED.
  """
  state: String
  priority: Int
  begin: DateTime
  end: DateTime
  bufferTimeBefore: Int
  bufferTimeAfter: Int
  reservationUnitPks: [Int]
  purposePk: Int

  """
  Reservation type. Mutation requires special permissions. Possible values are NORMAL, BLOCKED, STAFF.
  """
  type: String
  clientMutationId: String
}

type ReservationUpdateMutationPayload {
  pk: Int
  reserveeFirstName: String
  reserveeLastName: String
  reserveePhone: String
  reserveeOrganisationName: String
  reserveeAddressStreet: String
  reserveeAddressCity: String
  reserveeAddressZip: String
  reserveeEmail: String

  """
  Type of the reservee. Possible values are BUSINESS, NONPROFIT, INDIVIDUAL.
  """
  reserveeType: String

  """Reservee's business or association identity code"""
  reserveeId: String
  reserveeIsUnregisteredAssociation: Boolean
  reserveeLanguage: String
  homeCityPk: Int
  applyingForFreeOfCharge: Boolean
  freeOfChargeReason: String
  ageGroupPk: Int
  billingFirstName: String
  billingLastName: String
  billingAddressStreet: String
  billingAddressCity: String
  billingAddressZip: String
  billingPhone: String
  billingEmail: String
  numPersons: Int
  name: String
  description: String

  """
  String value for ReservationType's ReservationState enum. Possible values are
  CREATED, CANCELLED, REQUIRES_HANDLING, WAITING_FOR_PAYMENT, CONFIRMED, DENIED.
  """
  state: String
  priority: Int
  begin: DateTime
  end: DateTime
  bufferTimeBefore: Int
  bufferTimeAfter: Int
  purposePk: Int
  confirmedAt: DateTime

  """The unit price of this particular reservation"""
  unitPrice: Decimal

  """The value of the tax percentage for this particular reservation"""
  taxPercentageValue: Decimal

  """The price of this particular reservation including VAT"""
  price: Decimal

  """The price of this particular reservation excluding VAT"""
  priceNet: Decimal

  """The non subsidised price of this reservation excluding VAT"""
  nonSubsidisedPrice: Decimal

  """The non subsidised price of this reservation excluding VAT"""
  nonSubsidisedPriceNet: Decimal

  """
  Reservation type. Mutation requires special permissions. Possible values are NORMAL, BLOCKED, STAFF.
  """
  type: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  reservation: ReservationType
  clientMutationId: String
}

input ReservationWorkingMemoMutationInput {
  """Primary key of the reservation"""
  pk: Int

  """Working memo for staff users."""
  workingMemo: String
  clientMutationId: String
}

type ReservationWorkingMemoMutationPayload {
  """Primary key of the reservation"""
  pk: Int

  """Working memo for staff users."""
  workingMemo: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  clientMutationId: String
}

input ResourceCreateMutationInput {
  locationType: String

  """PK of the related space for this resource."""
  spacePk: Int

  """
  Buffer time while reservation unit is unreservable before the reservation.
  Dynamically calculated from spaces and resources.
  """
  bufferTimeBefore: Int

  """
  Buffer time while reservation unit is unreservable after the reservation.
  Dynamically calculated from spaces and resources.
  """
  bufferTimeAfter: Int
  nameFi: String
  nameEn: String
  nameSv: String
  clientMutationId: String
}

type ResourceCreateMutationPayload {
  pk: Int
  locationType: String

  """PK of the related space for this resource."""
  spacePk: Int

  """
  Buffer time while reservation unit is unreservable before the reservation.
  Dynamically calculated from spaces and resources.
  """
  bufferTimeBefore: Int

  """
  Buffer time while reservation unit is unreservable after the reservation.
  Dynamically calculated from spaces and resources.
  """
  bufferTimeAfter: Int
  nameFi: String
  nameEn: String
  nameSv: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  resource: ResourceType
  clientMutationId: String
}

input ResourceDeleteMutationInput {
  pk: Int!
  clientMutationId: String
}

type ResourceDeleteMutationPayload {
  deleted: Boolean
  errors: String
  clientMutationId: String
}

"""An enumeration."""
enum ResourcesResourceLocationTypeChoices {
  """Fixed"""
  FIXED

  """Movable"""
  MOVABLE
}

type ResourceType implements Node {
  locationType: ResourcesResourceLocationTypeChoices!
  nameFi: String
  nameEn: String
  nameSv: String
  space: SpaceType
  bufferTimeBefore: Duration
  bufferTimeAfter: Duration

  """The ID of the object"""
  id: ID!
  pk: Int
  building: [BuildingType]
}

type ResourceTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ResourceTypeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `ResourceType` and its cursor."""
type ResourceTypeEdge {
  """The item at the end of the edge"""
  node: ResourceType

  """A cursor for use in pagination"""
  cursor: String!
}

input ResourceUpdateMutationInput {
  pk: Int!
  locationType: String

  """PK of the related space for this resource."""
  spacePk: Int

  """
  Buffer time while reservation unit is unreservable before the reservation.
  Dynamically calculated from spaces and resources.
  """
  bufferTimeBefore: Int

  """
  Buffer time while reservation unit is unreservable after the reservation.
  Dynamically calculated from spaces and resources.
  """
  bufferTimeAfter: Int
  nameFi: String
  nameEn: String
  nameSv: String
  clientMutationId: String
}

type ResourceUpdateMutationPayload {
  pk: Int
  locationType: String

  """PK of the related space for this resource."""
  spacePk: Int

  """
  Buffer time while reservation unit is unreservable before the reservation.
  Dynamically calculated from spaces and resources.
  """
  bufferTimeBefore: Int

  """
  Buffer time while reservation unit is unreservable after the reservation.
  Dynamically calculated from spaces and resources.
  """
  bufferTimeAfter: Int
  nameFi: String
  nameEn: String
  nameSv: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  resource: ResourceType
  clientMutationId: String
}

type RoleType {
  code: String
  verboseName: String
  verboseNameFi: String
  verboseNameSv: String
  verboseNameEn: String
}

type ServiceSectorRolePermissionType {
  permission: String
}

type ServiceSectorRoleType implements Node {
  role: RoleType
  serviceSector: ServiceSectorType

  """The ID of the object"""
  id: ID!
  pk: Int
  permissions: [ServiceSectorRolePermissionType]
}

type ServiceSectorType implements Node {
  """The ID of the object"""
  id: ID!
  nameFi: String
  nameEn: String
  nameSv: String
  pk: Int
}

type ServiceSectorTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ServiceSectorTypeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `ServiceSectorType` and its cursor."""
type ServiceSectorTypeEdge {
  """The item at the end of the edge"""
  node: ServiceSectorType

  """A cursor for use in pagination"""
  cursor: String!
}

"""An enumeration."""
enum ServicesServiceServiceTypeChoices {
  """Introduction"""
  INTRODUCTION

  """Catering"""
  CATERING

  """Configuration"""
  CONFIGURATION
}

type ServiceType implements Node {
  nameFi: String
  nameEn: String
  nameSv: String
  serviceType: ServicesServiceServiceTypeChoices!
  bufferTimeBefore: Duration
  bufferTimeAfter: Duration

  """The ID of the object"""
  id: ID!
  pk: Int
}

input SpaceCreateMutationInput {
  """PK of the parent space for this space."""
  parentPk: Int
  surfaceArea: Float

  """PK of the district for this space."""
  districtPk: Int
  maxPersons: Int
  code: String
  unitPk: Int
  nameFi: String!
  nameEn: String
  nameSv: String
  clientMutationId: String
}

type SpaceCreateMutationPayload {
  pk: Int

  """PK of the parent space for this space."""
  parentPk: Int
  surfaceArea: Float

  """PK of the district for this space."""
  districtPk: Int
  maxPersons: Int
  code: String
  unitPk: Int
  nameFi: String
  nameEn: String
  nameSv: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  space: SpaceType
  clientMutationId: String
}

input SpaceDeleteMutationInput {
  pk: Int!
  clientMutationId: String
}

type SpaceDeleteMutationPayload {
  deleted: Boolean
  errors: String
  clientMutationId: String
}

type SpaceType implements Node {
  nameFi: String
  nameEn: String
  nameSv: String
  parent: SpaceType
  building: BuildingType
  unit: UnitByPkType
  surfaceArea: Float
  maxPersons: Int
  code: String!

  """The ID of the object"""
  id: ID!
  pk: Int
  children: [SpaceType]
  resources: [ResourceType]
}

type SpaceTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [SpaceTypeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `SpaceType` and its cursor."""
type SpaceTypeEdge {
  """The item at the end of the edge"""
  node: SpaceType

  """A cursor for use in pagination"""
  cursor: String!
}

input SpaceUpdateMutationInput {
  pk: Int!

  """PK of the parent space for this space."""
  parentPk: Int
  surfaceArea: Float

  """PK of the district for this space."""
  districtPk: Int
  maxPersons: Int
  code: String
  unitPk: Int
  nameFi: String
  nameEn: String
  nameSv: String
  clientMutationId: String
}

type SpaceUpdateMutationPayload {
  pk: Int

  """PK of the parent space for this space."""
  parentPk: Int
  surfaceArea: Float

  """PK of the district for this space."""
  districtPk: Int
  maxPersons: Int
  code: String
  unitPk: Int
  nameFi: String
  nameEn: String
  nameSv: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  space: SpaceType
  clientMutationId: String
}

"""An enumeration."""
enum state {
  """created"""
  CREATED

  """cancelled"""
  CANCELLED

  """requires_handling"""
  REQUIRES_HANDLING

  """waiting_for_payment"""
  WAITING_FOR_PAYMENT

  """confirmed"""
  CONFIRMED

  """denied"""
  DENIED
}

type TaxPercentageType implements Node {
  """The tax percentage for a price"""
  value: Decimal!

  """The ID of the object"""
  id: ID!
  pk: Int
}

type TaxPercentageTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [TaxPercentageTypeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `TaxPercentageType` and its cursor."""
type TaxPercentageTypeEdge {
  """The item at the end of the edge"""
  node: TaxPercentageType

  """A cursor for use in pagination"""
  cursor: String!
}

"""An enumeration."""
enum TermsOfUseTermsOfUseTermsTypeChoices {
  """Generic terms"""
  GENERIC_TERMS

  """Payment terms"""
  PAYMENT_TERMS

  """Cancellation terms"""
  CANCELLATION_TERMS

  """Recurring reservation terms"""
  RECURRING_TERMS

  """Service-specific terms"""
  SERVICE_TERMS

  """Pricing terms"""
  PRICING_TERMS
}

type TermsOfUseType implements Node {
  nameFi: String
  nameEn: String
  nameSv: String
  textFi: String
  textEn: String
  textSv: String
  termsType: TermsOfUseTermsOfUseTermsTypeChoices!

  """The ID of the object"""
  id: ID!
  pk: String
}

type TermsOfUseTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [TermsOfUseTypeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `TermsOfUseType` and its cursor."""
type TermsOfUseTypeEdge {
  """The item at the end of the edge"""
  node: TermsOfUseType

  """A cursor for use in pagination"""
  cursor: String!
}

"""
The `Time` scalar type represents a Time value as
specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar Time

type TimeSpanType {
  startTime: Time
  endTime: Time
  weekdays: [Int]
  resourceState: String
  endTimeOnNextDay: Boolean
  nameFi: String
  nameEn: String
  nameSv: String
  descriptionFi: String
  descriptionEn: String
  descriptionSv: String
}

type UnitByPkType implements Node {
  tprekId: String
  nameFi: String
  nameEn: String
  nameSv: String
  descriptionFi: String
  descriptionEn: String
  descriptionSv: String
  shortDescriptionFi: String
  shortDescriptionEn: String
  shortDescriptionSv: String
  webPage: String!
  email: String!
  phone: String!

  """The ID of the object"""
  id: ID!
  openingHours(openingTimes: Boolean, periods: Boolean, startDate: Date, endDate: Date): OpeningHoursType
  pk: Int
  reservationUnits: [ReservationUnitType]
  spaces: [SpaceType]
  location: LocationType
  serviceSectors: [ServiceSectorType]
  paymentMerchant: PaymentMerchantType
}

type UnitGroupType implements Node {
  name: String!
  units: [UnitType]

  """The ID of the object"""
  id: ID!
  pk: Int
}

type UnitRolePermissionType {
  permission: String
}

type UnitRoleType implements Node {
  role: RoleType

  """The ID of the object"""
  id: ID!
  pk: Int
  units: [UnitType]
  unitGroups: [UnitGroupType]
  permissions: [UnitRolePermissionType]
}

type UnitType implements Node {
  tprekId: String
  nameFi: String
  nameEn: String
  nameSv: String
  descriptionFi: String
  descriptionEn: String
  descriptionSv: String
  shortDescriptionFi: String
  shortDescriptionEn: String
  shortDescriptionSv: String
  webPage: String!
  email: String!
  phone: String!
  paymentMerchant: PaymentMerchantType

  """The ID of the object"""
  id: ID!
  pk: Int
  reservationUnits: [ReservationUnitType]
  spaces: [SpaceType]
  location: LocationType
  serviceSectors: [ServiceSectorType]
}

type UnitTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [UnitTypeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `UnitType` and its cursor."""
type UnitTypeEdge {
  """The item at the end of the edge"""
  node: UnitType

  """A cursor for use in pagination"""
  cursor: String!
}

input UnitUpdateMutationInput {
  pk: Int!
  tprekId: String
  webPage: String
  email: String
  phone: String
  nameFi: String
  nameEn: String
  nameSv: String
  shortDescriptionFi: String
  shortDescriptionEn: String
  shortDescriptionSv: String
  descriptionFi: String
  descriptionEn: String
  descriptionSv: String
  clientMutationId: String
}

type UnitUpdateMutationPayload {
  pk: Int
  tprekId: String
  webPage: String
  email: String
  phone: String
  nameFi: String
  nameEn: String
  nameSv: String
  shortDescriptionFi: String
  shortDescriptionEn: String
  shortDescriptionSv: String
  descriptionFi: String
  descriptionEn: String
  descriptionSv: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  unit: UnitType
  clientMutationId: String
}

"""
Create scalar that ignores normal serialization/deserialization, since
that will be handled by the multipart request spec
"""
scalar Upload

type UserType implements Node {
  """
  Antaa käyttäjälle kaikki oikeudet ilman, että niitä täytyy erikseen luetella.
  """
  isSuperuser: Boolean!

  """
  Vaaditaan. Enintään 150 merkkiä. Vain kirjaimet, numerot ja @/./+/-/_ ovat sallittuja.
  """
  username: String!
  firstName: String!
  lastName: String!
  email: String!
  uuid: UUID!
  reservationNotification: String
  dateOfBirth: Date
  unitRoles: [UnitRoleType]
  serviceSectorRoles: [ServiceSectorRoleType]
  generalRoles: [GeneralRoleType]

  """The ID of the object"""
  id: ID!
  pk: Int
}

input UserUpdateMutationInput {
  pk: Int!

  """
  When reservation notification emails are sent. Possible values are: ALL, ONLY_HANDLING_REQUIRED, NONE.
  """
  reservationNotification: String
  clientMutationId: String
}

type UserUpdateMutationPayload {
  pk: Int

  """
  When reservation notification emails are sent. Possible values are: ALL, ONLY_HANDLING_REQUIRED, NONE.
  """
  reservationNotification: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  user: UserType
  clientMutationId: String
}

"""
Leverages the internal Python implementation of UUID (uuid.UUID) to provide native UUID objects
in fields, resolvers and input.
"""
scalar UUID

