"""Exposes a URL that specifies the behaviour of this scalar."""
directive @specifiedBy(
  """The URL that specifies the behaviour of this scalar."""
  url: String!
) on SCALAR

type AbilityGroupType {
  name: String!
  pk: Int
}

type AddressNode implements Node {
  streetAddress: String!
  streetAddressFi: String
  streetAddressEn: String
  streetAddressSv: String
  postCode: String!
  city: String!
  cityFi: String
  cityEn: String
  citySv: String

  """The ID of the object"""
  id: ID!
  pk: Int
}

input AddressSerializerInput {
  pk: Int
  streetAddress: String!
  streetAddressFi: String
  streetAddressEn: String
  streetAddressSv: String
  postCode: String!
  city: String!
  cityFi: String
  cityEn: String
  citySv: String
}

type AgeGroupType implements Node {
  minimum: Int!
  maximum: Int

  """The ID of the object"""
  id: ID!
  pk: Int
}

type AgeGroupTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [AgeGroupTypeEdge]!
}

"""A Relay edge containing a `AgeGroupType` and its cursor."""
type AgeGroupTypeEdge {
  """The item at the end of the edge"""
  node: AgeGroupType

  """A cursor for use in pagination"""
  cursor: String!
}

input AllocatedTimeSlotCreateMutationInput {
  pk: Int
  dayOfTheWeek: Weekday!
  beginTime: Time!
  endTime: Time!
  reservationUnitOption: Int!
  force: Boolean
  clientMutationId: String
}

type AllocatedTimeSlotCreateMutationPayload {
  pk: Int
  dayOfTheWeek: Weekday
  beginTime: Time
  endTime: Time
  reservationUnitOption: Int
  clientMutationId: String
}

input AllocatedTimeSlotDeleteMutationInput {
  pk: ID!
  clientMutationId: String
}

type AllocatedTimeSlotDeleteMutationPayload {
  deleted: Boolean
  clientMutationId: String
}

type AllocatedTimeSlotNode implements Node {
  dayOfTheWeek: Weekday!
  beginTime: Time!
  endTime: Time!
  reservationUnitOption: ReservationUnitOptionNode!

  """The ID of the object"""
  id: ID!
  pk: Int
}

type AllocatedTimeSlotNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [AllocatedTimeSlotNodeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `AllocatedTimeSlotNode` and its cursor."""
type AllocatedTimeSlotNodeEdge {
  """The item at the end of the edge"""
  node: AllocatedTimeSlotNode

  """A cursor for use in pagination"""
  cursor: String!
}

"""Ordering fields for the 'AllocatedTimeSlot' model."""
enum AllocatedTimeSlotOrderingChoices {
  pkAsc
  pkDesc
  applicationSectionPkAsc
  applicationSectionPkDesc
  applicationPkAsc
  applicationPkDesc
  applicationSectionNameAsc
  applicationSectionNameDesc
  allocatedUnitNameFiAsc
  allocatedUnitNameFiDesc
  allocatedUnitNameEnAsc
  allocatedUnitNameEnDesc
  allocatedUnitNameSvAsc
  allocatedUnitNameSvDesc
  allocatedReservationUnitNameFiAsc
  allocatedReservationUnitNameFiDesc
  allocatedReservationUnitNameEnAsc
  allocatedReservationUnitNameEnDesc
  allocatedReservationUnitNameSvAsc
  allocatedReservationUnitNameSvDesc
  allocatedTimeOfWeekAsc
  allocatedTimeOfWeekDesc
  applicantAsc
  applicantDesc
  dayOfTheWeekAsc
  dayOfTheWeekDesc
  applicationStatusAsc
  applicationStatusDesc
  applicationSectionStatusAsc
  applicationSectionStatusDesc
}

type ApplicantNode implements Node {
  email: String!
  dateOfBirth: Date

  """The ID of the object"""
  id: ID!
  name: String
  pk: Int
}

"""An enumeration."""
enum ApplicantTypeChoice {
  INDIVIDUAL
  ASSOCIATION
  COMMUNITY
  COMPANY
}

input ApplicationCancelMutationInput {
  pk: Int!
  clientMutationId: String
}

type ApplicationCancelMutationPayload {
  pk: Int
  clientMutationId: String
}

input ApplicationCreateMutationInput {
  pk: Int
  applicantType: ApplicantTypeChoice
  cancelledDate: DateTime
  sentDate: DateTime
  additionalInformation: String
  applicationRound: Int!
  organisation: OrganisationSerializerInput
  contactPerson: PersonSerializerInput
  billingAddress: AddressSerializerInput
  homeCity: Int
  applicationSections: [ApplicationSectionForApplicationSerializerInput]
  clientMutationId: String
}

type ApplicationCreateMutationPayload {
  pk: Int
  applicantType: ApplicantTypeChoice
  createdDate: DateTime
  lastModifiedDate: DateTime
  cancelledDate: DateTime
  sentDate: DateTime
  additionalInformation: String
  applicationRound: Int
  organisation: OrganisationNode
  contactPerson: PersonNode
  billingAddress: AddressNode
  homeCity: Int
  applicationSections: [ApplicationSectionNode]
  status: Status
  clientMutationId: String
}

type ApplicationNode implements Node {
  applicantType: ApplicantTypeChoice
  createdDate: DateTime!
  lastModifiedDate: DateTime!
  cancelledDate: DateTime
  sentDate: DateTime
  additionalInformation: String
  workingMemo: String!
  applicationRound: ApplicationRoundNode!
  organisation: OrganisationNode
  contactPerson: PersonNode
  user: ApplicantNode
  billingAddress: AddressNode
  homeCity: CityNode
  applicationSections(
    pk: [Int]
    name: String
    user: Int
    application: Int
    applicationRound: Int
    reservationUnit: [Int]
    unit: [Int]
    applicantType: [ApplicantTypeChoice]
    status: [ApplicationSectionStatusChoice]
    applicationStatus: [ApplicationStatusChoice]
    priority: [Priority]
    preferredOrder: [Int]
    includePreferredOrder10OrHigher: Boolean
    homeCity: [Int]
    ageGroup: [Int]
    purpose: [Int]
    textSearch: String

    """Järjestä"""
    orderBy: [ApplicationSectionOrderingChoices]
  ): [ApplicationSectionNode!]

  """The ID of the object"""
  id: ID!
  status: ApplicationStatusChoice
  pk: Int
}

type ApplicationNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ApplicationNodeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `ApplicationNode` and its cursor."""
type ApplicationNodeEdge {
  """The item at the end of the edge"""
  node: ApplicationNode

  """A cursor for use in pagination"""
  cursor: String!
}

"""Ordering fields for the 'Application' model."""
enum ApplicationOrderingChoices {
  pkAsc
  pkDesc
  applicantAsc
  applicantDesc
  applicantTypeAsc
  applicantTypeDesc
  preferredUnitNameFiAsc
  preferredUnitNameFiDesc
  preferredUnitNameEnAsc
  preferredUnitNameEnDesc
  preferredUnitNameSvAsc
  preferredUnitNameSvDesc
  statusAsc
  statusDesc
}

type ApplicationRoundNode implements Node {
  name: String!
  nameFi: String
  nameEn: String
  nameSv: String
  targetGroup: TargetGroup!
  criteria: String!
  criteriaFi: String
  criteriaEn: String
  criteriaSv: String
  applicationPeriodBegin: DateTime!
  applicationPeriodEnd: DateTime!
  reservationPeriodBegin: Date!
  reservationPeriodEnd: Date!
  publicDisplayBegin: DateTime!
  publicDisplayEnd: DateTime!
  handledDate: DateTime
  sentDate: DateTime
  reservationUnits: [ReservationUnitType!]
  purposes: [ReservationPurposeType!]
  serviceSector: ServiceSectorType

  """The ID of the object"""
  id: ID!
  status: ApplicationRoundStatusChoice
  statusTimestamp: DateTime
  applicationsCount: Int
  reservationUnitCount: Int
  pk: Int
}

type ApplicationRoundNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ApplicationRoundNodeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `ApplicationRoundNode` and its cursor."""
type ApplicationRoundNodeEdge {
  """The item at the end of the edge"""
  node: ApplicationRoundNode

  """A cursor for use in pagination"""
  cursor: String!
}

"""Ordering fields for the 'ApplicationRound' model."""
enum ApplicationRoundOrderingChoices {
  pkAsc
  pkDesc
}

"""An enumeration."""
enum ApplicationRoundStatusChoice {
  UPCOMING
  OPEN
  IN_ALLOCATION
  HANDLED
  RESULTS_SENT
}

type ApplicationRoundTimeSlotNode implements Node {
  weekday: Int!
  closed: Boolean!
  reservableTimes: [TimeSlotType]

  """The ID of the object"""
  id: ID!
  pk: Int
}

input ApplicationRoundTimeSlotSerializerInput {
  weekday: Int!
  closed: Boolean
  reservableTimes: [TimeSlotSerializerInput]
}

input ApplicationSectionCreateMutationInput {
  pk: Int
  name: String!
  numPersons: Int!
  reservationsBeginDate: Date!
  reservationsEndDate: Date!
  reservationMinDuration: Duration!
  reservationMaxDuration: Duration!
  appliedReservationsPerWeek: Int!
  application: Int!
  purpose: Int
  ageGroup: Int
  reservationUnitOptions: [ReservationUnitOptionApplicantSerializerInput]!
  suitableTimeRanges: [SuitableTimeRangeSerializerInput]!
  clientMutationId: String
}

type ApplicationSectionCreateMutationPayload {
  pk: Int
  name: String
  numPersons: Int
  reservationsBeginDate: Date
  reservationsEndDate: Date
  reservationMinDuration: Duration
  reservationMaxDuration: Duration
  appliedReservationsPerWeek: Int
  application: Int
  purpose: Int
  ageGroup: Int
  reservationUnitOptions: [ReservationUnitOptionNode]
  suitableTimeRanges: [SuitableTimeRangeNode]
  clientMutationId: String
}

input ApplicationSectionDeleteMutationInput {
  pk: ID!
  clientMutationId: String
}

type ApplicationSectionDeleteMutationPayload {
  deleted: Boolean
  clientMutationId: String
}

input ApplicationSectionForApplicationSerializerInput {
  pk: Int
  name: String!
  numPersons: Int!
  reservationsBeginDate: Date!
  reservationsEndDate: Date!
  reservationMinDuration: Duration!
  reservationMaxDuration: Duration!
  appliedReservationsPerWeek: Int!
  purpose: Int
  ageGroup: Int
  reservationUnitOptions: [ReservationUnitOptionApplicantSerializerInput]!
  suitableTimeRanges: [SuitableTimeRangeSerializerInput]!
}

type ApplicationSectionNode implements Node {
  name: String!
  numPersons: Int!
  reservationsBeginDate: Date!
  reservationsEndDate: Date!
  reservationMinDuration: Duration!
  reservationMaxDuration: Duration!
  appliedReservationsPerWeek: Int!
  application: ApplicationNode!
  purpose: ReservationPurposeType
  ageGroup: AgeGroupType
  reservationUnitOptions(
    pk: [Int]
    preferredOrder: Int
    reservationUnit: [Int]

    """Järjestä"""
    orderBy: [ReservationUnitOptionOrderingChoices]
  ): [ReservationUnitOptionNode!]
  suitableTimeRanges(
    pk: [Int]
    priority: [Priority]
    fulfilled: Boolean

    """Järjestä"""
    orderBy: [SuitableTimeRangeOrderingChoices]
  ): [SuitableTimeRangeNode!]

  """The ID of the object"""
  id: ID!
  status: ApplicationSectionStatusChoice
  allocations: Int
  pk: Int
}

type ApplicationSectionNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ApplicationSectionNodeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `ApplicationSectionNode` and its cursor."""
type ApplicationSectionNodeEdge {
  """The item at the end of the edge"""
  node: ApplicationSectionNode

  """A cursor for use in pagination"""
  cursor: String!
}

"""Ordering fields for the 'ApplicationSection' model."""
enum ApplicationSectionOrderingChoices {
  pkAsc
  pkDesc
  applicationPkAsc
  applicationPkDesc
  applicantAsc
  applicantDesc
  nameAsc
  nameDesc
  statusAsc
  statusDesc
  applicationStatusAsc
  applicationStatusDesc
  preferredUnitNameFiAsc
  preferredUnitNameFiDesc
  preferredUnitNameEnAsc
  preferredUnitNameEnDesc
  preferredUnitNameSvAsc
  preferredUnitNameSvDesc
}

"""An enumeration."""
enum ApplicationSectionStatusChoice {
  UNALLOCATED
  IN_ALLOCATION
  HANDLED
  RESERVED
  FAILED
}

input ApplicationSectionUpdateMutationInput {
  pk: Int!
  name: String
  numPersons: Int
  reservationsBeginDate: Date
  reservationsEndDate: Date
  reservationMinDuration: Duration
  reservationMaxDuration: Duration
  appliedReservationsPerWeek: Int
  application: Int
  purpose: Int
  ageGroup: Int
  reservationUnitOptions: [UpdateReservationUnitOptionApplicantSerializerInput]
  suitableTimeRanges: [UpdateSuitableTimeRangeSerializerInput]
  clientMutationId: String
}

type ApplicationSectionUpdateMutationPayload {
  pk: Int
  name: String
  numPersons: Int
  reservationsBeginDate: Date
  reservationsEndDate: Date
  reservationMinDuration: Duration
  reservationMaxDuration: Duration
  appliedReservationsPerWeek: Int
  application: Int
  purpose: Int
  ageGroup: Int
  reservationUnitOptions: [ReservationUnitOptionNode]
  suitableTimeRanges: [SuitableTimeRangeNode]
  clientMutationId: String
}

input ApplicationSendMutationInput {
  pk: Int!
  clientMutationId: String
}

type ApplicationSendMutationPayload {
  pk: Int
  clientMutationId: String
}

"""An enumeration."""
enum ApplicationStatusChoice {
  DRAFT
  RECEIVED
  IN_ALLOCATION
  HANDLED
  RESULTS_SENT
  EXPIRED
  CANCELLED
}

input ApplicationUpdateMutationInput {
  pk: Int!
  applicantType: ApplicantTypeChoice
  cancelledDate: DateTime
  sentDate: DateTime
  additionalInformation: String
  applicationRound: Int
  organisation: UpdateOrganisationSerializerInput
  contactPerson: UpdatePersonSerializerInput
  billingAddress: UpdateAddressSerializerInput
  homeCity: Int
  applicationSections: [UpdateApplicationSectionForApplicationSerializerInput]
  workingMemo: String
  clientMutationId: String
}

type ApplicationUpdateMutationPayload {
  pk: Int
  applicantType: ApplicantTypeChoice
  createdDate: DateTime
  lastModifiedDate: DateTime
  cancelledDate: DateTime
  sentDate: DateTime
  additionalInformation: String
  applicationRound: Int
  organisation: OrganisationNode
  contactPerson: PersonNode
  billingAddress: AddressNode
  homeCity: Int
  applicationSections: [ApplicationSectionNode]
  status: Status
  workingMemo: String
  clientMutationId: String
}

"""An enumeration."""
enum Authentication {
  """Heikko"""
  WEAK

  """Vahva"""
  STRONG
}

input BannerNotificationCreateMutationInput {
  pk: Int
  name: String!
  message: String
  messageFi: String
  messageEn: String
  messageSv: String
  draft: Boolean
  level: BannerNotificationLevel!
  target: BannerNotificationTarget!
  activeFrom: DateTime
  activeUntil: DateTime
  clientMutationId: String
}

type BannerNotificationCreateMutationPayload {
  pk: Int
  name: String
  message: String
  messageFi: String
  messageEn: String
  messageSv: String
  draft: Boolean
  level: BannerNotificationLevel
  target: BannerNotificationTarget
  activeFrom: DateTime
  activeUntil: DateTime
  clientMutationId: String
}

input BannerNotificationDeleteMutationInput {
  pk: ID!
  clientMutationId: String
}

type BannerNotificationDeleteMutationPayload {
  deleted: Boolean
  clientMutationId: String
}

"""An enumeration."""
enum BannerNotificationLevel {
  """Poikkeus"""
  EXCEPTION

  """Varoitus"""
  WARNING

  """Normaali"""
  NORMAL
}

type BannerNotificationNode implements Node {
  name: String!
  message: String!
  messageFi: String
  messageEn: String
  messageSv: String
  draft: Boolean!
  level: BannerNotificationLevel!
  target: BannerNotificationTarget!
  activeFrom: DateTime
  activeUntil: DateTime

  """The ID of the object"""
  id: ID!

  """May contain more than one error for same field."""
  errors: [ErrorType]
  state: BannerNotificationState
  pk: Int
}

type BannerNotificationNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [BannerNotificationNodeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `BannerNotificationNode` and its cursor."""
type BannerNotificationNodeEdge {
  """The item at the end of the edge"""
  node: BannerNotificationNode

  """A cursor for use in pagination"""
  cursor: String!
}

"""An enumeration."""
enum BannerNotificationState {
  DRAFT
  SCHEDULED
  ACTIVE
}

"""An enumeration."""
enum BannerNotificationTarget {
  """Kaikki"""
  ALL

  """Henkilökunta"""
  STAFF

  """Käyttäjä"""
  USER
}

input BannerNotificationUpdateMutationInput {
  pk: Int!
  name: String
  message: String
  messageFi: String
  messageEn: String
  messageSv: String
  draft: Boolean
  level: BannerNotificationLevel
  target: BannerNotificationTarget
  activeFrom: DateTime
  activeUntil: DateTime
  clientMutationId: String
}

type BannerNotificationUpdateMutationPayload {
  pk: Int
  name: String
  message: String
  messageFi: String
  messageEn: String
  messageSv: String
  draft: Boolean
  level: BannerNotificationLevel
  target: BannerNotificationTarget
  activeFrom: DateTime
  activeUntil: DateTime
  clientMutationId: String
}

type BuildingType implements Node {
  nameFi: String
  nameEn: String
  nameSv: String
  surfaceArea: Decimal
  realEstate: RealEstateType

  """The ID of the object"""
  id: ID!
  pk: Int
}

type CityNode implements Node {
  name: String!
  nameFi: String
  nameEn: String
  nameSv: String
  municipalityCode: String!

  """The ID of the object"""
  id: ID!
  pk: Int
}

type CityNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [CityNodeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `CityNode` and its cursor."""
type CityNodeEdge {
  """The item at the end of the edge"""
  node: CityNode

  """A cursor for use in pagination"""
  cursor: String!
}

"""
The `Date` scalar type represents a Date
value as specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar Date

"""
The `DateTime` scalar type represents a DateTime
value as specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar DateTime

"""The `Decimal` scalar type represents a python Decimal."""
scalar Decimal

"""Debugging information for the current query."""
type DjangoDebug {
  """Executed SQL queries for this API query."""
  sql: [DjangoDebugSQL]

  """Raise exceptions for this API query."""
  exceptions: [DjangoDebugException]
}

"""Represents a single exception raised."""
type DjangoDebugException {
  """The class of the exception"""
  excType: String!

  """The message of the exception"""
  message: String!

  """The stack trace"""
  stack: String!
}

"""Represents a single database query made to a Django managed DB."""
type DjangoDebugSQL {
  """The type of database being used (e.g. postrgesql, mysql, sqlite)."""
  vendor: String!

  """The Django database alias (e.g. 'default')."""
  alias: String!

  """The actual SQL sent to this database."""
  sql: String

  """Duration of this database query in seconds."""
  duration: Float!

  """The raw SQL of this query, without params."""
  rawSql: String!

  """JSON encoded database query parameters."""
  params: String!

  """Start time of this database query."""
  startTime: Float!

  """Stop time of this database query."""
  stopTime: Float!

  """Whether this database query took more than 10 seconds."""
  isSlow: Boolean!

  """Whether this database query was a SELECT."""
  isSelect: Boolean!

  """Postgres transaction ID if available."""
  transId: String

  """Postgres transaction status if available."""
  transStatus: String

  """Postgres isolation level if available."""
  isoLevel: String

  """Postgres connection encoding if available."""
  encoding: String
}

"""
The `Duration` scalar type represents a duration value as an integer in seconds.
For example, a value of 900 means a duration of 15 minutes.
"""
scalar Duration

input EquipmentCategoryCreateMutationInput {
  nameFi: String
  nameEn: String
  nameSv: String
  clientMutationId: String
}

type EquipmentCategoryCreateMutationPayload {
  pk: Int
  nameFi: String
  nameEn: String
  nameSv: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  equipmentCategory: EquipmentCategoryType
  clientMutationId: String
}

input EquipmentCategoryDeleteMutationInput {
  pk: Int!
  clientMutationId: String
}

type EquipmentCategoryDeleteMutationPayload {
  deleted: Boolean
  errors: String
  clientMutationId: String
}

type EquipmentCategoryType implements Node {
  nameFi: String
  nameEn: String
  nameSv: String

  """The ID of the object"""
  id: ID!
  pk: Int
}

type EquipmentCategoryTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [EquipmentCategoryTypeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `EquipmentCategoryType` and its cursor."""
type EquipmentCategoryTypeEdge {
  """The item at the end of the edge"""
  node: EquipmentCategoryType

  """A cursor for use in pagination"""
  cursor: String!
}

input EquipmentCategoryUpdateMutationInput {
  pk: Int!
  nameFi: String
  nameEn: String
  nameSv: String
  clientMutationId: String
}

type EquipmentCategoryUpdateMutationPayload {
  pk: Int
  nameFi: String
  nameEn: String
  nameSv: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  equipmentCategory: EquipmentCategoryType
  clientMutationId: String
}

input EquipmentCreateMutationInput {
  categoryPk: Int!
  nameFi: String
  nameEn: String
  nameSv: String
  clientMutationId: String
}

type EquipmentCreateMutationPayload {
  pk: Int
  categoryPk: Int
  nameFi: String
  nameEn: String
  nameSv: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  equipment: EquipmentType
  clientMutationId: String
}

input EquipmentDeleteMutationInput {
  pk: Int!
  clientMutationId: String
}

type EquipmentDeleteMutationPayload {
  deleted: Boolean
  errors: String
  clientMutationId: String
}

type EquipmentType implements Node {
  nameFi: String
  nameEn: String
  nameSv: String

  """The ID of the object"""
  id: ID!
  pk: Int
  category: EquipmentCategoryType
}

type EquipmentTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [EquipmentTypeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `EquipmentType` and its cursor."""
type EquipmentTypeEdge {
  """The item at the end of the edge"""
  node: EquipmentType

  """A cursor for use in pagination"""
  cursor: String!
}

input EquipmentUpdateMutationInput {
  pk: Int!
  categoryPk: Int!
  nameFi: String
  nameEn: String
  nameSv: String
  clientMutationId: String
}

type EquipmentUpdateMutationPayload {
  pk: Int
  categoryPk: Int
  nameFi: String
  nameEn: String
  nameSv: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  equipment: EquipmentType
  clientMutationId: String
}

type ErrorType {
  field: String!
  messages: [String!]!
}

type GeneralRolePermissionType {
  permission: String
}

type GeneralRoleType implements Node {
  role: RoleType

  """The ID of the object"""
  id: ID!
  pk: Int
  permissions: [GeneralRolePermissionType]
}

"""An enumeration."""
enum ImageType {
  """Pääkuva"""
  MAIN

  """Pohjapiirros"""
  GROUND_PLAN

  """Kartta"""
  MAP

  """Muu"""
  OTHER
}

type KeywordCategoryType implements Node {
  nameFi: String
  nameEn: String
  nameSv: String

  """The ID of the object"""
  id: ID!
  pk: Int
  keywordGroups: [KeywordGroupType]
}

type KeywordCategoryTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [KeywordCategoryTypeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `KeywordCategoryType` and its cursor."""
type KeywordCategoryTypeEdge {
  """The item at the end of the edge"""
  node: KeywordCategoryType

  """A cursor for use in pagination"""
  cursor: String!
}

type KeywordGroupType implements Node {
  nameFi: String
  nameEn: String
  nameSv: String

  """The ID of the object"""
  id: ID!
  pk: Int
  keywords: [KeywordType]
}

type KeywordGroupTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [KeywordGroupTypeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `KeywordGroupType` and its cursor."""
type KeywordGroupTypeEdge {
  """The item at the end of the edge"""
  node: KeywordGroupType

  """A cursor for use in pagination"""
  cursor: String!
}

type KeywordType implements Node {
  nameFi: String
  nameEn: String
  nameSv: String

  """The ID of the object"""
  id: ID!
  pk: Int
}

type KeywordTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [KeywordTypeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `KeywordType` and its cursor."""
type KeywordTypeEdge {
  """The item at the end of the edge"""
  node: KeywordType

  """A cursor for use in pagination"""
  cursor: String!
}

type LocationType implements Node {
  addressStreetFi: String
  addressStreetEn: String
  addressStreetSv: String
  addressZip: String!
  addressCityFi: String
  addressCityEn: String
  addressCitySv: String

  """The ID of the object"""
  id: ID!
  pk: Int
  longitude: String
  latitude: String
}

type Mutation {
  createApplication(input: ApplicationCreateMutationInput!): ApplicationCreateMutationPayload
  updateApplication(input: ApplicationUpdateMutationInput!): ApplicationUpdateMutationPayload
  sendApplication(input: ApplicationSendMutationInput!): ApplicationSendMutationPayload
  cancelApplication(input: ApplicationCancelMutationInput!): ApplicationCancelMutationPayload
  createApplicationSection(input: ApplicationSectionCreateMutationInput!): ApplicationSectionCreateMutationPayload
  updateApplicationSection(input: ApplicationSectionUpdateMutationInput!): ApplicationSectionUpdateMutationPayload
  deleteApplicationSection(input: ApplicationSectionDeleteMutationInput!): ApplicationSectionDeleteMutationPayload
  createAllocatedTimeslot(input: AllocatedTimeSlotCreateMutationInput!): AllocatedTimeSlotCreateMutationPayload
  deleteAllocatedTimeslot(input: AllocatedTimeSlotDeleteMutationInput!): AllocatedTimeSlotDeleteMutationPayload
  updateReservationUnitOption(input: ReservationUnitOptionUpdateMutationInput!): ReservationUnitOptionUpdateMutationPayload
  createRecurringReservation(input: RecurringReservationCreateMutationInput!): RecurringReservationCreateMutationPayload
  updateRecurringReservation(input: RecurringReservationUpdateMutationInput!): RecurringReservationUpdateMutationPayload
  createReservation(input: ReservationCreateMutationInput!): ReservationCreateMutationPayload
  createStaffReservation(input: ReservationStaffCreateMutationInput!): ReservationStaffCreateMutationPayload
  updateReservation(input: ReservationUpdateMutationInput!): ReservationUpdateMutationPayload
  confirmReservation(input: ReservationConfirmMutationInput!): ReservationConfirmMutationPayload
  cancelReservation(input: ReservationCancellationMutationInput!): ReservationCancellationMutationPayload
  denyReservation(input: ReservationDenyMutationInput!): ReservationDenyMutationPayload
  deleteReservation(input: ReservationDeleteMutationInput!): ReservationDeleteMutationPayload
  approveReservation(input: ReservationApproveMutationInput!): ReservationApproveMutationPayload
  refundReservation(input: ReservationRefundMutationInput!): ReservationRefundMutationPayload
  requireHandlingForReservation(input: ReservationRequiresHandlingMutationInput!): ReservationRequiresHandlingMutationPayload
  updateReservationWorkingMemo(input: ReservationWorkingMemoMutationInput!): ReservationWorkingMemoMutationPayload
  adjustReservationTime(input: ReservationAdjustTimeMutationInput!): ReservationAdjustTimeMutationPayload
  staffAdjustReservationTime(input: ReservationStaffAdjustTimeMutationInput!): ReservationStaffAdjustTimeMutationPayload
  staffReservationModify(input: ReservationStaffModifyMutationInput!): ReservationStaffModifyMutationPayload
  createReservationUnit(input: ReservationUnitCreateMutationInput!): ReservationUnitCreateMutationPayload
  updateReservationUnit(input: ReservationUnitUpdateMutationInput!): ReservationUnitUpdateMutationPayload
  createReservationUnitImage(input: ReservationUnitImageCreateMutationInput!): ReservationUnitImageCreateMutationPayload
  updateReservationUnitImage(input: ReservationUnitImageUpdateMutationInput!): ReservationUnitImageUpdateMutationPayload
  deleteReservationUnitImage(input: ReservationUnitImageDeleteMutationInput!): ReservationUnitImageDeleteMutationPayload
  createPurpose(input: PurposeCreateMutationInput!): PurposeCreateMutationPayload
  updatePurpose(input: PurposeUpdateMutationInput!): PurposeUpdateMutationPayload
  createEquipment(input: EquipmentCreateMutationInput!): EquipmentCreateMutationPayload
  updateEquipment(input: EquipmentUpdateMutationInput!): EquipmentUpdateMutationPayload
  deleteEquipment(input: EquipmentDeleteMutationInput!): EquipmentDeleteMutationPayload
  createEquipmentCategory(input: EquipmentCategoryCreateMutationInput!): EquipmentCategoryCreateMutationPayload
  updateEquipmentCategory(input: EquipmentCategoryUpdateMutationInput!): EquipmentCategoryUpdateMutationPayload
  deleteEquipmentCategory(input: EquipmentCategoryDeleteMutationInput!): EquipmentCategoryDeleteMutationPayload
  createSpace(input: SpaceCreateMutationInput!): SpaceCreateMutationPayload
  updateSpace(input: SpaceUpdateMutationInput!): SpaceUpdateMutationPayload
  deleteSpace(input: SpaceDeleteMutationInput!): SpaceDeleteMutationPayload
  createResource(input: ResourceCreateMutationInput!): ResourceCreateMutationPayload
  updateResource(input: ResourceUpdateMutationInput!): ResourceUpdateMutationPayload
  deleteResource(input: ResourceDeleteMutationInput!): ResourceDeleteMutationPayload
  updateUnit(input: UnitUpdateMutationInput!): UnitUpdateMutationPayload
  updateUser(input: UserUpdateMutationInput!): UserUpdateMutationPayload
  refreshOrder(input: RefreshOrderMutationInput!): RefreshOrderMutationPayload
  createBannerNotification(input: BannerNotificationCreateMutationInput!): BannerNotificationCreateMutationPayload
  updateBannerNotification(input: BannerNotificationUpdateMutationInput!): BannerNotificationUpdateMutationPayload
  deleteBannerNotification(input: BannerNotificationDeleteMutationInput!): BannerNotificationDeleteMutationPayload
}

"""An object with an ID"""
interface Node {
  """The ID of the object"""
  id: ID!
}

type OrganisationNode implements Node {
  name: String!
  nameFi: String
  nameEn: String
  nameSv: String
  email: String!
  identifier: String
  yearEstablished: Int
  activeMembers: Int
  coreBusiness: String!
  coreBusinessFi: String
  coreBusinessEn: String
  coreBusinessSv: String
  organisationType: OrganizationTypeChoice!
  address: AddressNode

  """The ID of the object"""
  id: ID!
  pk: Int
}

input OrganisationSerializerInput {
  pk: Int
  name: String!
  nameFi: String
  nameEn: String
  nameSv: String
  identifier: String
  yearEstablished: Int
  address: AddressSerializerInput!
  activeMembers: Int
  coreBusiness: String
  coreBusinessFi: String
  coreBusinessEn: String
  coreBusinessSv: String
  organisationType: OrganizationTypeChoice
  email: String
}

"""An enumeration."""
enum OrganizationTypeChoice {
  """Yritys"""
  COMPANY

  """Rekisteröity yhdistys"""
  REGISTERED_ASSOCIATION

  """Julkinen yhdistys"""
  PUBLIC_ASSOCIATION

  """Rekisteröimätön yhdistys"""
  UNREGISTERED_ASSOCIATION

  """Kuntakonsortio"""
  MUNICIPALITY_CONSORTIUM

  """Uskonnollinen yhteisö"""
  RELIGIOUS_COMMUNITY
}

"""
The Relay compliant `PageInfo` type, containing data necessary to paginate this connection.
"""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String

  """When paginating forwards, the cursor to continue."""
  endCursor: String
}

type PaymentMerchantType implements Node {
  name: String!

  """The ID of the object"""
  id: ID!
  pk: String
}

type PaymentOrderType implements Node {
  paymentType: String
  status: String
  processedAt: DateTime
  checkoutUrl: String
  receiptUrl: String

  """The ID of the object"""
  id: ID!
  pk: Int
  orderUuid: String
  reservationPk: String
  refundUuid: String
  expiresInMinutes: Int
}

type PaymentProductType implements Node {
  """The ID of the object"""
  id: ID!
  pk: String
  merchantPk: String
}

type PersonNode implements Node {
  firstName: String!
  lastName: String!
  email: String
  phoneNumber: String

  """The ID of the object"""
  id: ID!
  pk: Int
}

input PersonSerializerInput {
  pk: Int
  firstName: String!
  lastName: String!
  email: String
  phoneNumber: String
}

"""An enumeration."""
enum PriceUnit {
  """per 15 minuuttia"""
  PER_15_MINS

  """per 30 minuuttia"""
  PER_30_MINS

  """per tunti"""
  PER_HOUR

  """per puolipäivää"""
  PER_HALF_DAY

  """per päivä"""
  PER_DAY

  """per viikko"""
  PER_WEEK

  """kiinteä"""
  FIXED
}

"""An enumeration."""
enum PricingType {
  """Paid"""
  PAID

  """Free"""
  FREE
}

"""An enumeration."""
enum Priority {
  PRIMARY
  SECONDARY
}

input PurposeCreateMutationInput {
  nameFi: String
  nameEn: String
  nameSv: String
  clientMutationId: String
}

type PurposeCreateMutationPayload {
  nameFi: String
  nameEn: String
  nameSv: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  purpose: PurposeType
  clientMutationId: String
}

type PurposeType implements Node {
  nameFi: String
  nameEn: String
  nameSv: String

  """Järjestysnumero, jota käytetään rajapinnan järjestämisessä."""
  rank: Int

  """The ID of the object"""
  id: ID!
  pk: Int
  imageUrl: String
  smallUrl: String
}

type PurposeTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [PurposeTypeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `PurposeType` and its cursor."""
type PurposeTypeEdge {
  """The item at the end of the edge"""
  node: PurposeType

  """A cursor for use in pagination"""
  cursor: String!
}

input PurposeUpdateMutationInput {
  pk: Int!
  nameFi: String
  nameEn: String
  nameSv: String
  clientMutationId: String
}

type PurposeUpdateMutationPayload {
  pk: Int
  nameFi: String
  nameEn: String
  nameSv: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  purpose: PurposeType
  clientMutationId: String
}

type QualifierType implements Node {
  nameFi: String
  nameEn: String
  nameSv: String

  """The ID of the object"""
  id: ID!
  pk: Int
}

type QualifierTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [QualifierTypeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `QualifierType` and its cursor."""
type QualifierTypeEdge {
  """The item at the end of the edge"""
  node: QualifierType

  """A cursor for use in pagination"""
  cursor: String!
}

type Query {
  applicationRounds(
    first: Int
    last: Int
    offset: Int
    after: String
    before: String
    pk: [Int]
    name: String

    """Järjestä"""
    orderBy: [ApplicationRoundOrderingChoices]
  ): ApplicationRoundNodeConnection
  applicationRound(
    """The ID of the object"""
    id: ID!
  ): ApplicationRoundNode
  applications(
    first: Int
    last: Int
    offset: Int
    after: String
    before: String
    pk: [Int]
    applicationRound: Int
    user: Int
    applicantType: [ApplicantTypeChoice]
    status: [ApplicationStatusChoice]
    unit: [Int]
    textSearch: String

    """Järjestä"""
    orderBy: [ApplicationOrderingChoices]
  ): ApplicationNodeConnection
  application(
    """The ID of the object"""
    id: ID!
  ): ApplicationNode
  applicationSections(
    first: Int
    last: Int
    offset: Int
    after: String
    before: String
    pk: [Int]
    name: String
    user: Int
    application: Int
    applicationRound: Int
    reservationUnit: [Int]
    unit: [Int]
    applicantType: [ApplicantTypeChoice]
    status: [ApplicationSectionStatusChoice]
    applicationStatus: [ApplicationStatusChoice]
    priority: [Priority]
    preferredOrder: [Int]
    includePreferredOrder10OrHigher: Boolean
    homeCity: [Int]
    ageGroup: [Int]
    purpose: [Int]
    textSearch: String

    """Järjestä"""
    orderBy: [ApplicationSectionOrderingChoices]
  ): ApplicationSectionNodeConnection
  allocatedTimeSlots(
    first: Int
    last: Int
    offset: Int
    after: String
    before: String
    pk: [Int]
    dayOfTheWeek: [Weekday]
    applicationRound: Int
    applicationSectionStatus: [ApplicationSectionStatusChoice]
    applicantType: [ApplicantTypeChoice]
    allocatedUnit: [Int]
    allocatedReservationUnit: [Int]
    textSearch: String

    """Järjestä"""
    orderBy: [AllocatedTimeSlotOrderingChoices]
  ): AllocatedTimeSlotNodeConnection

  """
  Return all allocations that affect allocations for given reservation unit
  (through space hierarchy or common resource) during the given time period.
  """
  affectingAllocatedTimeSlots(reservationUnit: Int!, beginDate: Date!, endDate: Date!): [AllocatedTimeSlotNode!]
  reservations(
    offset: Int
    before: String
    after: String
    first: Int
    last: Int
    beginDate: Date
    endDate: Date
    onlyWithPermission: Boolean
    onlyWithHandlingPermission: Boolean

    """
    PaymentOrder's statuses; DRAFT, EXPIRED, CANCELLED, PAID, PAID_MANUALLY, REFUNDED
    """
    orderStatus: [String]
    priceGte: Decimal
    priceLte: Decimal
    recurringReservation: ID
    requested: Boolean
    reservationUnit: [ID]
    reservationType: [String]
    reservationUnitNameFi: String
    reservationUnitNameEn: String
    reservationUnitNameSv: String
    reservationUnitType: [ID]
    state: [String]
    unit: [ID]
    user: ID
    textSearch: String

    """Järjestä"""
    orderBy: String
  ): ReservationTypeConnection
  reservationByPk(pk: Int): ReservationType
  recurringReservations(
    offset: Int
    before: String
    after: String
    first: Int
    last: Int
    begin: DateTime
    end: DateTime
    beginDate: Date
    endDate: Date
    beginTime: TimeString
    endTime: TimeString
    user: ID
    reservationUnitNameFi: String
    reservationUnitNameEn: String
    reservationUnitNameSv: String
    unit: [ID]
    reservationUnit: [ID]
    reservationUnitType: [ID]

    """Järjestä"""
    orderBy: String
  ): RecurringReservationTypeConnection
  reservationCancelReasons(offset: Int, before: String, after: String, first: Int, last: Int, reason: String): ReservationCancelReasonTypeConnection
  reservationDenyReasons(offset: Int, before: String, after: String, first: Int, last: Int, reason: String): ReservationDenyReasonTypeConnection
  reservationUnits(
    offset: Int
    before: String
    after: String
    first: Int
    last: Int
    pk: [Int]
    unit: [Int]
    reservationUnitType: [Int]
    minPersonsGte: Decimal
    minPersonsLte: Decimal
    maxPersonsGte: Decimal
    maxPersonsLte: Decimal
    textSearch: String
    keywordGroups: [Int]
    purposes: [Int]
    qualifiers: [Int]
    equipments: [Int]
    isDraft: Boolean
    isVisible: Boolean
    applicationRound: [Int]
    nameFi: String
    nameEn: String
    nameSv: String
    surfaceAreaGte: Decimal
    surfaceAreaLte: Decimal
    rankGte: Decimal
    rankLte: Decimal
    typeRankGte: Decimal
    typeRankLte: Decimal
    reservationKind: String
    state: [String]
    reservationState: [String]
    onlyWithPermission: Boolean
    reservableDateStart: Date
    reservableDateEnd: Date
    reservableTimeStart: TimeString
    reservableTimeEnd: TimeString
    reservableMinimumDurationMinutes: Decimal
    showOnlyReservable: Boolean

    """Järjestä"""
    orderBy: String
  ): ReservationUnitTypeConnection
  reservationUnit(
    """The ID of the object"""
    id: ID!
  ): ReservationUnitType
  reservationUnitByPk(pk: Int): ReservationUnitByPkType
  reservationUnitCancellationRules(offset: Int, before: String, after: String, first: Int, last: Int, name: String): ReservationUnitCancellationRuleTypeConnection
  reservationUnitHaukiUrl(pk: Int, reservationUnits: [Int]): ReservationUnitHaukiUrlType
  reservationUnitTypes(
    offset: Int
    before: String
    after: String
    first: Int
    last: Int

    """Järjestä"""
    orderBy: String
  ): ReservationUnitTypeTypeConnection
  resources(offset: Int, before: String, after: String, first: Int, last: Int, onlyWithPermission: Boolean): ResourceTypeConnection
  resource(
    """The ID of the object"""
    id: ID!
  ): ResourceType
  resourceByPk(pk: Int): ResourceType
  equipments(
    offset: Int
    before: String
    after: String
    first: Int
    last: Int
    name: String
    rankGte: Decimal
    rankLte: Decimal

    """Järjestä"""
    orderBy: String
  ): EquipmentTypeConnection
  equipment(
    """The ID of the object"""
    id: ID!
  ): EquipmentType
  equipmentByPk(pk: Int): EquipmentType
  equipmentCategories(offset: Int, before: String, after: String, first: Int, last: Int, nameFi: String, nameFi_Icontains: String, nameFi_Istartswith: String, nameSv: String, nameSv_Icontains: String, nameSv_Istartswith: String, nameEn: String, nameEn_Icontains: String, nameEn_Istartswith: String): EquipmentCategoryTypeConnection
  equipmentCategory(
    """The ID of the object"""
    id: ID!
  ): EquipmentCategoryType
  equipmentCategoryByPk(pk: Int): EquipmentCategoryType
  spaces(
    offset: Int
    before: String
    after: String
    first: Int
    last: Int
    onlyWithPermission: Boolean

    """Järjestä"""
    orderBy: String
  ): SpaceTypeConnection
  space(
    """The ID of the object"""
    id: ID!
  ): SpaceType
  spaceByPk(pk: Int): SpaceType
  serviceSectors(offset: Int, before: String, after: String, first: Int, last: Int): ServiceSectorTypeConnection
  units(
    offset: Int
    before: String
    after: String
    first: Int
    last: Int
    pk: [ID]
    nameFi: String
    nameEn: String
    nameSv: String
    serviceSector: Decimal
    onlyWithPermission: Boolean
    publishedReservationUnits: Boolean
    ownReservations: Boolean

    """Järjestä"""
    orderBy: String
  ): UnitTypeConnection
  unit(
    """The ID of the object"""
    id: ID!
  ): UnitType
  unitByPk(pk: Int): UnitByPkType
  currentUser: UserType
  user(pk: Int): UserType
  keywordCategories(offset: Int, before: String, after: String, first: Int, last: Int, nameFi: String, nameSv: String, nameEn: String): KeywordCategoryTypeConnection
  keywordGroups(offset: Int, before: String, after: String, first: Int, last: Int, nameFi: String, nameSv: String, nameEn: String): KeywordGroupTypeConnection
  keywords(offset: Int, before: String, after: String, first: Int, last: Int, nameFi: String, nameSv: String, nameEn: String): KeywordTypeConnection
  purposes(
    offset: Int
    before: String
    after: String
    first: Int
    last: Int

    """Järjestä"""
    orderBy: String
  ): PurposeTypeConnection
  qualifiers(offset: Int, before: String, after: String, first: Int, last: Int, nameFi: String, nameEn: String, nameSv: String): QualifierTypeConnection
  reservationPurposes(offset: Int, before: String, after: String, first: Int, last: Int, nameFi: String, nameEn: String, nameSv: String): ReservationPurposeTypeConnection
  termsOfUse(offset: Int, before: String, after: String, first: Int, last: Int, termsType: TermsType): TermsOfUseTypeConnection
  taxPercentages(offset: Int, before: String, after: String, first: Int, last: Int, value: Decimal): TaxPercentageTypeConnection
  ageGroups(offset: Int, before: String, after: String, first: Int, last: Int): AgeGroupTypeConnection
  cities(first: Int, last: Int, offset: Int, after: String, before: String): CityNodeConnection
  metadataSets(offset: Int, before: String, after: String, first: Int, last: Int): ReservationMetadataSetTypeConnection
  order(orderUuid: String): PaymentOrderType
  bannerNotification(
    """The ID of the object"""
    id: ID!
  ): BannerNotificationNode
  bannerNotifications(
    offset: Int
    before: String
    after: String
    first: Int
    last: Int
    name: String
    target: BannerNotificationTarget
    isActive: Boolean
    isVisible: Boolean

    """Järjestä"""
    orderBy: String
  ): BannerNotificationNodeConnection
  _debug: DjangoDebug
}

type RealEstateType implements Node {
  nameFi: String
  nameEn: String
  nameSv: String
  surfaceArea: Decimal

  """The ID of the object"""
  id: ID!
  pk: Int
}

input RecurringReservationCreateMutationInput {
  user: String
  name: String
  description: String
  reservationUnitPk: Int!
  ageGroupPk: Int
  abilityGroupPk: Int
  recurrenceInDays: Int!

  """List of weekdays which days the reservations occurs"""
  weekdays: [Int]!

  """Time when reservations begins."""
  beginTime: Time!

  """Time when reservations ends."""
  endTime: Time!

  """Date when first reservation begins."""
  beginDate: Date!

  """Date when last reservation begins."""
  endDate: Date!
  clientMutationId: String
}

type RecurringReservationCreateMutationPayload {
  pk: Int
  user: String
  name: String
  description: String
  reservationUnitPk: Int
  ageGroupPk: Int
  abilityGroupPk: Int
  recurrenceInDays: Int

  """List of weekdays which days the reservations occurs"""
  weekdays: [Int]

  """Time when reservations begins."""
  beginTime: Time

  """Time when reservations ends."""
  endTime: Time

  """Date when first reservation begins."""
  beginDate: Date

  """Date when last reservation begins."""
  endDate: Date

  """May contain more than one error for same field."""
  errors: [ErrorType]
  recurringReservation: RecurringReservationType
  clientMutationId: String
}

type RecurringReservationType implements Node {
  name: String!
  description: String!
  user: String
  beginDate: Date
  beginTime: TimeString
  endDate: Date
  endTime: TimeString
  reservationUnit: ReservationUnitByPkType
  recurrenceInDays: Int
  weekdays: [Int]
  ageGroup: AgeGroupType
  abilityGroup: AbilityGroupType
  created: DateTime!

  """The ID of the object"""
  id: ID!
  pk: Int
}

type RecurringReservationTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [RecurringReservationTypeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `RecurringReservationType` and its cursor."""
type RecurringReservationTypeEdge {
  """The item at the end of the edge"""
  node: RecurringReservationType

  """A cursor for use in pagination"""
  cursor: String!
}

input RecurringReservationUpdateMutationInput {
  pk: Int!
  user: String
  name: String
  description: String
  ageGroupPk: Int
  abilityGroupPk: Int
  recurrenceInDays: Int

  """List of weekdays which days the reservations occurs"""
  weekdays: [Int]

  """Time when reservations begins."""
  beginTime: Time

  """Time when reservations ends."""
  endTime: Time

  """Date when first reservation begins."""
  beginDate: Date

  """Date when last reservation begins."""
  endDate: Date
  clientMutationId: String
}

type RecurringReservationUpdateMutationPayload {
  pk: Int
  user: String
  name: String
  description: String
  ageGroupPk: Int
  abilityGroupPk: Int
  recurrenceInDays: Int

  """List of weekdays which days the reservations occurs"""
  weekdays: [Int]

  """Time when reservations begins."""
  beginTime: Time

  """Time when reservations ends."""
  endTime: Time

  """Date when first reservation begins."""
  beginDate: Date

  """Date when last reservation begins."""
  endDate: Date

  """May contain more than one error for same field."""
  errors: [ErrorType]
  recurringReservation: RecurringReservationType
  clientMutationId: String
}

input RefreshOrderMutationInput {
  orderUuid: UUID!
  clientMutationId: String
}

type RefreshOrderMutationPayload {
  orderUuid: UUID
  status: String
  reservationPk: Int
  clientMutationId: String
}

type ReservableTimeSpanType {
  startDatetime: DateTime
  endDatetime: DateTime
}

input ReservationAdjustTimeMutationInput {
  pk: Int!
  begin: DateTime!
  end: DateTime!
  state: State
  clientMutationId: String
}

type ReservationAdjustTimeMutationPayload {
  pk: Int
  begin: DateTime
  end: DateTime
  state: State

  """May contain more than one error for same field."""
  errors: [ErrorType]
  clientMutationId: String
}

input ReservationApproveMutationInput {
  pk: Int

  """Additional information for approval."""
  handlingDetails: String!
  price: Float!
  priceNet: Float!
  clientMutationId: String
}

type ReservationApproveMutationPayload {
  pk: Int
  state: State

  """Additional information for approval."""
  handlingDetails: String

  """When this reservation was handled."""
  handledAt: DateTime
  price: Float
  priceNet: Float

  """May contain more than one error for same field."""
  errors: [ErrorType]
  clientMutationId: String
}

input ReservationCancellationMutationInput {
  pk: Int!

  """Primary key for the pre-defined cancel reason."""
  cancelReasonPk: Int!

  """Additional information for the cancellation."""
  cancelDetails: String
  clientMutationId: String
}

type ReservationCancellationMutationPayload {
  pk: Int

  """Primary key for the pre-defined cancel reason."""
  cancelReasonPk: Int

  """Additional information for the cancellation."""
  cancelDetails: String
  state: State

  """May contain more than one error for same field."""
  errors: [ErrorType]
  clientMutationId: String
}

type ReservationCancelReasonType implements Node {
  reason: String!
  reasonFi: String
  reasonEn: String
  reasonSv: String

  """The ID of the object"""
  id: ID!
  pk: Int
}

type ReservationCancelReasonTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ReservationCancelReasonTypeEdge]!
}

"""
A Relay edge containing a `ReservationCancelReasonType` and its cursor.
"""
type ReservationCancelReasonTypeEdge {
  """The item at the end of the edge"""
  node: ReservationCancelReasonType

  """A cursor for use in pagination"""
  cursor: String!
}

input ReservationConfirmMutationInput {
  """Type of the payment. Possible values are ONLINE, INVOICE, ON_SITE."""
  paymentType: String
  pk: Int!
  clientMutationId: String
}

type ReservationConfirmMutationPayload {
  """Type of the payment. Possible values are ONLINE, INVOICE, ON_SITE."""
  paymentType: String
  pk: Int
  reserveeFirstName: String
  reserveeLastName: String
  reserveePhone: String
  reserveeOrganisationName: String
  reserveeAddressStreet: String
  reserveeAddressCity: String
  reserveeAddressZip: String
  reserveeEmail: String
  reserveeType: String

  """Reservee's business or association identity code"""
  reserveeId: String
  reserveeIsUnregisteredAssociation: Boolean
  reserveeLanguage: String
  homeCityPk: Int
  applyingForFreeOfCharge: Boolean
  freeOfChargeReason: String
  ageGroupPk: Int
  billingFirstName: String
  billingLastName: String
  billingAddressStreet: String
  billingAddressCity: String
  billingAddressZip: String
  billingPhone: String
  billingEmail: String
  numPersons: Int
  name: String
  description: String

  """
  String value for ReservationType's ReservationState enum. Possible values are
  CREATED, CANCELLED, REQUIRES_HANDLING, WAITING_FOR_PAYMENT, CONFIRMED, DENIED.
  """
  state: String
  begin: DateTime
  end: DateTime
  bufferTimeBefore: Int
  bufferTimeAfter: Int
  purposePk: Int
  confirmedAt: DateTime

  """The unit price of this particular reservation"""
  unitPrice: Decimal

  """The value of the tax percentage for this particular reservation"""
  taxPercentageValue: Decimal

  """The price of this particular reservation including VAT"""
  price: Decimal

  """The price of this particular reservation excluding VAT"""
  priceNet: Decimal

  """The non subsidised price of this reservation including VAT"""
  nonSubsidisedPrice: Decimal

  """The non subsidised price of this reservation excluding VAT"""
  nonSubsidisedPriceNet: Decimal
  type: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  order: PaymentOrderType
  clientMutationId: String
}

input ReservationCreateMutationInput {
  reserveeFirstName: String
  reserveeLastName: String
  reserveePhone: String
  reserveeOrganisationName: String
  reserveeAddressStreet: String
  reserveeAddressCity: String
  reserveeAddressZip: String
  reserveeEmail: String
  reserveeType: String

  """Reservee's business or association identity code"""
  reserveeId: String
  reserveeIsUnregisteredAssociation: Boolean
  reserveeLanguage: String
  homeCityPk: Int
  applyingForFreeOfCharge: Boolean
  freeOfChargeReason: String
  ageGroupPk: Int
  billingFirstName: String
  billingLastName: String
  billingAddressStreet: String
  billingAddressCity: String
  billingAddressZip: String
  billingPhone: String
  billingEmail: String
  numPersons: Int
  name: String
  description: String
  begin: DateTime!
  end: DateTime!
  bufferTimeBefore: Int
  bufferTimeAfter: Int
  reservationUnitPks: [Int]!
  purposePk: Int
  type: String
  clientMutationId: String
}

type ReservationCreateMutationPayload {
  pk: Int
  reserveeFirstName: String
  reserveeLastName: String
  reserveePhone: String
  reserveeOrganisationName: String
  reserveeAddressStreet: String
  reserveeAddressCity: String
  reserveeAddressZip: String
  reserveeEmail: String
  reserveeType: String

  """Reservee's business or association identity code"""
  reserveeId: String
  reserveeIsUnregisteredAssociation: Boolean
  reserveeLanguage: String
  homeCityPk: Int
  applyingForFreeOfCharge: Boolean
  freeOfChargeReason: String
  ageGroupPk: Int
  billingFirstName: String
  billingLastName: String
  billingAddressStreet: String
  billingAddressCity: String
  billingAddressZip: String
  billingPhone: String
  billingEmail: String
  numPersons: Int
  name: String
  description: String
  state: String
  begin: DateTime
  end: DateTime
  bufferTimeBefore: Int
  bufferTimeAfter: Int
  purposePk: Int
  confirmedAt: DateTime

  """The unit price of this particular reservation"""
  unitPrice: Decimal

  """The value of the tax percentage for this particular reservation"""
  taxPercentageValue: Decimal

  """The price of this particular reservation including VAT"""
  price: Decimal

  """The price of this particular reservation excluding VAT"""
  priceNet: Decimal

  """The non subsidised price of this reservation including VAT"""
  nonSubsidisedPrice: Decimal

  """The non subsidised price of this reservation excluding VAT"""
  nonSubsidisedPriceNet: Decimal
  type: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  reservation: ReservationType
  clientMutationId: String
}

input ReservationDeleteMutationInput {
  pk: Int!
  clientMutationId: String
}

type ReservationDeleteMutationPayload {
  deleted: Boolean
  errors: String
  clientMutationId: String
}

input ReservationDenyMutationInput {
  pk: Int

  """Additional information for denying."""
  handlingDetails: String

  """Primary key for the pre-defined deny reason."""
  denyReasonPk: Int!
  clientMutationId: String
}

type ReservationDenyMutationPayload {
  pk: Int
  state: State

  """Additional information for denying."""
  handlingDetails: String

  """When this reservation was handled."""
  handledAt: DateTime

  """Primary key for the pre-defined deny reason."""
  denyReasonPk: Int

  """May contain more than one error for same field."""
  errors: [ErrorType]
  clientMutationId: String
}

type ReservationDenyReasonType implements Node {
  reason: String!
  reasonFi: String
  reasonEn: String
  reasonSv: String

  """The ID of the object"""
  id: ID!
  pk: Int
}

type ReservationDenyReasonTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ReservationDenyReasonTypeEdge]!
}

"""A Relay edge containing a `ReservationDenyReasonType` and its cursor."""
type ReservationDenyReasonTypeEdge {
  """The item at the end of the edge"""
  node: ReservationDenyReasonType

  """A cursor for use in pagination"""
  cursor: String!
}

"""An enumeration."""
enum ReservationKind {
  """Direct"""
  DIRECT

  """Season"""
  SEASON

  """Direct And Season"""
  DIRECT_AND_SEASON
}

type ReservationMetadataSetType implements Node {
  name: String!
  supportedFields: [String]
  requiredFields: [String]

  """The ID of the object"""
  id: ID!
  pk: Int
}

type ReservationMetadataSetTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ReservationMetadataSetTypeEdge]!
}

"""A Relay edge containing a `ReservationMetadataSetType` and its cursor."""
type ReservationMetadataSetTypeEdge {
  """The item at the end of the edge"""
  node: ReservationMetadataSetType

  """A cursor for use in pagination"""
  cursor: String!
}

type ReservationPurposeType implements Node {
  nameFi: String
  nameEn: String
  nameSv: String

  """The ID of the object"""
  id: ID!
  pk: Int
}

type ReservationPurposeTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ReservationPurposeTypeEdge]!
}

"""A Relay edge containing a `ReservationPurposeType` and its cursor."""
type ReservationPurposeTypeEdge {
  """The item at the end of the edge"""
  node: ReservationPurposeType

  """A cursor for use in pagination"""
  cursor: String!
}

input ReservationRefundMutationInput {
  pk: Int
  clientMutationId: String
}

type ReservationRefundMutationPayload {
  pk: Int

  """May contain more than one error for same field."""
  errors: [ErrorType]
  clientMutationId: String
}

input ReservationRequiresHandlingMutationInput {
  pk: Int
  clientMutationId: String
}

type ReservationRequiresHandlingMutationPayload {
  pk: Int
  state: State

  """May contain more than one error for same field."""
  errors: [ErrorType]
  clientMutationId: String
}

input ReservationStaffAdjustTimeMutationInput {
  pk: Int!
  begin: DateTime!
  end: DateTime!
  state: State

  """
  Can be a number of seconds or timespan in format HH:MM:SS. Null/undefined
  value means buffer from reservation unit is used.
  """
  bufferTimeBefore: String

  """
  Can be a number of seconds or timespan in format HH:MM:SS. Null/undefined
  value means buffer from reservation unit is used.
  """
  bufferTimeAfter: String
  clientMutationId: String
}

type ReservationStaffAdjustTimeMutationPayload {
  pk: Int
  begin: DateTime
  end: DateTime
  state: State

  """
  Can be a number of seconds or timespan in format HH:MM:SS. Null/undefined
  value means buffer from reservation unit is used.
  """
  bufferTimeBefore: String

  """
  Can be a number of seconds or timespan in format HH:MM:SS. Null/undefined
  value means buffer from reservation unit is used.
  """
  bufferTimeAfter: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  clientMutationId: String
}

input ReservationStaffCreateMutationInput {
  reserveeFirstName: String
  reserveeLastName: String
  reserveePhone: String
  reserveeOrganisationName: String
  reserveeAddressStreet: String
  reserveeAddressCity: String
  reserveeAddressZip: String
  reserveeEmail: String
  reserveeType: String

  """Reservee's business or association identity code"""
  reserveeId: String
  reserveeIsUnregisteredAssociation: Boolean
  reserveeLanguage: String
  billingFirstName: String
  billingLastName: String
  billingAddressStreet: String
  billingAddressCity: String
  billingAddressZip: String
  billingPhone: String
  billingEmail: String
  homeCityPk: Int
  applyingForFreeOfCharge: Boolean
  freeOfChargeReason: String
  ageGroupPk: Int
  numPersons: Int
  name: String
  description: String
  begin: DateTime!
  end: DateTime!

  """
  Can be a number of seconds or timespan in format HH:MM:SS. Null/undefined
  value means buffer from reservation unit is used.
  """
  bufferTimeBefore: String

  """
  Can be a number of seconds or timespan in format HH:MM:SS. Null/undefined
  value means buffer from reservation unit is used.
  """
  bufferTimeAfter: String
  reservationUnitPks: [Int]!
  purposePk: Int

  """The unit price of this particular reservation"""
  unitPrice: Decimal
  type: String!

  """Working memo for staff users."""
  workingMemo: String
  recurringReservationPk: Int
  clientMutationId: String
}

type ReservationStaffCreateMutationPayload {
  pk: Int
  reserveeFirstName: String
  reserveeLastName: String
  reserveePhone: String
  reserveeOrganisationName: String
  reserveeAddressStreet: String
  reserveeAddressCity: String
  reserveeAddressZip: String
  reserveeEmail: String
  reserveeType: String

  """Reservee's business or association identity code"""
  reserveeId: String
  reserveeIsUnregisteredAssociation: Boolean
  reserveeLanguage: String
  billingFirstName: String
  billingLastName: String
  billingAddressStreet: String
  billingAddressCity: String
  billingAddressZip: String
  billingPhone: String
  billingEmail: String
  homeCityPk: Int
  applyingForFreeOfCharge: Boolean
  freeOfChargeReason: String
  ageGroupPk: Int
  numPersons: Int
  name: String
  description: String
  state: State
  begin: DateTime
  end: DateTime

  """
  Can be a number of seconds or timespan in format HH:MM:SS. Null/undefined
  value means buffer from reservation unit is used.
  """
  bufferTimeBefore: String

  """
  Can be a number of seconds or timespan in format HH:MM:SS. Null/undefined
  value means buffer from reservation unit is used.
  """
  bufferTimeAfter: String
  reservationUnitPks: [Int]
  purposePk: Int
  confirmedAt: DateTime

  """When this reservation was handled."""
  handledAt: DateTime

  """The unit price of this particular reservation"""
  unitPrice: Decimal
  type: String

  """Working memo for staff users."""
  workingMemo: String
  recurringReservationPk: Int

  """May contain more than one error for same field."""
  errors: [ErrorType]
  reservation: ReservationType
  clientMutationId: String
}

input ReservationStaffModifyMutationInput {
  pk: Int!
  reserveeFirstName: String
  reserveeLastName: String
  reserveePhone: String
  reserveeOrganisationName: String
  reserveeAddressStreet: String
  reserveeAddressCity: String
  reserveeAddressZip: String
  reserveeEmail: String
  reserveeType: String

  """Reservee's business or association identity code"""
  reserveeId: String
  reserveeIsUnregisteredAssociation: Boolean
  reserveeLanguage: String
  homeCityPk: Int
  applyingForFreeOfCharge: Boolean
  freeOfChargeReason: String
  ageGroupPk: Int
  billingFirstName: String
  billingLastName: String
  billingAddressStreet: String
  billingAddressCity: String
  billingAddressZip: String
  billingPhone: String
  billingEmail: String
  numPersons: Int
  name: String
  description: String

  """
  String value for ReservationType's ReservationState enum. Possible values are
  CREATED, CANCELLED, REQUIRES_HANDLING, WAITING_FOR_PAYMENT, CONFIRMED, DENIED.
  """
  state: String
  reservationUnitPks: [Int]
  purposePk: Int
  type: String
  clientMutationId: String
}

type ReservationStaffModifyMutationPayload {
  pk: Int
  reserveeFirstName: String
  reserveeLastName: String
  reserveePhone: String
  reserveeOrganisationName: String
  reserveeAddressStreet: String
  reserveeAddressCity: String
  reserveeAddressZip: String
  reserveeEmail: String
  reserveeType: String

  """Reservee's business or association identity code"""
  reserveeId: String
  reserveeIsUnregisteredAssociation: Boolean
  reserveeLanguage: String
  homeCityPk: Int
  applyingForFreeOfCharge: Boolean
  freeOfChargeReason: String
  ageGroupPk: Int
  billingFirstName: String
  billingLastName: String
  billingAddressStreet: String
  billingAddressCity: String
  billingAddressZip: String
  billingPhone: String
  billingEmail: String
  numPersons: Int
  name: String
  description: String

  """
  String value for ReservationType's ReservationState enum. Possible values are
  CREATED, CANCELLED, REQUIRES_HANDLING, WAITING_FOR_PAYMENT, CONFIRMED, DENIED.
  """
  state: String
  begin: DateTime
  end: DateTime
  bufferTimeBefore: Int
  bufferTimeAfter: Int
  purposePk: Int
  confirmedAt: DateTime

  """The unit price of this particular reservation"""
  unitPrice: Decimal

  """The value of the tax percentage for this particular reservation"""
  taxPercentageValue: Decimal

  """The price of this particular reservation including VAT"""
  price: Decimal

  """The price of this particular reservation excluding VAT"""
  priceNet: Decimal

  """The non subsidised price of this reservation including VAT"""
  nonSubsidisedPrice: Decimal

  """The non subsidised price of this reservation excluding VAT"""
  nonSubsidisedPriceNet: Decimal
  type: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  clientMutationId: String
}

"""An enumeration."""
enum ReservationStartInterval {
  """15 minuuttia"""
  INTERVAL_15_MINS

  """30 minuuttia"""
  INTERVAL_30_MINS

  """60 minuuttia"""
  INTERVAL_60_MINS

  """90 minuuttia"""
  INTERVAL_90_MINS

  """2 tuntia"""
  INTERVAL_120_MINS

  """3 tuntia"""
  INTERVAL_180_MINS

  """4 tuntia"""
  INTERVAL_240_MINS

  """5 tuntia"""
  INTERVAL_300_MINS

  """6 tuntia"""
  INTERVAL_360_MINS

  """7 tuntia"""
  INTERVAL_420_MINS
}

"""An enumeration."""
enum ReservationState {
  SCHEDULED_RESERVATION
  SCHEDULED_PERIOD
  RESERVABLE
  SCHEDULED_CLOSING
  RESERVATION_CLOSED
}

type ReservationType implements Node {
  """Type of reservee"""
  reserveeType: ReserveeType
  reserveeFirstName: String
  reserveeLastName: String
  reserveeOrganisationName: String
  reserveePhone: String
  reserveeEmail: String
  reserveeId: String
  reserveeIsUnregisteredAssociation: Boolean
  reserveeAddressStreet: String
  reserveeAddressCity: String
  reserveeAddressZip: String
  billingFirstName: String
  billingLastName: String
  billingPhone: String
  billingEmail: String
  billingAddressStreet: String
  billingAddressCity: String
  billingAddressZip: String

  """Home city of the group or association"""
  homeCity: CityNode
  ageGroup: AgeGroupType
  applyingForFreeOfCharge: Boolean
  freeOfChargeReason: String
  name: String
  description: String
  state: State!
  user: UserType
  begin: DateTime!
  end: DateTime!
  bufferTimeBefore: Duration
  bufferTimeAfter: Duration
  recurringReservation: RecurringReservationType
  numPersons: Int
  purpose: ReservationPurposeType
  cancelReason: ReservationCancelReasonType
  cancelDetails: String
  createdAt: String
  unitPrice: Float
  taxPercentageValue: Decimal
  price: Float
  priceNet: Decimal
  handledAt: DateTime
  denyReason: ReservationDenyReasonType

  """Additional details for denying or approving the reservation"""
  handlingDetails: String!

  """Working memo for staff users."""
  workingMemo: String

  """Type of reservation"""
  type: Type

  """The ID of the object"""
  id: ID!
  pk: Int
  isBlocked: Boolean
  isHandled: Boolean
  order: PaymentOrderType
  reservationUnits: [ReservationUnitType]
  reserveeName: String
  staffEvent: Boolean @deprecated(reason: "Please refer to type.")
  calendarUrl: String
}

type ReservationTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ReservationTypeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `ReservationType` and its cursor."""
type ReservationTypeEdge {
  """The item at the end of the edge"""
  node: ReservationType

  """A cursor for use in pagination"""
  cursor: String!
}

type ReservationUnitByPkType implements Node {
  nameFi: String
  nameEn: String
  nameSv: String
  descriptionFi: String
  descriptionEn: String
  descriptionSv: String
  spaces: [SpaceType]
  resources: [ResourceType]
  services: [ServiceType]
  purposes: [PurposeType]
  reservationUnitType: ReservationUnitTypeType
  requireIntroduction: Boolean!
  termsOfUseFi: String
  termsOfUseEn: String
  termsOfUseSv: String
  paymentTerms: TermsOfUseType
  cancellationTerms: TermsOfUseType
  serviceSpecificTerms: TermsOfUseType
  pricingTerms: TermsOfUseType
  reservationPendingInstructionsFi: String
  reservationPendingInstructionsEn: String
  reservationPendingInstructionsSv: String
  reservationConfirmedInstructionsFi: String
  reservationConfirmedInstructionsEn: String
  reservationConfirmedInstructionsSv: String
  reservationCancelledInstructionsFi: String
  reservationCancelledInstructionsEn: String
  reservationCancelledInstructionsSv: String
  contactInformation: String!
  maxReservationDuration: Duration
  minReservationDuration: Duration
  uuid: UUID!
  isDraft: Boolean!
  maxPersons: Int
  minPersons: Int
  surfaceArea: Int
  bufferTimeBefore: Duration
  bufferTimeAfter: Duration
  cancellationRule: ReservationUnitCancellationRuleType

  """
  Determines the interval for the start time of the reservation. For example an
  interval of 15 minutes means a reservation can begin at minutes 15, 30, 60, or
  90. Possible values are interval_15_mins, interval_30_mins, interval_60_mins,
  interval_90_mins, interval_120_mins, interval_180_mins, interval_240_mins,
  interval_300_mins, interval_360_mins, interval_420_mins.
  """
  reservationStartInterval: ReservationStartInterval!
  reservationsMinDaysBefore: Int
  reservationsMaxDaysBefore: Int

  """
  Aika, jolloin varauksien tekeminen tulee mahdolliseksi tälle varausyksikölle.
  """
  reservationBegins: DateTime

  """
  Aika, jolloin varauksien tekeminen ei ole enää mahdollista tälle varausyksikölle
  """
  reservationEnds: DateTime

  """
  Aika, jonka jälkeen tämä varausyksikkö tulee julkisesti näkyville käyttöliittymässä.
  """
  publishBegins: DateTime

  """
  Aika, jonka jälkeen tämä varausyksikkö ei enää ole julkisesti näkyvillä käyttöliittymässä.
  """
  publishEnds: DateTime
  metadataSet: ReservationMetadataSetType
  maxReservationsPerUser: Int

  """
  Vaativatko tämän varausyksikön varaukset käsittelyn ennen kuin ne voidaan vahvistaa.
  """
  requireReservationHandling: Boolean!

  """Tunnistautumisen taso joka vaaditaan tämän varausyksikön varaamiseen."""
  authentication: Authentication!

  """Järjestysnumero, jota käytetään rajapinnan järjestämisessä."""
  rank: Int

  """What kind of reservations are to be booked with this reservation unit."""
  reservationKind: ReservationKind!
  paymentTypes: [ReservationUnitPaymentTypeType]
  reservationBlockWholeDay: Boolean!

  """Voivatko tämän varausyksikön varaukset olla alennuskelpoisia."""
  canApplyFreeOfCharge: Boolean!

  """
  Is it possible to reserve this reservation unit when opening hours are not defined.
  """
  allowReservationsWithoutOpeningHours: Boolean!

  """Is reservation unit archived."""
  isArchived: Boolean!
  applicationRounds(active: Boolean): [ApplicationRoundNode]
  images: [ReservationUnitImageType!]

  """The ID of the object"""
  id: ID!
  reservations(from: Date, to: Date, state: [String], includeWithSameComponents: Boolean): [ReservationType]
  pk: Int
  qualifiers: [QualifierType]
  location: LocationType
  equipment: [EquipmentType]
  unit: UnitType
  keywordGroups: [KeywordGroupType]
  state: ReservationUnitState
  reservationState: ReservationState
  paymentMerchant: PaymentMerchantType
  paymentProduct: PaymentProductType
  pricings: [ReservationUnitPricingType]
  applicationRoundTimeSlots: [ApplicationRoundTimeSlotNode!]
  isClosed: Boolean
  firstReservableDatetime: DateTime
  haukiUrl: ReservationUnitHaukiUrlType
  reservableTimeSpans(startDate: Date!, endDate: Date!): [ReservableTimeSpanType]
}

type ReservationUnitCancellationRuleType implements Node {
  nameFi: String
  nameEn: String
  nameSv: String

  """
  Seconds before reservations related to this cancellation rule can be cancelled without handling.
  """
  canBeCancelledTimeBefore: Duration
  needsHandling: Boolean!

  """The ID of the object"""
  id: ID!
  pk: Int
}

type ReservationUnitCancellationRuleTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ReservationUnitCancellationRuleTypeEdge]!
  totalCount: Int
}

"""
A Relay edge containing a `ReservationUnitCancellationRuleType` and its cursor.
"""
type ReservationUnitCancellationRuleTypeEdge {
  """The item at the end of the edge"""
  node: ReservationUnitCancellationRuleType

  """A cursor for use in pagination"""
  cursor: String!
}

input ReservationUnitCreateMutationInput {
  """
  Determines if introduction is required in order to reserve this reservation unit.
  """
  requireIntroduction: Boolean
  maxPersons: Int
  minPersons: Int
  equipmentPks: [Int]
  unitPk: Int

  """Contact information for this reservation unit."""
  contactInformation: String
  maxReservationDuration: Int
  minReservationDuration: Int
  isDraft: Boolean
  spacePks: [Int]
  resourcePks: [Int]
  purposePks: [Int]
  qualifierPks: [Int]
  servicePks: [Int]
  reservationUnitTypePk: Int
  surfaceArea: Int
  bufferTimeBefore: Int
  bufferTimeAfter: Int
  cancellationRulePk: Int
  paymentTermsPk: String
  cancellationTermsPk: String
  serviceSpecificTermsPk: String

  """
  Determines the interval for the start time of the reservation. For example an
  interval of 15 minutes means a reservation can begin at minutes 0, 15, 30, or
  45. Possible values are INTERVAL_15_MINUTES, INTERVAL_30_MINUTES,
  INTERVAL_60_MINUTES, INTERVAL_90_MINUTES, INTERVAL_120_MINUTES,
  INTERVAL_180_MINUTES, INTERVAL_240_MINUTES, INTERVAL_300_MINUTES,
  INTERVAL_360_MINUTES, INTERVAL_420_MINUTES.
  """
  reservationStartInterval: String

  """
  Aika, jolloin varauksien tekeminen tulee mahdolliseksi tälle varausyksikölle.
  """
  reservationBegins: DateTime

  """
  Aika, jolloin varauksien tekeminen ei ole enää mahdollista tälle varausyksikölle
  """
  reservationEnds: DateTime

  """
  Aika, jonka jälkeen tämä varausyksikkö tulee julkisesti näkyville käyttöliittymässä.
  """
  publishBegins: DateTime

  """
  Aika, jonka jälkeen tämä varausyksikkö ei enää ole julkisesti näkyvillä käyttöliittymässä.
  """
  publishEnds: DateTime
  metadataSetPk: Int
  maxReservationsPerUser: Int

  """
  Vaativatko tämän varausyksikön varaukset käsittelyn ennen kuin ne voidaan vahvistaa.
  """
  requireReservationHandling: Boolean

  """
  Authentication required for reserving this reservation unit. Possible values are WEAK, STRONG.
  """
  authentication: String

  """
  What kind of reservations are to be made to this is reservation unit. Possible
  values are: DIRECT, SEASON, DIRECT_AND_SEASON.
  """
  reservationKind: String
  reservationBlockWholeDay: Boolean

  """Voivatko tämän varausyksikön varaukset olla alennuskelpoisia."""
  canApplyFreeOfCharge: Boolean
  reservationsMaxDaysBefore: Int
  reservationsMinDaysBefore: Int

  """Allow reservations without opening hours. Used for testing."""
  allowReservationsWithoutOpeningHours: Boolean

  """Is reservation unit archived"""
  isArchived: Boolean
  pricingTermsPk: String
  pricingTerms: String
  paymentTypes: [String]
  pricings: [ReservationUnitPricingCreateSerializerInput]
  applicationRoundTimeSlots: [ApplicationRoundTimeSlotSerializerInput]
  reservationCancelledInstructionsFi: String
  reservationCancelledInstructionsEn: String
  reservationCancelledInstructionsSv: String
  reservationConfirmedInstructionsFi: String
  reservationConfirmedInstructionsEn: String
  reservationConfirmedInstructionsSv: String
  descriptionFi: String
  descriptionEn: String
  descriptionSv: String
  nameFi: String
  nameEn: String
  nameSv: String
  reservationPendingInstructionsFi: String
  reservationPendingInstructionsEn: String
  reservationPendingInstructionsSv: String
  termsOfUseFi: String
  termsOfUseEn: String
  termsOfUseSv: String
  clientMutationId: String
}

type ReservationUnitCreateMutationPayload {
  pk: Int

  """Spaces included in the reservation unit as nested related objects."""
  spaces: [SpaceType]

  """Resources included in the reservation unit as nested related objects."""
  resources: [ResourceType]

  """Services included in the reservation unit as nested related objects."""
  services: [ServiceType]

  """
  Determines if introduction is required in order to reserve this reservation unit.
  """
  requireIntroduction: Boolean
  purposes: [PurposeType]

  """Images of the reservation unit as nested related objects. """
  images: [ReservationUnitImageType]

  """
  Location of this reservation unit. Dynamically determined from spaces of the reservation unit.
  """
  location: String
  maxPersons: Int
  minPersons: Int

  """Type of the reservation unit as nested related object."""
  reservationUnitType: ReservationUnitTypeType
  building: String
  unitPk: Int
  uuid: String

  """Contact information for this reservation unit."""
  contactInformation: String
  maxReservationDuration: Int
  minReservationDuration: Int
  isDraft: Boolean
  qualifierPks: [Int]
  reservationUnitTypePk: Int
  surfaceArea: Int
  bufferTimeBefore: Int
  bufferTimeAfter: Int
  cancellationRulePk: Int

  """
  Determines the interval for the start time of the reservation. For example an
  interval of 15 minutes means a reservation can begin at minutes 0, 15, 30, or
  45. Possible values are INTERVAL_15_MINUTES, INTERVAL_30_MINUTES,
  INTERVAL_60_MINUTES, INTERVAL_90_MINUTES, INTERVAL_120_MINUTES,
  INTERVAL_180_MINUTES, INTERVAL_240_MINUTES, INTERVAL_300_MINUTES,
  INTERVAL_360_MINUTES, INTERVAL_420_MINUTES.
  """
  reservationStartInterval: String

  """
  Aika, jolloin varauksien tekeminen tulee mahdolliseksi tälle varausyksikölle.
  """
  reservationBegins: DateTime

  """
  Aika, jolloin varauksien tekeminen ei ole enää mahdollista tälle varausyksikölle
  """
  reservationEnds: DateTime

  """
  Aika, jonka jälkeen tämä varausyksikkö tulee julkisesti näkyville käyttöliittymässä.
  """
  publishBegins: DateTime

  """
  Aika, jonka jälkeen tämä varausyksikkö ei enää ole julkisesti näkyvillä käyttöliittymässä.
  """
  publishEnds: DateTime
  maxReservationsPerUser: Int

  """
  Vaativatko tämän varausyksikön varaukset käsittelyn ennen kuin ne voidaan vahvistaa.
  """
  requireReservationHandling: Boolean

  """
  Authentication required for reserving this reservation unit. Possible values are WEAK, STRONG.
  """
  authentication: String

  """
  What kind of reservations are to be made to this is reservation unit. Possible
  values are: DIRECT, SEASON, DIRECT_AND_SEASON.
  """
  reservationKind: String
  reservationBlockWholeDay: Boolean

  """Voivatko tämän varausyksikön varaukset olla alennuskelpoisia."""
  canApplyFreeOfCharge: Boolean
  reservationsMaxDaysBefore: Int
  reservationsMinDaysBefore: Int

  """Allow reservations without opening hours. Used for testing."""
  allowReservationsWithoutOpeningHours: Boolean

  """Is reservation unit archived"""
  isArchived: Boolean
  state: String
  pricingTerms: String
  paymentTypes: [String]
  pricings: [ReservationUnitPricingType]
  applicationRoundTimeSlots: [ApplicationRoundTimeSlotNode]
  reservationCancelledInstructionsFi: String
  reservationCancelledInstructionsEn: String
  reservationCancelledInstructionsSv: String
  reservationConfirmedInstructionsFi: String
  reservationConfirmedInstructionsEn: String
  reservationConfirmedInstructionsSv: String
  descriptionFi: String
  descriptionEn: String
  descriptionSv: String
  nameFi: String
  nameEn: String
  nameSv: String
  reservationPendingInstructionsFi: String
  reservationPendingInstructionsEn: String
  reservationPendingInstructionsSv: String
  termsOfUseFi: String
  termsOfUseEn: String
  termsOfUseSv: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  reservationUnit: ReservationUnitType
  clientMutationId: String
}

type ReservationUnitHaukiUrlType {
  url: String
}

input ReservationUnitImageCreateMutationInput {
  image: Upload
  reservationUnitPk: Int!

  """
  Type of image. Value is one of image_type enum values: MAIN, GROUND_PLAN, MAP, OTHER.
  """
  imageType: String!
  clientMutationId: String
}

type ReservationUnitImageCreateMutationPayload {
  pk: Int
  reservationUnitPk: Int

  """
  Type of image. Value is one of image_type enum values: MAIN, GROUND_PLAN, MAP, OTHER.
  """
  imageType: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  reservationUnitImage: ReservationUnitImageType
  clientMutationId: String
}

input ReservationUnitImageDeleteMutationInput {
  pk: Int!
  clientMutationId: String
}

type ReservationUnitImageDeleteMutationPayload {
  deleted: Boolean
  errors: String
  clientMutationId: String
}

type ReservationUnitImageType {
  imageType: ImageType!
  largeUrl: String
  mediumUrl: String
  smallUrl: String
  pk: Int
  imageUrl: String
}

input ReservationUnitImageUpdateMutationInput {
  pk: Int!

  """
  Type of image. Value is one of image_type enum values: MAIN, GROUND_PLAN, MAP, OTHER.
  """
  imageType: String
  clientMutationId: String
}

type ReservationUnitImageUpdateMutationPayload {
  pk: Int
  reservationUnitPk: Int

  """
  Type of image. Value is one of image_type enum values: MAIN, GROUND_PLAN, MAP, OTHER.
  """
  imageType: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  reservationUnitImage: ReservationUnitImageType
  clientMutationId: String
}

input ReservationUnitOptionApplicantSerializerInput {
  pk: Int
  preferredOrder: Int!
  reservationUnit: Int!
}

type ReservationUnitOptionNode implements Node {
  preferredOrder: Int!
  rejected: Boolean!
  locked: Boolean!
  applicationSection: ApplicationSectionNode!
  reservationUnit: ReservationUnitByPkType
  allocatedTimeSlots(
    pk: [Int]
    dayOfTheWeek: [Weekday]
    applicationRound: Int
    applicationSectionStatus: [ApplicationSectionStatusChoice]
    applicantType: [ApplicantTypeChoice]
    allocatedUnit: [Int]
    allocatedReservationUnit: [Int]
    textSearch: String

    """Järjestä"""
    orderBy: [AllocatedTimeSlotOrderingChoices]
  ): [AllocatedTimeSlotNode!]

  """The ID of the object"""
  id: ID!
  pk: Int
}

"""Ordering fields for the 'ReservationUnitOption' model."""
enum ReservationUnitOptionOrderingChoices {
  pkAsc
  pkDesc
}

input ReservationUnitOptionUpdateMutationInput {
  pk: Int!
  rejected: Boolean
  locked: Boolean
  clientMutationId: String
}

type ReservationUnitOptionUpdateMutationPayload {
  pk: Int
  rejected: Boolean
  locked: Boolean
  clientMutationId: String
}

type ReservationUnitPaymentTypeType implements Node {
  code: String

  """The ID of the object"""
  id: ID!
  pk: Int
}

input ReservationUnitPricingCreateSerializerInput {
  """When pricing is activated"""
  begins: Date!

  """
  What kind of pricing type this pricing has. Possible values are PAID, FREE.
  """
  pricingType: String!

  """
  Unit of the price. Possible values are PER_15_MINS, PER_30_MINS, PER_HOUR, PER_HALF_DAY, PER_DAY, PER_WEEK, FIXED.
  """
  priceUnit: String
  lowestPrice: Float
  lowestPriceNet: Float
  highestPrice: Float
  highestPriceNet: Float
  taxPercentagePk: Int

  """Pricing status. Possible values are PAST, ACTIVE, FUTURE."""
  status: String!
}

type ReservationUnitPricingType {
  """When pricing is activated"""
  begins: Date!

  """What kind of pricing types are available with this reservation unit."""
  pricingType: PricingType

  """Unit of the price"""
  priceUnit: PriceUnit!

  """Minimum price of the reservation unit including VAT"""
  lowestPrice: Decimal!

  """Maximum price of the reservation unit including VAT"""
  highestPrice: Decimal!
  taxPercentage: TaxPercentageType

  """Status of the pricing"""
  status: Status!
  pk: Int
  lowestPriceNet: Decimal
  highestPriceNet: Decimal
}

input ReservationUnitPricingUpdateSerializerInput {
  pk: Int

  """When pricing is activated"""
  begins: Date!

  """
  What kind of pricing type this pricing has. Possible values are PAID, FREE.
  """
  pricingType: String!

  """
  Unit of the price. Possible values are PER_15_MINS, PER_30_MINS, PER_HOUR, PER_HALF_DAY, PER_DAY, PER_WEEK, FIXED.
  """
  priceUnit: String
  lowestPrice: Float
  lowestPriceNet: Float
  highestPrice: Float
  highestPriceNet: Float
  taxPercentagePk: Int

  """Pricing status. Possible values are PAST, ACTIVE, FUTURE."""
  status: String!
}

"""An enumeration."""
enum ReservationUnitState {
  DRAFT
  SCHEDULED_PUBLISHING
  SCHEDULED_HIDING
  SCHEDULED_PERIOD
  HIDDEN
  PUBLISHED
  ARCHIVED
}

type ReservationUnitType implements Node {
  nameFi: String
  nameEn: String
  nameSv: String
  descriptionFi: String
  descriptionEn: String
  descriptionSv: String
  spaces: [SpaceType]
  resources: [ResourceType]
  services: [ServiceType]
  purposes: [PurposeType]
  qualifiers: [QualifierType]
  reservationUnitType: ReservationUnitTypeType
  requireIntroduction: Boolean!
  termsOfUseFi: String
  termsOfUseEn: String
  termsOfUseSv: String
  paymentTerms: TermsOfUseType
  cancellationTerms: TermsOfUseType
  serviceSpecificTerms: TermsOfUseType
  pricingTerms: TermsOfUseType
  reservationPendingInstructionsFi: String
  reservationPendingInstructionsEn: String
  reservationPendingInstructionsSv: String
  reservationConfirmedInstructionsFi: String
  reservationConfirmedInstructionsEn: String
  reservationConfirmedInstructionsSv: String
  reservationCancelledInstructionsFi: String
  reservationCancelledInstructionsEn: String
  reservationCancelledInstructionsSv: String
  contactInformation: String!
  maxReservationDuration: Duration
  minReservationDuration: Duration
  uuid: UUID!
  isDraft: Boolean!
  maxPersons: Int
  minPersons: Int
  surfaceArea: Int
  bufferTimeBefore: Duration
  bufferTimeAfter: Duration
  cancellationRule: ReservationUnitCancellationRuleType

  """
  Determines the interval for the start time of the reservation. For example an
  interval of 15 minutes means a reservation can begin at minutes 15, 30, 60, or
  90. Possible values are interval_15_mins, interval_30_mins, interval_60_mins,
  interval_90_mins, interval_120_mins, interval_180_mins, interval_240_mins,
  interval_300_mins, interval_360_mins, interval_420_mins.
  """
  reservationStartInterval: ReservationStartInterval!
  reservationsMinDaysBefore: Int
  reservationsMaxDaysBefore: Int

  """
  Aika, jolloin varauksien tekeminen tulee mahdolliseksi tälle varausyksikölle.
  """
  reservationBegins: DateTime

  """
  Aika, jolloin varauksien tekeminen ei ole enää mahdollista tälle varausyksikölle
  """
  reservationEnds: DateTime

  """
  Aika, jonka jälkeen tämä varausyksikkö tulee julkisesti näkyville käyttöliittymässä.
  """
  publishBegins: DateTime

  """
  Aika, jonka jälkeen tämä varausyksikkö ei enää ole julkisesti näkyvillä käyttöliittymässä.
  """
  publishEnds: DateTime
  metadataSet: ReservationMetadataSetType
  maxReservationsPerUser: Int

  """
  Vaativatko tämän varausyksikön varaukset käsittelyn ennen kuin ne voidaan vahvistaa.
  """
  requireReservationHandling: Boolean!

  """Tunnistautumisen taso joka vaaditaan tämän varausyksikön varaamiseen."""
  authentication: Authentication!

  """Järjestysnumero, jota käytetään rajapinnan järjestämisessä."""
  rank: Int

  """What kind of reservations are to be booked with this reservation unit."""
  reservationKind: ReservationKind!
  paymentTypes: [ReservationUnitPaymentTypeType]
  reservationBlockWholeDay: Boolean!

  """Voivatko tämän varausyksikön varaukset olla alennuskelpoisia."""
  canApplyFreeOfCharge: Boolean!

  """
  Is it possible to reserve this reservation unit when opening hours are not defined.
  """
  allowReservationsWithoutOpeningHours: Boolean!

  """Is reservation unit archived."""
  isArchived: Boolean!
  paymentMerchant: PaymentMerchantType
  paymentProduct: PaymentProductType
  applicationRounds(active: Boolean): [ApplicationRoundNode]
  applicationRoundTimeSlots: [ApplicationRoundTimeSlotNode!]
  images: [ReservationUnitImageType!]
  pricings: [ReservationUnitPricingType]

  """The ID of the object"""
  id: ID!
  reservations(from: Date, to: Date, state: [String], includeWithSameComponents: Boolean): [ReservationType]
  pk: Int
  location: LocationType
  equipment: [EquipmentType]
  unit: UnitType
  keywordGroups: [KeywordGroupType]
  state: ReservationUnitState
  reservationState: ReservationState
  isClosed: Boolean
  firstReservableDatetime: DateTime
}

type ReservationUnitTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ReservationUnitTypeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `ReservationUnitType` and its cursor."""
type ReservationUnitTypeEdge {
  """The item at the end of the edge"""
  node: ReservationUnitType

  """A cursor for use in pagination"""
  cursor: String!
}

type ReservationUnitTypeType implements Node {
  nameFi: String
  nameEn: String
  nameSv: String

  """Järjestysnumero, jota käytetään rajapinnan järjestämisessä."""
  rank: Int

  """The ID of the object"""
  id: ID!
  pk: Int
}

type ReservationUnitTypeTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ReservationUnitTypeTypeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `ReservationUnitTypeType` and its cursor."""
type ReservationUnitTypeTypeEdge {
  """The item at the end of the edge"""
  node: ReservationUnitTypeType

  """A cursor for use in pagination"""
  cursor: String!
}

input ReservationUnitUpdateMutationInput {
  pk: Int!

  """
  Determines if introduction is required in order to reserve this reservation unit.
  """
  requireIntroduction: Boolean
  maxPersons: Int
  minPersons: Int
  equipmentPks: [Int]
  unitPk: Int

  """Contact information for this reservation unit."""
  contactInformation: String
  maxReservationDuration: Int
  minReservationDuration: Int
  isDraft: Boolean
  spacePks: [Int]
  resourcePks: [Int]
  purposePks: [Int]
  qualifierPks: [Int]
  servicePks: [Int]
  reservationUnitTypePk: Int
  surfaceArea: Int
  bufferTimeBefore: Int
  bufferTimeAfter: Int
  cancellationRulePk: Int
  paymentTermsPk: String
  cancellationTermsPk: String
  serviceSpecificTermsPk: String

  """
  Determines the interval for the start time of the reservation. For example an
  interval of 15 minutes means a reservation can begin at minutes 0, 15, 30, or
  45. Possible values are INTERVAL_15_MINUTES, INTERVAL_30_MINUTES,
  INTERVAL_60_MINUTES, INTERVAL_90_MINUTES, INTERVAL_120_MINUTES,
  INTERVAL_180_MINUTES, INTERVAL_240_MINUTES, INTERVAL_300_MINUTES,
  INTERVAL_360_MINUTES, INTERVAL_420_MINUTES.
  """
  reservationStartInterval: String

  """
  Aika, jolloin varauksien tekeminen tulee mahdolliseksi tälle varausyksikölle.
  """
  reservationBegins: DateTime

  """
  Aika, jolloin varauksien tekeminen ei ole enää mahdollista tälle varausyksikölle
  """
  reservationEnds: DateTime

  """
  Aika, jonka jälkeen tämä varausyksikkö tulee julkisesti näkyville käyttöliittymässä.
  """
  publishBegins: DateTime

  """
  Aika, jonka jälkeen tämä varausyksikkö ei enää ole julkisesti näkyvillä käyttöliittymässä.
  """
  publishEnds: DateTime
  metadataSetPk: Int
  maxReservationsPerUser: Int

  """
  Vaativatko tämän varausyksikön varaukset käsittelyn ennen kuin ne voidaan vahvistaa.
  """
  requireReservationHandling: Boolean

  """
  Authentication required for reserving this reservation unit. Possible values are WEAK, STRONG.
  """
  authentication: String

  """
  What kind of reservations are to be made to this is reservation unit. Possible
  values are: DIRECT, SEASON, DIRECT_AND_SEASON.
  """
  reservationKind: String
  reservationBlockWholeDay: Boolean

  """Voivatko tämän varausyksikön varaukset olla alennuskelpoisia."""
  canApplyFreeOfCharge: Boolean
  reservationsMaxDaysBefore: Int
  reservationsMinDaysBefore: Int

  """Allow reservations without opening hours. Used for testing."""
  allowReservationsWithoutOpeningHours: Boolean

  """Is reservation unit archived"""
  isArchived: Boolean
  pricingTermsPk: String
  pricingTerms: String
  paymentTypes: [String]
  pricings: [ReservationUnitPricingUpdateSerializerInput]!
  applicationRoundTimeSlots: [ApplicationRoundTimeSlotSerializerInput]
  reservationCancelledInstructionsFi: String
  reservationCancelledInstructionsEn: String
  reservationCancelledInstructionsSv: String
  reservationConfirmedInstructionsFi: String
  reservationConfirmedInstructionsEn: String
  reservationConfirmedInstructionsSv: String
  descriptionFi: String
  descriptionEn: String
  descriptionSv: String
  nameFi: String
  nameEn: String
  nameSv: String
  reservationPendingInstructionsFi: String
  reservationPendingInstructionsEn: String
  reservationPendingInstructionsSv: String
  termsOfUseFi: String
  termsOfUseEn: String
  termsOfUseSv: String
  clientMutationId: String
}

type ReservationUnitUpdateMutationPayload {
  pk: Int

  """Spaces included in the reservation unit as nested related objects."""
  spaces: [SpaceType]

  """Resources included in the reservation unit as nested related objects."""
  resources: [ResourceType]

  """Services included in the reservation unit as nested related objects."""
  services: [ServiceType]

  """
  Determines if introduction is required in order to reserve this reservation unit.
  """
  requireIntroduction: Boolean
  purposes: [PurposeType]

  """Images of the reservation unit as nested related objects. """
  images: [ReservationUnitImageType]

  """
  Location of this reservation unit. Dynamically determined from spaces of the reservation unit.
  """
  location: String
  maxPersons: Int
  minPersons: Int

  """Type of the reservation unit as nested related object."""
  reservationUnitType: ReservationUnitTypeType
  building: String
  unitPk: Int
  uuid: String

  """Contact information for this reservation unit."""
  contactInformation: String
  maxReservationDuration: Int
  minReservationDuration: Int
  isDraft: Boolean
  qualifierPks: [Int]
  reservationUnitTypePk: Int
  surfaceArea: Int
  bufferTimeBefore: Int
  bufferTimeAfter: Int
  cancellationRulePk: Int

  """
  Determines the interval for the start time of the reservation. For example an
  interval of 15 minutes means a reservation can begin at minutes 0, 15, 30, or
  45. Possible values are INTERVAL_15_MINUTES, INTERVAL_30_MINUTES,
  INTERVAL_60_MINUTES, INTERVAL_90_MINUTES, INTERVAL_120_MINUTES,
  INTERVAL_180_MINUTES, INTERVAL_240_MINUTES, INTERVAL_300_MINUTES,
  INTERVAL_360_MINUTES, INTERVAL_420_MINUTES.
  """
  reservationStartInterval: String

  """
  Aika, jolloin varauksien tekeminen tulee mahdolliseksi tälle varausyksikölle.
  """
  reservationBegins: DateTime

  """
  Aika, jolloin varauksien tekeminen ei ole enää mahdollista tälle varausyksikölle
  """
  reservationEnds: DateTime

  """
  Aika, jonka jälkeen tämä varausyksikkö tulee julkisesti näkyville käyttöliittymässä.
  """
  publishBegins: DateTime

  """
  Aika, jonka jälkeen tämä varausyksikkö ei enää ole julkisesti näkyvillä käyttöliittymässä.
  """
  publishEnds: DateTime
  maxReservationsPerUser: Int

  """
  Vaativatko tämän varausyksikön varaukset käsittelyn ennen kuin ne voidaan vahvistaa.
  """
  requireReservationHandling: Boolean

  """
  Authentication required for reserving this reservation unit. Possible values are WEAK, STRONG.
  """
  authentication: String

  """
  What kind of reservations are to be made to this is reservation unit. Possible
  values are: DIRECT, SEASON, DIRECT_AND_SEASON.
  """
  reservationKind: String
  reservationBlockWholeDay: Boolean

  """Voivatko tämän varausyksikön varaukset olla alennuskelpoisia."""
  canApplyFreeOfCharge: Boolean
  reservationsMaxDaysBefore: Int
  reservationsMinDaysBefore: Int

  """Allow reservations without opening hours. Used for testing."""
  allowReservationsWithoutOpeningHours: Boolean

  """Is reservation unit archived"""
  isArchived: Boolean
  state: String
  pricingTerms: String
  paymentTypes: [String]
  applicationRoundTimeSlots: [ApplicationRoundTimeSlotNode]
  reservationCancelledInstructionsFi: String
  reservationCancelledInstructionsEn: String
  reservationCancelledInstructionsSv: String
  reservationConfirmedInstructionsFi: String
  reservationConfirmedInstructionsEn: String
  reservationConfirmedInstructionsSv: String
  descriptionFi: String
  descriptionEn: String
  descriptionSv: String
  nameFi: String
  nameEn: String
  nameSv: String
  reservationPendingInstructionsFi: String
  reservationPendingInstructionsEn: String
  reservationPendingInstructionsSv: String
  termsOfUseFi: String
  termsOfUseEn: String
  termsOfUseSv: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  reservationUnit: ReservationUnitType
  clientMutationId: String
}

input ReservationUpdateMutationInput {
  pk: Int!
  reserveeFirstName: String
  reserveeLastName: String
  reserveePhone: String
  reserveeOrganisationName: String
  reserveeAddressStreet: String
  reserveeAddressCity: String
  reserveeAddressZip: String
  reserveeEmail: String
  reserveeType: String

  """Reservee's business or association identity code"""
  reserveeId: String
  reserveeIsUnregisteredAssociation: Boolean
  reserveeLanguage: String
  homeCityPk: Int
  applyingForFreeOfCharge: Boolean
  freeOfChargeReason: String
  ageGroupPk: Int
  billingFirstName: String
  billingLastName: String
  billingAddressStreet: String
  billingAddressCity: String
  billingAddressZip: String
  billingPhone: String
  billingEmail: String
  numPersons: Int
  name: String
  description: String

  """
  String value for ReservationType's ReservationState enum. Possible values are
  CREATED, CANCELLED, REQUIRES_HANDLING, WAITING_FOR_PAYMENT, CONFIRMED, DENIED.
  """
  state: String
  begin: DateTime
  end: DateTime
  bufferTimeBefore: Int
  bufferTimeAfter: Int
  reservationUnitPks: [Int]
  purposePk: Int
  type: String
  clientMutationId: String
}

type ReservationUpdateMutationPayload {
  pk: Int
  reserveeFirstName: String
  reserveeLastName: String
  reserveePhone: String
  reserveeOrganisationName: String
  reserveeAddressStreet: String
  reserveeAddressCity: String
  reserveeAddressZip: String
  reserveeEmail: String
  reserveeType: String

  """Reservee's business or association identity code"""
  reserveeId: String
  reserveeIsUnregisteredAssociation: Boolean
  reserveeLanguage: String
  homeCityPk: Int
  applyingForFreeOfCharge: Boolean
  freeOfChargeReason: String
  ageGroupPk: Int
  billingFirstName: String
  billingLastName: String
  billingAddressStreet: String
  billingAddressCity: String
  billingAddressZip: String
  billingPhone: String
  billingEmail: String
  numPersons: Int
  name: String
  description: String

  """
  String value for ReservationType's ReservationState enum. Possible values are
  CREATED, CANCELLED, REQUIRES_HANDLING, WAITING_FOR_PAYMENT, CONFIRMED, DENIED.
  """
  state: String
  begin: DateTime
  end: DateTime
  bufferTimeBefore: Int
  bufferTimeAfter: Int
  purposePk: Int
  confirmedAt: DateTime

  """The unit price of this particular reservation"""
  unitPrice: Decimal

  """The value of the tax percentage for this particular reservation"""
  taxPercentageValue: Decimal

  """The price of this particular reservation including VAT"""
  price: Decimal

  """The price of this particular reservation excluding VAT"""
  priceNet: Decimal

  """The non subsidised price of this reservation including VAT"""
  nonSubsidisedPrice: Decimal

  """The non subsidised price of this reservation excluding VAT"""
  nonSubsidisedPriceNet: Decimal
  type: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  reservation: ReservationType
  clientMutationId: String
}

input ReservationWorkingMemoMutationInput {
  """Primary key of the reservation"""
  pk: Int

  """Working memo for staff users."""
  workingMemo: String
  clientMutationId: String
}

type ReservationWorkingMemoMutationPayload {
  """Primary key of the reservation"""
  pk: Int

  """Working memo for staff users."""
  workingMemo: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  clientMutationId: String
}

"""An enumeration."""
enum ReserveeType {
  """Yritys"""
  BUSINESS

  """Yhdistys"""
  NONPROFIT

  """Yksittäinen"""
  INDIVIDUAL
}

input ResourceCreateMutationInput {
  locationType: String

  """PK of the related space for this resource."""
  spacePk: Int

  """
  Buffer time while reservation unit is unreservable before the reservation.
  Dynamically calculated from spaces and resources.
  """
  bufferTimeBefore: Int

  """
  Buffer time while reservation unit is unreservable after the reservation.
  Dynamically calculated from spaces and resources.
  """
  bufferTimeAfter: Int
  nameFi: String
  nameEn: String
  nameSv: String
  clientMutationId: String
}

type ResourceCreateMutationPayload {
  pk: Int
  locationType: String

  """PK of the related space for this resource."""
  spacePk: Int

  """
  Buffer time while reservation unit is unreservable before the reservation.
  Dynamically calculated from spaces and resources.
  """
  bufferTimeBefore: Int

  """
  Buffer time while reservation unit is unreservable after the reservation.
  Dynamically calculated from spaces and resources.
  """
  bufferTimeAfter: Int
  nameFi: String
  nameEn: String
  nameSv: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  resource: ResourceType
  clientMutationId: String
}

input ResourceDeleteMutationInput {
  pk: Int!
  clientMutationId: String
}

type ResourceDeleteMutationPayload {
  deleted: Boolean
  errors: String
  clientMutationId: String
}

"""An enumeration."""
enum ResourceLocationType {
  FIXED
  MOVABLE
}

type ResourceType implements Node {
  locationType: ResourceLocationType
  nameFi: String
  nameEn: String
  nameSv: String
  space: SpaceType
  bufferTimeBefore: Duration
  bufferTimeAfter: Duration

  """The ID of the object"""
  id: ID!
  pk: Int
  building: [BuildingType]
}

type ResourceTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ResourceTypeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `ResourceType` and its cursor."""
type ResourceTypeEdge {
  """The item at the end of the edge"""
  node: ResourceType

  """A cursor for use in pagination"""
  cursor: String!
}

input ResourceUpdateMutationInput {
  pk: Int!
  locationType: String

  """PK of the related space for this resource."""
  spacePk: Int

  """
  Buffer time while reservation unit is unreservable before the reservation.
  Dynamically calculated from spaces and resources.
  """
  bufferTimeBefore: Int

  """
  Buffer time while reservation unit is unreservable after the reservation.
  Dynamically calculated from spaces and resources.
  """
  bufferTimeAfter: Int
  nameFi: String
  nameEn: String
  nameSv: String
  clientMutationId: String
}

type ResourceUpdateMutationPayload {
  pk: Int
  locationType: String

  """PK of the related space for this resource."""
  spacePk: Int

  """
  Buffer time while reservation unit is unreservable before the reservation.
  Dynamically calculated from spaces and resources.
  """
  bufferTimeBefore: Int

  """
  Buffer time while reservation unit is unreservable after the reservation.
  Dynamically calculated from spaces and resources.
  """
  bufferTimeAfter: Int
  nameFi: String
  nameEn: String
  nameSv: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  resource: ResourceType
  clientMutationId: String
}

type RoleType {
  code: String
  verboseName: String
  verboseNameFi: String
  verboseNameSv: String
  verboseNameEn: String
}

type ServiceSectorRolePermissionType {
  permission: String
}

type ServiceSectorRoleType implements Node {
  role: RoleType
  serviceSector: ServiceSectorType

  """The ID of the object"""
  id: ID!
  pk: Int
  permissions: [ServiceSectorRolePermissionType]
}

type ServiceSectorType implements Node {
  """The ID of the object"""
  id: ID!
  nameFi: String
  nameEn: String
  nameSv: String
  pk: Int
}

type ServiceSectorTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ServiceSectorTypeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `ServiceSectorType` and its cursor."""
type ServiceSectorTypeEdge {
  """The item at the end of the edge"""
  node: ServiceSectorType

  """A cursor for use in pagination"""
  cursor: String!
}

type ServiceType implements Node {
  nameFi: String
  nameEn: String
  nameSv: String
  serviceType: ServiceType!
  bufferTimeBefore: Duration
  bufferTimeAfter: Duration

  """The ID of the object"""
  id: ID!
  pk: Int
}

input SpaceCreateMutationInput {
  """PK of the parent space for this space."""
  parentPk: Int
  surfaceArea: Float
  maxPersons: Int
  code: String
  unitPk: Int
  nameFi: String!
  nameEn: String
  nameSv: String
  clientMutationId: String
}

type SpaceCreateMutationPayload {
  pk: Int

  """PK of the parent space for this space."""
  parentPk: Int
  surfaceArea: Float
  maxPersons: Int
  code: String
  unitPk: Int
  nameFi: String
  nameEn: String
  nameSv: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  space: SpaceType
  clientMutationId: String
}

input SpaceDeleteMutationInput {
  pk: Int!
  clientMutationId: String
}

type SpaceDeleteMutationPayload {
  deleted: Boolean
  errors: String
  clientMutationId: String
}

type SpaceType implements Node {
  nameFi: String
  nameEn: String
  nameSv: String
  surfaceArea: Int
  maxPersons: Int
  code: String!
  parent: SpaceType
  building: BuildingType
  unit: UnitByPkType

  """The ID of the object"""
  id: ID!
  pk: Int
  children: [SpaceType]
  resources: [ResourceType]
}

type SpaceTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [SpaceTypeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `SpaceType` and its cursor."""
type SpaceTypeEdge {
  """The item at the end of the edge"""
  node: SpaceType

  """A cursor for use in pagination"""
  cursor: String!
}

input SpaceUpdateMutationInput {
  pk: Int!

  """PK of the parent space for this space."""
  parentPk: Int
  surfaceArea: Float
  maxPersons: Int
  code: String
  unitPk: Int
  nameFi: String
  nameEn: String
  nameSv: String
  clientMutationId: String
}

type SpaceUpdateMutationPayload {
  pk: Int

  """PK of the parent space for this space."""
  parentPk: Int
  surfaceArea: Float
  maxPersons: Int
  code: String
  unitPk: Int
  nameFi: String
  nameEn: String
  nameSv: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  space: SpaceType
  clientMutationId: String
}

"""An enumeration."""
enum State {
  """Luotu"""
  CREATED

  """Peruttu"""
  CANCELLED

  """Vaatiiko käsittelyn"""
  REQUIRES_HANDLING

  """Odottaa maksua"""
  WAITING_FOR_PAYMENT

  """Vahvistettu"""
  CONFIRMED

  """Hylätty"""
  DENIED
}

"""An enumeration."""
enum Status {
  """mennyt"""
  PAST

  """aktiivinen"""
  ACTIVE

  """tuleva"""
  FUTURE
}

type SuitableTimeRangeNode implements Node {
  priority: Priority!
  dayOfTheWeek: Weekday!
  beginTime: Time!
  endTime: Time!
  applicationSection: ApplicationSectionNode!

  """The ID of the object"""
  id: ID!
  fulfilled: Boolean
  pk: Int
}

"""Ordering fields for the 'SuitableTimeRange' model."""
enum SuitableTimeRangeOrderingChoices {
  pkAsc
  pkDesc
}

input SuitableTimeRangeSerializerInput {
  pk: Int
  priority: Priority!
  dayOfTheWeek: Weekday!
  beginTime: Time!
  endTime: Time!
}

"""An enumeration."""
enum TargetGroup {
  """Sisäinen"""
  INTERNAL

  """Julkinen"""
  PUBLIC

  """Kaikki"""
  ALL
}

type TaxPercentageType implements Node {
  """The tax percentage for a price"""
  value: Decimal!

  """The ID of the object"""
  id: ID!
  pk: Int
}

type TaxPercentageTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [TaxPercentageTypeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `TaxPercentageType` and its cursor."""
type TaxPercentageTypeEdge {
  """The item at the end of the edge"""
  node: TaxPercentageType

  """A cursor for use in pagination"""
  cursor: String!
}

type TermsOfUseType implements Node {
  nameFi: String
  nameEn: String
  nameSv: String
  textFi: String
  textEn: String
  textSv: String
  termsType: TermsType!

  """The ID of the object"""
  id: ID!
  pk: String
}

type TermsOfUseTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [TermsOfUseTypeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `TermsOfUseType` and its cursor."""
type TermsOfUseTypeEdge {
  """The item at the end of the edge"""
  node: TermsOfUseType

  """A cursor for use in pagination"""
  cursor: String!
}

"""An enumeration."""
enum TermsType {
  """Yleiset ehdot"""
  GENERIC_TERMS

  """Maksuehdot"""
  PAYMENT_TERMS

  """Peruutusehdot"""
  CANCELLATION_TERMS

  """Toistuvan varauksen ehdot"""
  RECURRING_TERMS

  """Palvelualuekohtaiset ehdot"""
  SERVICE_TERMS

  """Hinnoitteluehdot"""
  PRICING_TERMS
}

"""Time scalar that can parse time-strings from database."""
scalar Time

input TimeSlotSerializerInput {
  begin: Time!
  end: Time!
}

type TimeSlotType {
  begin: TimeString!
  end: TimeString!
}

"""Time scalar that can parse time-strings from database."""
scalar TimeString

"""An enumeration."""
enum Type {
  """Normaali"""
  NORMAL

  """Estetty"""
  BLOCKED

  """Henkilökunta"""
  STAFF

  """Puolesta"""
  BEHALF
}

type UnitByPkType implements Node {
  tprekId: String
  nameFi: String
  nameEn: String
  nameSv: String
  descriptionFi: String
  descriptionEn: String
  descriptionSv: String
  shortDescriptionFi: String
  shortDescriptionEn: String
  shortDescriptionSv: String
  webPage: String!
  email: String!
  phone: String!

  """The ID of the object"""
  id: ID!
  pk: Int
  reservationUnits: [ReservationUnitType]
  spaces: [SpaceType]
  location: LocationType
  serviceSectors: [ServiceSectorType]
  paymentMerchant: PaymentMerchantType
}

type UnitGroupType implements Node {
  name: String!
  units: [UnitType]

  """The ID of the object"""
  id: ID!
  pk: Int
}

type UnitRolePermissionType {
  permission: String
}

type UnitRoleType implements Node {
  role: RoleType

  """The ID of the object"""
  id: ID!
  pk: Int
  units: [UnitType]
  unitGroups: [UnitGroupType]
  permissions: [UnitRolePermissionType]
}

type UnitType implements Node {
  tprekId: String
  nameFi: String
  nameEn: String
  nameSv: String
  descriptionFi: String
  descriptionEn: String
  descriptionSv: String
  shortDescriptionFi: String
  shortDescriptionEn: String
  shortDescriptionSv: String
  webPage: String!
  email: String!
  phone: String!
  paymentMerchant: PaymentMerchantType

  """The ID of the object"""
  id: ID!
  pk: Int
  reservationUnits: [ReservationUnitType]
  spaces: [SpaceType]
  location: LocationType
  serviceSectors: [ServiceSectorType]
}

type UnitTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [UnitTypeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `UnitType` and its cursor."""
type UnitTypeEdge {
  """The item at the end of the edge"""
  node: UnitType

  """A cursor for use in pagination"""
  cursor: String!
}

input UnitUpdateMutationInput {
  pk: Int!
  tprekId: String
  webPage: String
  email: String
  phone: String
  nameFi: String
  nameEn: String
  nameSv: String
  shortDescriptionFi: String
  shortDescriptionEn: String
  shortDescriptionSv: String
  descriptionFi: String
  descriptionEn: String
  descriptionSv: String
  clientMutationId: String
}

type UnitUpdateMutationPayload {
  pk: Int
  tprekId: String
  webPage: String
  email: String
  phone: String
  nameFi: String
  nameEn: String
  nameSv: String
  shortDescriptionFi: String
  shortDescriptionEn: String
  shortDescriptionSv: String
  descriptionFi: String
  descriptionEn: String
  descriptionSv: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  unit: UnitType
  clientMutationId: String
}

input UpdateAddressSerializerInput {
  pk: Int
  streetAddress: String
  streetAddressFi: String
  streetAddressEn: String
  streetAddressSv: String
  postCode: String
  city: String
  cityFi: String
  cityEn: String
  citySv: String
}

input UpdateApplicationSectionForApplicationSerializerInput {
  pk: Int
  name: String
  numPersons: Int
  reservationsBeginDate: Date
  reservationsEndDate: Date
  reservationMinDuration: Duration
  reservationMaxDuration: Duration
  appliedReservationsPerWeek: Int
  purpose: Int
  ageGroup: Int
  reservationUnitOptions: [UpdateReservationUnitOptionApplicantSerializerInput]
  suitableTimeRanges: [UpdateSuitableTimeRangeSerializerInput]
}

input UpdateOrganisationSerializerInput {
  pk: Int
  name: String
  nameFi: String
  nameEn: String
  nameSv: String
  identifier: String
  yearEstablished: Int
  address: UpdateAddressSerializerInput
  activeMembers: Int
  coreBusiness: String
  coreBusinessFi: String
  coreBusinessEn: String
  coreBusinessSv: String
  organisationType: OrganizationTypeChoice
  email: String
}

input UpdatePersonSerializerInput {
  pk: Int
  firstName: String
  lastName: String
  email: String
  phoneNumber: String
}

input UpdateReservationUnitOptionApplicantSerializerInput {
  pk: Int
  preferredOrder: Int
  reservationUnit: Int
}

input UpdateSuitableTimeRangeSerializerInput {
  pk: Int
  priority: Priority
  dayOfTheWeek: Weekday
  beginTime: Time
  endTime: Time
}

"""
Create scalar that ignores normal serialization/deserialization, since
that will be handled by the multipart request spec
"""
scalar Upload

type UserType implements Node {
  """
  Antaa käyttäjälle kaikki oikeudet ilman, että niitä täytyy erikseen luetella.
  """
  isSuperuser: Boolean!

  """
  Vaaditaan. Enintään 150 merkkiä. Vain kirjaimet, numerot ja @/./+/-/_ ovat sallittuja.
  """
  username: String!
  firstName: String!
  lastName: String!
  email: String!
  uuid: UUID!
  reservationNotification: String
  dateOfBirth: Date
  unitRoles: [UnitRoleType]
  serviceSectorRoles: [ServiceSectorRoleType]
  generalRoles: [GeneralRoleType]

  """The ID of the object"""
  id: ID!
  pk: Int
  isAdAuthenticated: Boolean
  isStronglyAuthenticated: Boolean
}

input UserUpdateMutationInput {
  pk: Int!

  """
  When reservation notification emails are sent. Possible values are: ALL, ONLY_HANDLING_REQUIRED, NONE.
  """
  reservationNotification: String
  clientMutationId: String
}

type UserUpdateMutationPayload {
  pk: Int

  """
  When reservation notification emails are sent. Possible values are: ALL, ONLY_HANDLING_REQUIRED, NONE.
  """
  reservationNotification: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  user: UserType
  clientMutationId: String
}

"""
Leverages the internal Python implementation of UUID (uuid.UUID) to provide native UUID objects
in fields, resolvers and input.
"""
scalar UUID

"""An enumeration."""
enum Weekday {
  MONDAY
  TUESDAY
  WEDNESDAY
  THURSDAY
  FRIDAY
  SATURDAY
  SUNDAY
}

