"""Exposes a URL that specifies the behaviour of this scalar."""
directive @specifiedBy(
  """The URL that specifies the behaviour of this scalar."""
  url: String!
) on SCALAR

type AbilityGroupNode implements Node {
  name: String!
  nameFi: String
  nameEn: String
  nameSv: String

  """The ID of the object"""
  id: ID!
  pk: Int
}

type AddressNode implements Node {
  streetAddress: String!
  streetAddressFi: String
  streetAddressEn: String
  streetAddressSv: String
  postCode: String!
  city: String!
  cityFi: String
  cityEn: String
  citySv: String

  """The ID of the object"""
  id: ID!
  pk: Int
}

input AddressSerializerInput {
  pk: Int
  streetAddress: String!
  streetAddressFi: String
  streetAddressEn: String
  streetAddressSv: String
  postCode: String!
  city: String!
  cityFi: String
  cityEn: String
  citySv: String
}

type AgeGroupNode implements Node {
  minimum: Int!
  maximum: Int

  """The ID of the object"""
  id: ID!
  pk: Int
}

type AgeGroupNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [AgeGroupNodeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `AgeGroupNode` and its cursor."""
type AgeGroupNodeEdge {
  """The item at the end of the edge"""
  node: AgeGroupNode

  """A cursor for use in pagination"""
  cursor: String!
}

input AllocatedTimeSlotCreateMutationInput {
  pk: Int
  dayOfTheWeek: Weekday!
  beginTime: Time!
  endTime: Time!
  reservationUnitOption: Int!
  force: Boolean
}

type AllocatedTimeSlotCreateMutationPayload {
  pk: Int
  dayOfTheWeek: Weekday
  beginTime: Time
  endTime: Time
  reservationUnitOption: Int
}

input AllocatedTimeSlotDeleteMutationInput {
  pk: ID!
}

type AllocatedTimeSlotDeleteMutationPayload {
  deleted: Boolean
}

type AllocatedTimeSlotNode implements Node {
  dayOfTheWeek: Weekday!
  beginTime: Time!
  endTime: Time!
  reservationUnitOption: ReservationUnitOptionNode!

  """The ID of the object"""
  id: ID!
  pk: Int
}

type AllocatedTimeSlotNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [AllocatedTimeSlotNodeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `AllocatedTimeSlotNode` and its cursor."""
type AllocatedTimeSlotNodeEdge {
  """The item at the end of the edge"""
  node: AllocatedTimeSlotNode

  """A cursor for use in pagination"""
  cursor: String!
}

"""Ordering fields for the 'AllocatedTimeSlot' model."""
enum AllocatedTimeSlotOrderingChoices {
  pkAsc
  pkDesc
  applicationSectionPkAsc
  applicationSectionPkDesc
  applicationPkAsc
  applicationPkDesc
  applicationSectionNameAsc
  applicationSectionNameDesc
  allocatedUnitNameFiAsc
  allocatedUnitNameFiDesc
  allocatedUnitNameEnAsc
  allocatedUnitNameEnDesc
  allocatedUnitNameSvAsc
  allocatedUnitNameSvDesc
  allocatedReservationUnitNameFiAsc
  allocatedReservationUnitNameFiDesc
  allocatedReservationUnitNameEnAsc
  allocatedReservationUnitNameEnDesc
  allocatedReservationUnitNameSvAsc
  allocatedReservationUnitNameSvDesc
  allocatedTimeOfWeekAsc
  allocatedTimeOfWeekDesc
  applicantAsc
  applicantDesc
  dayOfTheWeekAsc
  dayOfTheWeekDesc
  applicationStatusAsc
  applicationStatusDesc
  applicationSectionStatusAsc
  applicationSectionStatusDesc
}

"""An enumeration."""
enum ApplicantTypeChoice {
  INDIVIDUAL
  ASSOCIATION
  COMMUNITY
  COMPANY
}

input ApplicationCancelMutationInput {
  pk: Int!
}

type ApplicationCancelMutationPayload {
  pk: Int
}

input ApplicationCreateMutationInput {
  pk: Int
  applicantType: ApplicantTypeChoice
  cancelledDate: DateTime
  sentDate: DateTime
  additionalInformation: String
  applicationRound: Int!
  organisation: OrganisationSerializerInput
  contactPerson: PersonSerializerInput
  billingAddress: AddressSerializerInput
  homeCity: Int
  applicationSections: [ApplicationSectionForApplicationSerializerInput]
}

type ApplicationCreateMutationPayload {
  pk: Int
  applicantType: ApplicantTypeChoice
  createdDate: DateTime
  lastModifiedDate: DateTime
  cancelledDate: DateTime
  sentDate: DateTime
  additionalInformation: String
  applicationRound: Int
  organisation: OrganisationNode
  contactPerson: PersonNode
  billingAddress: AddressNode
  homeCity: Int
  applicationSections: [ApplicationSectionNode]
  status: Status
}

type ApplicationNode implements Node {
  applicantType: ApplicantTypeChoice
  createdDate: DateTime!
  lastModifiedDate: DateTime!
  cancelledDate: DateTime
  sentDate: DateTime
  additionalInformation: String
  workingMemo: String!
  applicationRound: ApplicationRoundNode!
  organisation: OrganisationNode
  contactPerson: PersonNode
  user: UserNode
  billingAddress: AddressNode
  homeCity: CityNode
  applicationSections(
    pk: [Int]
    name: String
    user: Int
    application: Int
    applicationRound: Int
    reservationUnit: [Int]
    unit: [Int]
    applicantType: [ApplicantTypeChoice]
    status: [ApplicationSectionStatusChoice]
    applicationStatus: [ApplicationStatusChoice]
    priority: [Priority]
    preferredOrder: [Int]
    includePreferredOrder10OrHigher: Boolean
    homeCity: [Int]
    ageGroup: [Int]
    purpose: [Int]
    textSearch: String

    """Järjestä"""
    orderBy: [ApplicationSectionOrderingChoices]
  ): [ApplicationSectionNode!]

  """The ID of the object"""
  id: ID!
  status: ApplicationStatusChoice
  pk: Int
}

type ApplicationNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ApplicationNodeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `ApplicationNode` and its cursor."""
type ApplicationNodeEdge {
  """The item at the end of the edge"""
  node: ApplicationNode

  """A cursor for use in pagination"""
  cursor: String!
}

"""Ordering fields for the 'Application' model."""
enum ApplicationOrderingChoices {
  pkAsc
  pkDesc
  applicantAsc
  applicantDesc
  applicantTypeAsc
  applicantTypeDesc
  preferredUnitNameFiAsc
  preferredUnitNameFiDesc
  preferredUnitNameEnAsc
  preferredUnitNameEnDesc
  preferredUnitNameSvAsc
  preferredUnitNameSvDesc
  statusAsc
  statusDesc
}

type ApplicationRoundNode implements Node {
  name: String!
  nameFi: String
  nameEn: String
  nameSv: String
  targetGroup: TargetGroup!
  criteria: String!
  criteriaFi: String
  criteriaEn: String
  criteriaSv: String
  applicationPeriodBegin: DateTime!
  applicationPeriodEnd: DateTime!
  reservationPeriodBegin: Date!
  reservationPeriodEnd: Date!
  publicDisplayBegin: DateTime!
  publicDisplayEnd: DateTime!
  handledDate: DateTime
  sentDate: DateTime
  reservationUnits(
    nameFi: String
    nameFi_Icontains: String
    nameFi_Istartswith: String
    nameSv: String
    nameSv_Icontains: String
    nameSv_Istartswith: String
    nameEn: String
    nameEn_Icontains: String
    nameEn_Istartswith: String
    descriptionFi: String
    descriptionFi_Icontains: String
    descriptionSv: String
    descriptionSv_Icontains: String
    descriptionEn: String
    descriptionEn_Icontains: String
    pk: [Int]
    unit: [Int]
    reservationUnitType: [Int]
    minPersonsGte: Decimal
    minPersonsLte: Decimal
    maxPersonsGte: Decimal
    maxPersonsLte: Decimal
    textSearch: String
    keywordGroups: [Int]
    purposes: [Int]
    qualifiers: [Int]
    equipments: [Int]
    isDraft: Boolean
    isVisible: Boolean
    applicationRound: [Int]
    surfaceAreaGte: Decimal
    surfaceAreaLte: Decimal
    rankGte: Decimal
    rankLte: Decimal
    typeRankGte: Decimal
    typeRankLte: Decimal
    reservationKind: String
    state: [String]
    reservationState: [String]
    onlyWithPermission: Boolean
    reservableDateStart: Date
    reservableDateEnd: Date
    reservableTimeStart: Time
    reservableTimeEnd: Time
    reservableMinimumDurationMinutes: Decimal
    showOnlyReservable: Boolean
    calculateFirstReservableTime: Boolean

    """Järjestä"""
    orderBy: [ReservationUnitOrderingChoices]
  ): [ReservationUnitNode!]!
  purposes(
    nameFi: String
    nameEn: String
    nameSv: String
    pk: [Int]

    """Järjestä"""
    orderBy: [ReservationPurposeOrderingChoices]
  ): [ReservationPurposeNode!]!
  serviceSector: ServiceSectorNode
  termsOfUse: TermsOfUseNode

  """The ID of the object"""
  id: ID!
  status: ApplicationRoundStatusChoice
  statusTimestamp: DateTime
  applicationsCount: Int
  reservationUnitCount: Int
  pk: Int
}

type ApplicationRoundNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ApplicationRoundNodeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `ApplicationRoundNode` and its cursor."""
type ApplicationRoundNodeEdge {
  """The item at the end of the edge"""
  node: ApplicationRoundNode

  """A cursor for use in pagination"""
  cursor: String!
}

"""Ordering fields for the 'ApplicationRound' model."""
enum ApplicationRoundOrderingChoices {
  pkAsc
  pkDesc
}

"""An enumeration."""
enum ApplicationRoundStatusChoice {
  UPCOMING
  OPEN
  IN_ALLOCATION
  HANDLED
  RESULTS_SENT
}

type ApplicationRoundTimeSlotNode implements Node {
  weekday: Int!
  closed: Boolean!
  reservableTimes: [TimeSlotType]

  """The ID of the object"""
  id: ID!
  pk: Int
}

input ApplicationRoundTimeSlotSerializerInput {
  weekday: Int!
  closed: Boolean
  reservableTimes: [TimeSlotSerializerInput]
}

input ApplicationSectionCreateMutationInput {
  pk: Int
  name: String!
  numPersons: Int!
  reservationsBeginDate: Date!
  reservationsEndDate: Date!
  reservationMinDuration: Duration!
  reservationMaxDuration: Duration!
  appliedReservationsPerWeek: Int!
  application: Int!
  purpose: Int
  ageGroup: Int
  reservationUnitOptions: [ReservationUnitOptionApplicantSerializerInput]!
  suitableTimeRanges: [SuitableTimeRangeSerializerInput]!
}

type ApplicationSectionCreateMutationPayload {
  pk: Int
  name: String
  numPersons: Int
  reservationsBeginDate: Date
  reservationsEndDate: Date
  reservationMinDuration: Duration
  reservationMaxDuration: Duration
  appliedReservationsPerWeek: Int
  application: Int
  purpose: Int
  ageGroup: Int
  reservationUnitOptions: [ReservationUnitOptionNode]
  suitableTimeRanges: [SuitableTimeRangeNode]
}

input ApplicationSectionDeleteMutationInput {
  pk: ID!
}

type ApplicationSectionDeleteMutationPayload {
  deleted: Boolean
}

input ApplicationSectionForApplicationSerializerInput {
  pk: Int
  name: String!
  numPersons: Int!
  reservationsBeginDate: Date!
  reservationsEndDate: Date!
  reservationMinDuration: Duration!
  reservationMaxDuration: Duration!
  appliedReservationsPerWeek: Int!
  purpose: Int
  ageGroup: Int
  reservationUnitOptions: [ReservationUnitOptionApplicantSerializerInput]!
  suitableTimeRanges: [SuitableTimeRangeSerializerInput]!
}

type ApplicationSectionNode implements Node {
  name: String!
  numPersons: Int!
  reservationsBeginDate: Date!
  reservationsEndDate: Date!
  reservationMinDuration: Duration!
  reservationMaxDuration: Duration!
  appliedReservationsPerWeek: Int!
  application: ApplicationNode!
  purpose: ReservationPurposeNode
  ageGroup: AgeGroupNode
  reservationUnitOptions(
    pk: [Int]
    preferredOrder: Int
    reservationUnit: [Int]

    """Järjestä"""
    orderBy: [ReservationUnitOptionOrderingChoices]
  ): [ReservationUnitOptionNode!]!
  suitableTimeRanges(
    pk: [Int]
    priority: [Priority]
    fulfilled: Boolean

    """Järjestä"""
    orderBy: [SuitableTimeRangeOrderingChoices]
  ): [SuitableTimeRangeNode!]!

  """The ID of the object"""
  id: ID!
  status: ApplicationSectionStatusChoice
  allocations: Int
  pk: Int
}

type ApplicationSectionNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ApplicationSectionNodeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `ApplicationSectionNode` and its cursor."""
type ApplicationSectionNodeEdge {
  """The item at the end of the edge"""
  node: ApplicationSectionNode

  """A cursor for use in pagination"""
  cursor: String!
}

"""Ordering fields for the 'ApplicationSection' model."""
enum ApplicationSectionOrderingChoices {
  pkAsc
  pkDesc
  applicationPkAsc
  applicationPkDesc
  applicantAsc
  applicantDesc
  nameAsc
  nameDesc
  statusAsc
  statusDesc
  applicationStatusAsc
  applicationStatusDesc
  preferredUnitNameFiAsc
  preferredUnitNameFiDesc
  preferredUnitNameEnAsc
  preferredUnitNameEnDesc
  preferredUnitNameSvAsc
  preferredUnitNameSvDesc
}

"""An enumeration."""
enum ApplicationSectionStatusChoice {
  UNALLOCATED
  IN_ALLOCATION
  HANDLED
  RESERVED
  FAILED
}

input ApplicationSectionUpdateMutationInput {
  pk: Int!
  name: String
  numPersons: Int
  reservationsBeginDate: Date
  reservationsEndDate: Date
  reservationMinDuration: Duration
  reservationMaxDuration: Duration
  appliedReservationsPerWeek: Int
  application: Int
  purpose: Int
  ageGroup: Int
  reservationUnitOptions: [UpdateReservationUnitOptionApplicantSerializerInput]
  suitableTimeRanges: [UpdateSuitableTimeRangeSerializerInput]
}

type ApplicationSectionUpdateMutationPayload {
  pk: Int
  name: String
  numPersons: Int
  reservationsBeginDate: Date
  reservationsEndDate: Date
  reservationMinDuration: Duration
  reservationMaxDuration: Duration
  appliedReservationsPerWeek: Int
  application: Int
  purpose: Int
  ageGroup: Int
  reservationUnitOptions: [ReservationUnitOptionNode]
  suitableTimeRanges: [SuitableTimeRangeNode]
}

input ApplicationSendMutationInput {
  pk: Int!
}

type ApplicationSendMutationPayload {
  pk: Int
}

"""An enumeration."""
enum ApplicationStatusChoice {
  DRAFT
  RECEIVED
  IN_ALLOCATION
  HANDLED
  RESULTS_SENT
  EXPIRED
  CANCELLED
}

input ApplicationUpdateMutationInput {
  pk: Int!
  applicantType: ApplicantTypeChoice
  cancelledDate: DateTime
  sentDate: DateTime
  additionalInformation: String
  applicationRound: Int
  organisation: UpdateOrganisationSerializerInput
  contactPerson: UpdatePersonSerializerInput
  billingAddress: UpdateAddressSerializerInput
  homeCity: Int
  applicationSections: [UpdateApplicationSectionForApplicationSerializerInput]
  workingMemo: String
}

type ApplicationUpdateMutationPayload {
  pk: Int
  applicantType: ApplicantTypeChoice
  createdDate: DateTime
  lastModifiedDate: DateTime
  cancelledDate: DateTime
  sentDate: DateTime
  additionalInformation: String
  applicationRound: Int
  organisation: OrganisationNode
  contactPerson: PersonNode
  billingAddress: AddressNode
  homeCity: Int
  applicationSections: [ApplicationSectionNode]
  status: Status
  workingMemo: String
}

"""An enumeration."""
enum Authentication {
  """Heikko"""
  WEAK

  """Vahva"""
  STRONG
}

input BannerNotificationCreateMutationInput {
  pk: Int
  name: String!
  message: String
  messageFi: String
  messageEn: String
  messageSv: String
  draft: Boolean
  level: BannerNotificationLevel!
  target: BannerNotificationTarget!
  activeFrom: DateTime
  activeUntil: DateTime
}

type BannerNotificationCreateMutationPayload {
  pk: Int
  name: String
  message: String
  messageFi: String
  messageEn: String
  messageSv: String
  draft: Boolean
  level: BannerNotificationLevel
  target: BannerNotificationTarget
  activeFrom: DateTime
  activeUntil: DateTime
}

input BannerNotificationDeleteMutationInput {
  pk: ID!
}

type BannerNotificationDeleteMutationPayload {
  deleted: Boolean
}

"""An enumeration."""
enum BannerNotificationLevel {
  """Poikkeus"""
  EXCEPTION

  """Varoitus"""
  WARNING

  """Normaali"""
  NORMAL
}

type BannerNotificationNode implements Node {
  name: String!
  message: String!
  messageFi: String
  messageEn: String
  messageSv: String
  draft: Boolean!
  level: BannerNotificationLevel!
  target: BannerNotificationTarget!
  activeFrom: DateTime
  activeUntil: DateTime

  """The ID of the object"""
  id: ID!
  state: BannerNotificationState
  pk: Int
}

type BannerNotificationNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [BannerNotificationNodeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `BannerNotificationNode` and its cursor."""
type BannerNotificationNodeEdge {
  """The item at the end of the edge"""
  node: BannerNotificationNode

  """A cursor for use in pagination"""
  cursor: String!
}

"""Ordering fields for the 'BannerNotification' model."""
enum BannerNotificationOrderingChoices {
  pkAsc
  pkDesc
  nameAsc
  nameDesc
  startsAsc
  startsDesc
  endsAsc
  endsDesc
  levelAsc
  levelDesc
  stateAsc
  stateDesc
  targetAsc
  targetDesc
}

"""An enumeration."""
enum BannerNotificationState {
  DRAFT
  SCHEDULED
  ACTIVE
}

"""An enumeration."""
enum BannerNotificationTarget {
  """Kaikki"""
  ALL

  """Henkilökunta"""
  STAFF

  """Käyttäjä"""
  USER
}

input BannerNotificationUpdateMutationInput {
  pk: Int!
  name: String
  message: String
  messageFi: String
  messageEn: String
  messageSv: String
  draft: Boolean
  level: BannerNotificationLevel
  target: BannerNotificationTarget
  activeFrom: DateTime
  activeUntil: DateTime
}

type BannerNotificationUpdateMutationPayload {
  pk: Int
  name: String
  message: String
  messageFi: String
  messageEn: String
  messageSv: String
  draft: Boolean
  level: BannerNotificationLevel
  target: BannerNotificationTarget
  activeFrom: DateTime
  activeUntil: DateTime
}

type CityNode implements Node {
  name: String!
  nameFi: String
  nameEn: String
  nameSv: String
  municipalityCode: String!

  """The ID of the object"""
  id: ID!
  pk: Int
}

type CityNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [CityNodeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `CityNode` and its cursor."""
type CityNodeEdge {
  """The item at the end of the edge"""
  node: CityNode

  """A cursor for use in pagination"""
  cursor: String!
}

"""An enumeration."""
enum CustomerTypeChoice {
  BUSINESS
  NONPROFIT
  INDIVIDUAL
}

"""
The `Date` scalar type represents a Date
value as specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar Date

"""
The `DateTime` scalar type represents a DateTime
value as specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar DateTime

"""The `Decimal` scalar type represents a python Decimal."""
scalar Decimal

"""Debugging information for the current query."""
type DjangoDebug {
  """Executed SQL queries for this API query."""
  sql: [DjangoDebugSQL]

  """Raise exceptions for this API query."""
  exceptions: [DjangoDebugException]
}

"""Represents a single exception raised."""
type DjangoDebugException {
  """The class of the exception"""
  excType: String!

  """The message of the exception"""
  message: String!

  """The stack trace"""
  stack: String!
}

"""Represents a single database query made to a Django managed DB."""
type DjangoDebugSQL {
  """The type of database being used (e.g. postrgesql, mysql, sqlite)."""
  vendor: String!

  """The Django database alias (e.g. 'default')."""
  alias: String!

  """The actual SQL sent to this database."""
  sql: String

  """Duration of this database query in seconds."""
  duration: Float!

  """The raw SQL of this query, without params."""
  rawSql: String!

  """JSON encoded database query parameters."""
  params: String!

  """Start time of this database query."""
  startTime: Float!

  """Stop time of this database query."""
  stopTime: Float!

  """Whether this database query took more than 10 seconds."""
  isSlow: Boolean!

  """Whether this database query was a SELECT."""
  isSelect: Boolean!

  """Postgres transaction ID if available."""
  transId: String

  """Postgres transaction status if available."""
  transStatus: String

  """Postgres isolation level if available."""
  isoLevel: String

  """Postgres connection encoding if available."""
  encoding: String
}

"""Represents a DurationField value as an integer in seconds."""
scalar Duration

input EquipmentCategoryCreateMutationInput {
  pk: Int
  name: String!
  nameFi: String
  nameEn: String
  nameSv: String
}

type EquipmentCategoryCreateMutationPayload {
  pk: Int
  name: String
  nameFi: String
  nameEn: String
  nameSv: String
}

input EquipmentCategoryDeleteMutationInput {
  pk: ID!
}

type EquipmentCategoryDeleteMutationPayload {
  deleted: Boolean
}

type EquipmentCategoryNode implements Node {
  name: String!
  nameFi: String
  nameEn: String
  nameSv: String

  """The ID of the object"""
  id: ID!
  pk: Int
}

type EquipmentCategoryNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [EquipmentCategoryNodeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `EquipmentCategoryNode` and its cursor."""
type EquipmentCategoryNodeEdge {
  """The item at the end of the edge"""
  node: EquipmentCategoryNode

  """A cursor for use in pagination"""
  cursor: String!
}

"""Ordering fields for the 'EquipmentCategory' model."""
enum EquipmentCategoryOrderingChoices {
  pkAsc
  pkDesc
}

input EquipmentCategoryUpdateMutationInput {
  pk: Int!
  name: String
  nameFi: String
  nameEn: String
  nameSv: String
}

type EquipmentCategoryUpdateMutationPayload {
  pk: Int
  name: String
  nameFi: String
  nameEn: String
  nameSv: String
}

input EquipmentCreateMutationInput {
  pk: Int
  name: String!
  nameFi: String
  nameEn: String
  nameSv: String
  category: Int!
}

type EquipmentCreateMutationPayload {
  pk: Int
  name: String
  nameFi: String
  nameEn: String
  nameSv: String
  category: Int
}

input EquipmentDeleteMutationInput {
  pk: ID!
}

type EquipmentDeleteMutationPayload {
  deleted: Boolean
}

type EquipmentNode implements Node {
  name: String!
  nameFi: String
  nameEn: String
  nameSv: String
  category: EquipmentCategoryNode!

  """The ID of the object"""
  id: ID!
  pk: Int
}

type EquipmentNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [EquipmentNodeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `EquipmentNode` and its cursor."""
type EquipmentNodeEdge {
  """The item at the end of the edge"""
  node: EquipmentNode

  """A cursor for use in pagination"""
  cursor: String!
}

"""Ordering fields for the 'Equipment' model."""
enum EquipmentOrderingChoices {
  nameAsc
  nameDesc
  categoryRankAsc
  categoryRankDesc
}

input EquipmentUpdateMutationInput {
  pk: Int!
  name: String
  nameFi: String
  nameEn: String
  nameSv: String
  category: Int
}

type EquipmentUpdateMutationPayload {
  pk: Int
  name: String
  nameFi: String
  nameEn: String
  nameSv: String
  category: Int
}

"""An enumeration."""
enum GeneralPermissionChoices {
  CAN_MANAGE_GENERAL_ROLES
  CAN_MANAGE_SERVICE_SECTOR_ROLES
  CAN_MANAGE_UNIT_ROLES
  CAN_MANAGE_RESERVATION_UNITS
  CAN_MANAGE_PURPOSES
  CAN_MANAGE_RESERVATION_PURPOSES
  CAN_MANAGE_AGE_GROUPS
  CAN_MANAGE_ABILITY_GROUPS
  CAN_MANAGE_RESERVATION_UNIT_TYPES
  CAN_MANAGE_EQUIPMENT_CATEGORIES
  CAN_MANAGE_EQUIPMENT
  CAN_MANAGE_RESERVATIONS
  CAN_VIEW_RESERVATIONS
  CAN_MANAGE_RESOURCES
  CAN_MANAGE_SPACES
  CAN_HANDLE_APPLICATIONS
  CAN_VALIDATE_APPLICATIONS
  CAN_ALLOCATE_APPLICATIONS
  CAN_MANAGE_APPLICATION_ROUNDS
  CAN_VIEW_USERS
  CAN_COMMENT_RESERVATIONS
  CAN_CREATE_STAFF_RESERVATIONS
  CAN_MANAGE_UNITS
  CAN_MANAGE_NOTIFICATIONS
}

type GeneralRoleChoiceNode implements Node {
  code: String!
  verboseName: String!
  verboseNameFi: String
  verboseNameEn: String
  verboseNameSv: String
  permissions: [GeneralRolePermissionNode!]

  """The ID of the object"""
  id: ID!
}

type GeneralRoleNode implements Node {
  role: GeneralRoleChoiceNode!

  """The ID of the object"""
  id: ID!
  pk: Int
}

type GeneralRolePermissionNode implements Node {
  permission: GeneralPermissionChoices

  """The ID of the object"""
  id: ID!
  pk: Int
}

"""An enumeration."""
enum ImageType {
  """Pääkuva"""
  MAIN

  """Pohjapiirros"""
  GROUND_PLAN

  """Kartta"""
  MAP

  """Muu"""
  OTHER
}

type KeywordCategoryNode implements Node {
  name: String!
  nameFi: String
  nameEn: String
  nameSv: String
  keywordGroups(
    nameFi: String
    nameSv: String
    nameEn: String
    pk: [Int]

    """Järjestä"""
    orderBy: [KeywordGroupOrderingChoices]
  ): [KeywordGroupNode!]!

  """The ID of the object"""
  id: ID!
  pk: Int
}

type KeywordCategoryNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [KeywordCategoryNodeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `KeywordCategoryNode` and its cursor."""
type KeywordCategoryNodeEdge {
  """The item at the end of the edge"""
  node: KeywordCategoryNode

  """A cursor for use in pagination"""
  cursor: String!
}

type KeywordGroupNode implements Node {
  name: String!
  nameFi: String
  nameEn: String
  nameSv: String
  keywords(
    nameFi: String
    nameSv: String
    nameEn: String
    pk: [Int]

    """Järjestä"""
    orderBy: [KeywordOrderingChoices]
  ): [KeywordNode!]!

  """The ID of the object"""
  id: ID!
  pk: Int
}

type KeywordGroupNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [KeywordGroupNodeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `KeywordGroupNode` and its cursor."""
type KeywordGroupNodeEdge {
  """The item at the end of the edge"""
  node: KeywordGroupNode

  """A cursor for use in pagination"""
  cursor: String!
}

"""Ordering fields for the 'KeywordGroup' model."""
enum KeywordGroupOrderingChoices {
  pkAsc
  pkDesc
}

type KeywordNode implements Node {
  name: String!
  nameFi: String
  nameEn: String
  nameSv: String

  """The ID of the object"""
  id: ID!
  pk: Int
}

type KeywordNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [KeywordNodeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `KeywordNode` and its cursor."""
type KeywordNodeEdge {
  """The item at the end of the edge"""
  node: KeywordNode

  """A cursor for use in pagination"""
  cursor: String!
}

"""Ordering fields for the 'Keyword' model."""
enum KeywordOrderingChoices {
  pkAsc
  pkDesc
}

type LocationNode implements Node {
  addressStreet: String!
  addressStreetFi: String
  addressStreetEn: String
  addressStreetSv: String
  addressZip: String!
  addressCity: String!
  addressCityFi: String
  addressCityEn: String
  addressCitySv: String

  """The ID of the object"""
  id: ID!
  longitude: String
  latitude: String
  pk: Int
}

"""An enumeration."""
enum LocationType {
  """Kiinteä"""
  FIXED

  """Siirrettävä"""
  MOVABLE
}

type Mutation {
  createApplication(input: ApplicationCreateMutationInput!): ApplicationCreateMutationPayload
  updateApplication(input: ApplicationUpdateMutationInput!): ApplicationUpdateMutationPayload
  sendApplication(input: ApplicationSendMutationInput!): ApplicationSendMutationPayload
  cancelApplication(input: ApplicationCancelMutationInput!): ApplicationCancelMutationPayload
  createApplicationSection(input: ApplicationSectionCreateMutationInput!): ApplicationSectionCreateMutationPayload
  updateApplicationSection(input: ApplicationSectionUpdateMutationInput!): ApplicationSectionUpdateMutationPayload
  deleteApplicationSection(input: ApplicationSectionDeleteMutationInput!): ApplicationSectionDeleteMutationPayload
  createAllocatedTimeslot(input: AllocatedTimeSlotCreateMutationInput!): AllocatedTimeSlotCreateMutationPayload
  deleteAllocatedTimeslot(input: AllocatedTimeSlotDeleteMutationInput!): AllocatedTimeSlotDeleteMutationPayload
  updateReservationUnitOption(input: ReservationUnitOptionUpdateMutationInput!): ReservationUnitOptionUpdateMutationPayload
  updateUnit(input: UnitUpdateMutationInput!): UnitUpdateMutationPayload
  createResource(input: ResourceCreateMutationInput!): ResourceCreateMutationPayload
  updateResource(input: ResourceUpdateMutationInput!): ResourceUpdateMutationPayload
  deleteResource(input: ResourceDeleteMutationInput!): ResourceDeleteMutationPayload
  createSpace(input: SpaceCreateMutationInput!): SpaceCreateMutationPayload
  updateSpace(input: SpaceUpdateMutationInput!): SpaceUpdateMutationPayload
  deleteSpace(input: SpaceDeleteMutationInput!): SpaceDeleteMutationPayload
  createEquipment(input: EquipmentCreateMutationInput!): EquipmentCreateMutationPayload
  updateEquipment(input: EquipmentUpdateMutationInput!): EquipmentUpdateMutationPayload
  deleteEquipment(input: EquipmentDeleteMutationInput!): EquipmentDeleteMutationPayload
  createEquipmentCategory(input: EquipmentCategoryCreateMutationInput!): EquipmentCategoryCreateMutationPayload
  updateEquipmentCategory(input: EquipmentCategoryUpdateMutationInput!): EquipmentCategoryUpdateMutationPayload
  deleteEquipmentCategory(input: EquipmentCategoryDeleteMutationInput!): EquipmentCategoryDeleteMutationPayload
  createReservationUnit(input: ReservationUnitCreateMutationInput!): ReservationUnitCreateMutationPayload
  updateReservationUnit(input: ReservationUnitUpdateMutationInput!): ReservationUnitUpdateMutationPayload
  createReservationUnitImage(input: ReservationUnitImageCreateMutationInput!): ReservationUnitImageCreateMutationPayload
  updateReservationUnitImage(input: ReservationUnitImageUpdateMutationInput!): ReservationUnitImageUpdateMutationPayload
  deleteReservationUnitImage(input: ReservationUnitImageDeleteMutationInput!): ReservationUnitImageDeleteMutationPayload
  createPurpose(input: PurposeCreateMutationInput!): PurposeCreateMutationPayload
  updatePurpose(input: PurposeUpdateMutationInput!): PurposeUpdateMutationPayload
  createReservation(input: ReservationCreateMutationInput!): ReservationCreateMutationPayload
  createStaffReservation(input: ReservationStaffCreateMutationInput!): ReservationStaffCreateMutationPayload
  updateReservation(input: ReservationUpdateMutationInput!): ReservationUpdateMutationPayload
  confirmReservation(input: ReservationConfirmMutationInput!): ReservationConfirmMutationPayload
  cancelReservation(input: ReservationCancellationMutationInput!): ReservationCancellationMutationPayload
  denyReservation(input: ReservationDenyMutationInput!): ReservationDenyMutationPayload
  deleteReservation(input: ReservationDeleteMutationInput!): ReservationDeleteMutationPayload
  approveReservation(input: ReservationApproveMutationInput!): ReservationApproveMutationPayload
  refundReservation(input: ReservationRefundMutationInput!): ReservationRefundMutationPayload
  requireHandlingForReservation(input: ReservationRequiresHandlingMutationInput!): ReservationRequiresHandlingMutationPayload
  updateReservationWorkingMemo(input: ReservationWorkingMemoMutationInput!): ReservationWorkingMemoMutationPayload
  adjustReservationTime(input: ReservationAdjustTimeMutationInput!): ReservationAdjustTimeMutationPayload
  staffAdjustReservationTime(input: ReservationStaffAdjustTimeMutationInput!): ReservationStaffAdjustTimeMutationPayload
  staffReservationModify(input: ReservationStaffModifyMutationInput!): ReservationStaffModifyMutationPayload
  createRecurringReservation(input: RecurringReservationCreateMutationInput!): RecurringReservationCreateMutationPayload
  updateRecurringReservation(input: RecurringReservationUpdateMutationInput!): RecurringReservationUpdateMutationPayload
  refreshOrder(input: RefreshOrderMutationInput!): RefreshOrderMutationPayload
  updateUser(input: UserUpdateMutationInput!): UserUpdateMutationPayload
  createBannerNotification(input: BannerNotificationCreateMutationInput!): BannerNotificationCreateMutationPayload
  updateBannerNotification(input: BannerNotificationUpdateMutationInput!): BannerNotificationUpdateMutationPayload
  deleteBannerNotification(input: BannerNotificationDeleteMutationInput!): BannerNotificationDeleteMutationPayload
}

"""An object with an ID"""
interface Node {
  """The ID of the object"""
  id: ID!
}

"""An enumeration."""
enum OrderStatus {
  DRAFT
  EXPIRED
  CANCELLED
  PAID
  PAID_MANUALLY
  REFUNDED
}

type OrganisationNode implements Node {
  name: String!
  nameFi: String
  nameEn: String
  nameSv: String
  email: String!
  identifier: String
  yearEstablished: Int
  activeMembers: Int
  coreBusiness: String!
  coreBusinessFi: String
  coreBusinessEn: String
  coreBusinessSv: String
  organisationType: OrganizationTypeChoice!
  address: AddressNode

  """The ID of the object"""
  id: ID!
  pk: Int
}

input OrganisationSerializerInput {
  pk: Int
  name: String!
  nameFi: String
  nameEn: String
  nameSv: String
  identifier: String
  yearEstablished: Int
  address: AddressSerializerInput!
  activeMembers: Int
  coreBusiness: String
  coreBusinessFi: String
  coreBusinessEn: String
  coreBusinessSv: String
  organisationType: OrganizationTypeChoice
  email: String
}

"""An enumeration."""
enum OrganizationTypeChoice {
  """Yritys"""
  COMPANY

  """Rekisteröity yhdistys"""
  REGISTERED_ASSOCIATION

  """Julkinen yhdistys"""
  PUBLIC_ASSOCIATION

  """Rekisteröimätön yhdistys"""
  UNREGISTERED_ASSOCIATION

  """Kuntakonsortio"""
  MUNICIPALITY_CONSORTIUM

  """Uskonnollinen yhteisö"""
  RELIGIOUS_COMMUNITY
}

"""
The Relay compliant `PageInfo` type, containing data necessary to paginate this connection.
"""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String

  """When paginating forwards, the cursor to continue."""
  endCursor: String
}

type PaymentMerchantNode implements Node {
  name: String!

  """The ID of the object"""
  id: ID!
  pk: UUID
}

type PaymentOrderNode implements Node {
  paymentType: PaymentType!
  status: OrderStatus
  processedAt: DateTime
  checkoutUrl: String
  receiptUrl: String

  """The ID of the object"""
  id: ID!
  orderUuid: UUID
  refundUuid: UUID
  reservationPk: String
  expiresInMinutes: Int
}

type PaymentProductNode implements Node {
  """Merchant used for payments"""
  merchant: PaymentMerchantNode

  """The ID of the object"""
  id: ID!
  pk: UUID
}

"""An enumeration."""
enum PaymentType {
  """Paikan päällä"""
  ON_SITE

  """Verkossa"""
  ONLINE

  """Lasku"""
  INVOICE
}

type PersonNode implements Node {
  firstName: String!
  lastName: String!
  email: String
  phoneNumber: String

  """The ID of the object"""
  id: ID!
  pk: Int
}

input PersonSerializerInput {
  pk: Int
  firstName: String!
  lastName: String!
  email: String
  phoneNumber: String
}

"""An enumeration."""
enum PriceUnit {
  """per 15 minuuttia"""
  PER_15_MINS

  """per 30 minuuttia"""
  PER_30_MINS

  """per tunti"""
  PER_HOUR

  """per puolipäivää"""
  PER_HALF_DAY

  """per päivä"""
  PER_DAY

  """per viikko"""
  PER_WEEK

  """per kerta"""
  FIXED
}

"""An enumeration."""
enum PricingType {
  """Paid"""
  PAID

  """Free"""
  FREE
}

"""An enumeration."""
enum Priority {
  PRIMARY
  SECONDARY
}

input PurposeCreateMutationInput {
  pk: Int
  name: String!
  nameFi: String
  nameEn: String
  nameSv: String
}

type PurposeCreateMutationPayload {
  pk: Int
  name: String
  nameFi: String
  nameEn: String
  nameSv: String
}

type PurposeNode implements Node {
  name: String!
  nameFi: String
  nameEn: String
  nameSv: String

  """Järjestysnumero, jota käytetään rajapinnan järjestämisessä."""
  rank: Int

  """The ID of the object"""
  id: ID!
  imageUrl: String
  smallUrl: String
  pk: Int
}

type PurposeNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [PurposeNodeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `PurposeNode` and its cursor."""
type PurposeNodeEdge {
  """The item at the end of the edge"""
  node: PurposeNode

  """A cursor for use in pagination"""
  cursor: String!
}

"""Ordering fields for the 'Purpose' model."""
enum PurposeOrderingChoices {
  rankAsc
  rankDesc
  nameFiAsc
  nameFiDesc
  nameEnAsc
  nameEnDesc
  nameSvAsc
  nameSvDesc
}

input PurposeUpdateMutationInput {
  pk: Int!
  name: String
  nameFi: String
  nameEn: String
  nameSv: String
}

type PurposeUpdateMutationPayload {
  pk: Int
  name: String
  nameFi: String
  nameEn: String
  nameSv: String
}

type QualifierNode implements Node {
  name: String!
  nameFi: String
  nameEn: String
  nameSv: String

  """The ID of the object"""
  id: ID!
  pk: Int
}

type QualifierNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [QualifierNodeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `QualifierNode` and its cursor."""
type QualifierNodeEdge {
  """The item at the end of the edge"""
  node: QualifierNode

  """A cursor for use in pagination"""
  cursor: String!
}

"""Ordering fields for the 'Qualifier' model."""
enum QualifierOrderingChoices {
  pkAsc
  pkDesc
}

type Query {
  applicationRound(
    """The ID of the object"""
    id: ID!
  ): ApplicationRoundNode
  applicationRounds(
    first: Int
    last: Int
    offset: Int
    after: String
    before: String
    pk: [Int]
    name: String
    active: Boolean

    """Järjestä"""
    orderBy: [ApplicationRoundOrderingChoices]
  ): ApplicationRoundNodeConnection
  application(
    """The ID of the object"""
    id: ID!
  ): ApplicationNode
  applications(
    first: Int
    last: Int
    offset: Int
    after: String
    before: String
    pk: [Int]
    applicationRound: Int
    user: Int
    applicantType: [ApplicantTypeChoice]
    status: [ApplicationStatusChoice]
    unit: [Int]
    textSearch: String

    """Järjestä"""
    orderBy: [ApplicationOrderingChoices]
  ): ApplicationNodeConnection
  applicationSections(
    first: Int
    last: Int
    offset: Int
    after: String
    before: String
    pk: [Int]
    name: String
    user: Int
    application: Int
    applicationRound: Int
    reservationUnit: [Int]
    unit: [Int]
    applicantType: [ApplicantTypeChoice]
    status: [ApplicationSectionStatusChoice]
    applicationStatus: [ApplicationStatusChoice]
    priority: [Priority]
    preferredOrder: [Int]
    includePreferredOrder10OrHigher: Boolean
    homeCity: [Int]
    ageGroup: [Int]
    purpose: [Int]
    textSearch: String

    """Järjestä"""
    orderBy: [ApplicationSectionOrderingChoices]
  ): ApplicationSectionNodeConnection
  allocatedTimeSlots(
    first: Int
    last: Int
    offset: Int
    after: String
    before: String
    pk: [Int]
    dayOfTheWeek: [Weekday]
    applicationRound: Int
    applicationSectionStatus: [ApplicationSectionStatusChoice]
    applicantType: [ApplicantTypeChoice]
    allocatedUnit: [Int]
    allocatedReservationUnit: [Int]
    textSearch: String

    """Järjestä"""
    orderBy: [AllocatedTimeSlotOrderingChoices]
  ): AllocatedTimeSlotNodeConnection

  """
  Return all allocations that affect allocations for given reservation unit
  (through space hierarchy or common resource) during the given time period.
  """
  affectingAllocatedTimeSlots(reservationUnit: Int!, beginDate: Date!, endDate: Date!): [AllocatedTimeSlotNode!]
  unit(
    """The ID of the object"""
    id: ID!
  ): UnitNode
  units(
    first: Int
    last: Int
    offset: Int
    after: String
    before: String
    nameFi: String
    nameFi_Icontains: String
    nameFi_Istartswith: String
    nameSv: String
    nameSv_Icontains: String
    nameSv_Istartswith: String
    nameEn: String
    nameEn_Icontains: String
    nameEn_Istartswith: String
    pk: [Int]
    serviceSector: Decimal
    onlyWithPermission: Boolean
    publishedReservationUnits: Boolean
    ownReservations: Boolean
    onlyDirectBookable: Boolean
    onlySeasonalBookable: Boolean

    """Järjestä"""
    orderBy: [UnitOrderingChoices]
  ): UnitNodeConnection
  resource(
    """The ID of the object"""
    id: ID!
  ): ResourceNode
  resources(
    first: Int
    last: Int
    offset: Int
    after: String
    before: String
    nameFi: String
    nameFi_Icontains: String
    nameFi_Istartswith: String
    nameSv: String
    nameSv_Icontains: String
    nameSv_Istartswith: String
    nameEn: String
    nameEn_Icontains: String
    nameEn_Istartswith: String
    pk: [Int]
    onlyWithPermission: Boolean

    """Järjestä"""
    orderBy: [ResourceOrderingChoices]
  ): ResourceNodeConnection
  space(
    """The ID of the object"""
    id: ID!
  ): SpaceNode
  spaces(
    first: Int
    last: Int
    offset: Int
    after: String
    before: String
    nameFi: String
    nameFi_Icontains: String
    nameFi_Istartswith: String
    nameSv: String
    nameSv_Icontains: String
    nameSv_Istartswith: String
    nameEn: String
    nameEn_Icontains: String
    nameEn_Istartswith: String
    pk: [Int]
    onlyWithPermission: Boolean

    """Järjestä"""
    orderBy: [SpaceOrderingChoices]
  ): SpaceNodeConnection
  equipment(
    """The ID of the object"""
    id: ID!
  ): EquipmentNode
  equipments(
    first: Int
    last: Int
    offset: Int
    after: String
    before: String
    name: String
    name_Icontains: String
    name_Istartswith: String
    nameFi: String
    nameFi_Icontains: String
    nameFi_Istartswith: String
    nameSv: String
    nameSv_Icontains: String
    nameSv_Istartswith: String
    nameEn: String
    nameEn_Icontains: String
    nameEn_Istartswith: String
    pk: [Int]
    rankGte: Decimal
    rankLte: Decimal

    """Järjestä"""
    orderBy: [EquipmentOrderingChoices]
  ): EquipmentNodeConnection
  equipmentCategory(
    """The ID of the object"""
    id: ID!
  ): EquipmentCategoryNode
  equipmentCategories(
    first: Int
    last: Int
    offset: Int
    after: String
    before: String
    pk: [Int]

    """Järjestä"""
    orderBy: [EquipmentCategoryOrderingChoices]
  ): EquipmentCategoryNodeConnection
  reservationUnit(
    """The ID of the object"""
    id: ID!
  ): ReservationUnitNode
  reservationUnits(
    first: Int
    last: Int
    offset: Int
    after: String
    before: String
    nameFi: String
    nameFi_Icontains: String
    nameFi_Istartswith: String
    nameSv: String
    nameSv_Icontains: String
    nameSv_Istartswith: String
    nameEn: String
    nameEn_Icontains: String
    nameEn_Istartswith: String
    descriptionFi: String
    descriptionFi_Icontains: String
    descriptionSv: String
    descriptionSv_Icontains: String
    descriptionEn: String
    descriptionEn_Icontains: String
    pk: [Int]
    unit: [Int]
    reservationUnitType: [Int]
    minPersonsGte: Decimal
    minPersonsLte: Decimal
    maxPersonsGte: Decimal
    maxPersonsLte: Decimal
    textSearch: String
    keywordGroups: [Int]
    purposes: [Int]
    qualifiers: [Int]
    equipments: [Int]
    isDraft: Boolean
    isVisible: Boolean
    applicationRound: [Int]
    surfaceAreaGte: Decimal
    surfaceAreaLte: Decimal
    rankGte: Decimal
    rankLte: Decimal
    typeRankGte: Decimal
    typeRankLte: Decimal
    reservationKind: String
    state: [String]
    reservationState: [String]
    onlyWithPermission: Boolean
    reservableDateStart: Date
    reservableDateEnd: Date
    reservableTimeStart: Time
    reservableTimeEnd: Time
    reservableMinimumDurationMinutes: Decimal
    showOnlyReservable: Boolean
    calculateFirstReservableTime: Boolean

    """Järjestä"""
    orderBy: [ReservationUnitOrderingChoices]
  ): ReservationUnitNodeConnection
  reservationUnitTypes(
    first: Int
    last: Int
    offset: Int
    after: String
    before: String
    nameFi: String
    nameFi_Icontains: String
    nameFi_Istartswith: String
    nameSv: String
    nameSv_Icontains: String
    nameSv_Istartswith: String
    nameEn: String
    nameEn_Icontains: String
    nameEn_Istartswith: String
    pk: [Int]

    """Järjestä"""
    orderBy: [ReservationUnitTypeOrderingChoices]
  ): ReservationUnitTypeNodeConnection
  reservationUnitCancellationRules(
    first: Int
    last: Int
    offset: Int
    after: String
    before: String
    name: String
    pk: [Int]

    """Järjestä"""
    orderBy: [ReservationUnitCancellationRuleOrderingChoices]
  ): ReservationUnitCancellationRuleNodeConnection
  taxPercentages(
    first: Int
    last: Int
    offset: Int
    after: String
    before: String
    value: Decimal
    pk: [Int]

    """Järjestä"""
    orderBy: [TaxPercentageOrderingChoices]
  ): TaxPercentageNodeConnection
  metadataSets(first: Int, last: Int, offset: Int, after: String, before: String): ReservationMetadataSetNodeConnection
  purposes(
    first: Int
    last: Int
    offset: Int
    after: String
    before: String
    nameFi: String
    nameEn: String
    nameSv: String
    pk: [Int]

    """Järjestä"""
    orderBy: [PurposeOrderingChoices]
  ): PurposeNodeConnection
  qualifiers(
    first: Int
    last: Int
    offset: Int
    after: String
    before: String
    nameFi: String
    nameEn: String
    nameSv: String
    pk: [Int]

    """Järjestä"""
    orderBy: [QualifierOrderingChoices]
  ): QualifierNodeConnection
  keywordCategories(
    first: Int
    last: Int
    offset: Int
    after: String
    before: String
    nameFi: String
    nameSv: String
    nameEn: String
    pk: [Int]

    """Järjestä"""
    orderBy: [KeywordGroupOrderingChoices]
  ): KeywordCategoryNodeConnection
  keywordGroups(
    first: Int
    last: Int
    offset: Int
    after: String
    before: String
    nameFi: String
    nameSv: String
    nameEn: String
    pk: [Int]

    """Järjestä"""
    orderBy: [KeywordGroupOrderingChoices]
  ): KeywordGroupNodeConnection
  keywords(
    first: Int
    last: Int
    offset: Int
    after: String
    before: String
    nameFi: String
    nameSv: String
    nameEn: String
    pk: [Int]

    """Järjestä"""
    orderBy: [KeywordOrderingChoices]
  ): KeywordNodeConnection
  reservation(
    """The ID of the object"""
    id: ID!
  ): ReservationNode
  reservations(
    first: Int
    last: Int
    offset: Int
    after: String
    before: String
    state: [String]
    begin: DateTime
    begin_Gte: DateTime
    begin_Lte: DateTime
    beginDate: Date
    endDate: Date
    onlyWithPermission: Boolean
    onlyWithHandlingPermission: Boolean

    """
    PaymentOrder's statuses; DRAFT, EXPIRED, CANCELLED, PAID, PAID_MANUALLY, REFUNDED
    """
    orderStatus: [String]
    priceGte: Decimal
    priceLte: Decimal
    recurringReservation: ID
    requested: Boolean
    reservationUnit: [ID]
    reservationType: [String]
    reservationUnitNameFi: String
    reservationUnitNameEn: String
    reservationUnitNameSv: String
    reservationUnitType: [ID]
    unit: [ID]
    user: ID
    textSearch: String

    """Järjestä"""
    orderBy: [ReservationOrderingChoices]
  ): ReservationNodeConnection

  """
  Find all reservations that affect other reservations through the space hierarchy or a common resource.
  """
  affectingReservations(
    """
    Reservations should contain at least one reservation unit that belongs to any of these units.
    """
    forUnits: [Int] = []

    """Reservations should contain at least one these reservation units."""
    forReservationUnits: [Int] = []
    state: [String]
    begin: DateTime
    begin_Gte: DateTime
    begin_Lte: DateTime
    beginDate: Date
    endDate: Date
    onlyWithPermission: Boolean
    onlyWithHandlingPermission: Boolean

    """
    PaymentOrder's statuses; DRAFT, EXPIRED, CANCELLED, PAID, PAID_MANUALLY, REFUNDED
    """
    orderStatus: [String]
    priceGte: Decimal
    priceLte: Decimal
    recurringReservation: ID
    requested: Boolean
    reservationUnit: [ID]
    reservationType: [String]
    reservationUnitNameFi: String
    reservationUnitNameEn: String
    reservationUnitNameSv: String
    reservationUnitType: [ID]
    unit: [ID]
    user: ID
    textSearch: String

    """Järjestä"""
    orderBy: [ReservationOrderingChoices]
  ): [ReservationNode!]
  recurringReservation(
    """The ID of the object"""
    id: ID!
  ): RecurringReservationNode
  recurringReservations(
    first: Int
    last: Int
    offset: Int
    after: String
    before: String
    name: String
    beginDate: Date
    endDate: Date
    beginTime: Time
    endTime: Time
    user: ID
    reservationUnitNameFi: String
    reservationUnitNameEn: String
    reservationUnitNameSv: String
    unit: [ID]
    reservationUnit: [ID]
    reservationUnitType: [ID]

    """Järjestä"""
    orderBy: [RecurringReservationOrderingChoices]
  ): RecurringReservationNodeConnection
  reservationCancelReasons(
    first: Int
    last: Int
    offset: Int
    after: String
    before: String
    name: String
    pk: [Int]

    """Järjestä"""
    orderBy: [ReservationPurposeOrderingChoices]
  ): ReservationCancelReasonNodeConnection
  reservationDenyReasons(
    first: Int
    last: Int
    offset: Int
    after: String
    before: String
    reason: String
    pk: [Int]

    """Järjestä"""
    orderBy: [ReservationDenyReasonOrderingChoices]
  ): ReservationDenyReasonNodeConnection
  reservationPurposes(
    first: Int
    last: Int
    offset: Int
    after: String
    before: String
    nameFi: String
    nameEn: String
    nameSv: String
    pk: [Int]

    """Järjestä"""
    orderBy: [ReservationPurposeOrderingChoices]
  ): ReservationPurposeNodeConnection
  ageGroups(first: Int, last: Int, offset: Int, after: String, before: String): AgeGroupNodeConnection
  cities(first: Int, last: Int, offset: Int, after: String, before: String): CityNodeConnection
  order(orderUuid: String!): PaymentOrderNode
  user(
    """The ID of the object"""
    id: ID!
  ): UserNode
  currentUser: UserNode
  termsOfUse(
    first: Int
    last: Int
    offset: Int
    after: String
    before: String
    pk: [String]
    termsType: TermsType

    """Järjestä"""
    orderBy: [TermsOfUseOrderingChoices]
  ): TermsOfUseNodeConnection
  bannerNotification(
    """The ID of the object"""
    id: ID!
  ): BannerNotificationNode
  bannerNotifications(
    first: Int
    last: Int
    offset: Int
    after: String
    before: String
    name: String
    target: BannerNotificationTarget
    isActive: Boolean
    isVisible: Boolean

    """Järjestä"""
    orderBy: [BannerNotificationOrderingChoices]
  ): BannerNotificationNodeConnection
  serviceSectors(first: Int, last: Int, offset: Int, after: String, before: String): ServiceSectorNodeConnection
  _debug: DjangoDebug
}

input RecurringReservationCreateMutationInput {
  pk: Int
  user: Int
  name: String
  description: String
  reservationUnit: Int!
  ageGroup: Int
  abilityGroup: Int
  recurrenceInDays: Int
  weekdays: [Int]
  beginTime: Time
  endTime: Time
  beginDate: Date
  endDate: Date
}

type RecurringReservationCreateMutationPayload {
  pk: Int
  user: Int
  name: String
  description: String
  reservationUnit: Int
  ageGroup: Int
  abilityGroup: Int
  recurrenceInDays: Int
  weekdays: [Int]
  beginTime: Time
  endTime: Time
  beginDate: Date
  endDate: Date
}

type RecurringReservationNode implements Node {
  name: String!
  description: String!
  user: UserNode
  beginDate: Date
  beginTime: Time
  endDate: Date
  endTime: Time
  reservationUnit: ReservationUnitNode!
  recurrenceInDays: Int
  weekdays: [Int]
  ageGroup: AgeGroupNode
  abilityGroup: AbilityGroupNode
  created: DateTime!
  reservations(
    state: [String]
    begin: DateTime
    begin_Gte: DateTime
    begin_Lte: DateTime
    beginDate: Date
    endDate: Date
    onlyWithPermission: Boolean
    onlyWithHandlingPermission: Boolean

    """
    PaymentOrder's statuses; DRAFT, EXPIRED, CANCELLED, PAID, PAID_MANUALLY, REFUNDED
    """
    orderStatus: [String]
    priceGte: Decimal
    priceLte: Decimal
    recurringReservation: ID
    requested: Boolean
    reservationUnit: [ID]
    reservationType: [String]
    reservationUnitNameFi: String
    reservationUnitNameEn: String
    reservationUnitNameSv: String
    reservationUnitType: [ID]
    unit: [ID]
    user: ID
    textSearch: String

    """Järjestä"""
    orderBy: [ReservationOrderingChoices]
  ): [ReservationNode!]!

  """The ID of the object"""
  id: ID!
  pk: Int
}

type RecurringReservationNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [RecurringReservationNodeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `RecurringReservationNode` and its cursor."""
type RecurringReservationNodeEdge {
  """The item at the end of the edge"""
  node: RecurringReservationNode

  """A cursor for use in pagination"""
  cursor: String!
}

"""Ordering fields for the 'RecurringReservation' model."""
enum RecurringReservationOrderingChoices {
  pkAsc
  pkDesc
  nameAsc
  nameDesc
  createdAsc
  createdDesc
  beginDateAsc
  beginDateDesc
  beginTimeAsc
  beginTimeDesc
  endDateAsc
  endDateDesc
  endTimeAsc
  endTimeDesc
  reservationUnitNameFiAsc
  reservationUnitNameFiDesc
  reservationUnitNameEnAsc
  reservationUnitNameEnDesc
  reservationUnitNameSvAsc
  reservationUnitNameSvDesc
  unitNameFiAsc
  unitNameFiDesc
  unitNameEnAsc
  unitNameEnDesc
  unitNameSvAsc
  unitNameSvDesc
}

input RecurringReservationUpdateMutationInput {
  pk: Int!
  user: Int
  name: String
  description: String
  reservationUnit: Int
  ageGroup: Int
  abilityGroup: Int
  recurrenceInDays: Int
  weekdays: [Int]
  beginTime: Time
  endTime: Time
  beginDate: Date
  endDate: Date
}

type RecurringReservationUpdateMutationPayload {
  pk: Int
  user: Int
  name: String
  description: String
  reservationUnit: Int
  ageGroup: Int
  abilityGroup: Int
  recurrenceInDays: Int
  weekdays: [Int]
  beginTime: Time
  endTime: Time
  beginDate: Date
  endDate: Date
}

input RefreshOrderMutationInput {
  orderUuid: String!
}

type RefreshOrderMutationPayload {
  orderUuid: String
  status: String
  reservationPk: Int
}

type ReservableTimeSpanType {
  startDatetime: DateTime
  endDatetime: DateTime
}

input ReservationAdjustTimeMutationInput {
  pk: Int!
  begin: DateTime
  end: DateTime
  state: State
}

type ReservationAdjustTimeMutationPayload {
  pk: Int
  begin: DateTime
  end: DateTime
  state: State
}

input ReservationApproveMutationInput {
  pk: Int

  """Additional information for approval."""
  handlingDetails: String!
  price: Float!
  priceNet: Float!
}

type ReservationApproveMutationPayload {
  pk: Int
  state: State

  """Additional information for approval."""
  handlingDetails: String
  handledAt: DateTime
  price: Float
  priceNet: Float
}

input ReservationCancellationMutationInput {
  pk: Int!

  """Primary key for the pre-defined cancel reason."""
  cancelReasonPk: Int!

  """Additional information for the cancellation."""
  cancelDetails: String
}

type ReservationCancellationMutationPayload {
  pk: Int

  """Primary key for the pre-defined cancel reason."""
  cancelReasonPk: Int

  """Additional information for the cancellation."""
  cancelDetails: String
  state: State
}

type ReservationCancelReasonNode implements Node {
  reason: String!
  reasonFi: String
  reasonEn: String
  reasonSv: String

  """The ID of the object"""
  id: ID!
  pk: Int
}

type ReservationCancelReasonNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ReservationCancelReasonNodeEdge]!
  totalCount: Int
}

"""
A Relay edge containing a `ReservationCancelReasonNode` and its cursor.
"""
type ReservationCancelReasonNodeEdge {
  """The item at the end of the edge"""
  node: ReservationCancelReasonNode

  """A cursor for use in pagination"""
  cursor: String!
}

input ReservationConfirmMutationInput {
  """Type of the payment. Possible values are ONLINE, INVOICE, ON_SITE."""
  paymentType: String
  pk: Int!
}

type ReservationConfirmMutationPayload {
  pk: Int
  reserveeFirstName: String
  reserveeLastName: String
  reserveePhone: String
  reserveeOrganisationName: String
  reserveeAddressStreet: String
  reserveeAddressCity: String
  reserveeAddressZip: String
  reserveeEmail: String
  reserveeType: String
  reserveeId: String
  reserveeIsUnregisteredAssociation: Boolean
  reserveeLanguage: String
  homeCityPk: Int
  applyingForFreeOfCharge: Boolean
  freeOfChargeReason: String
  ageGroupPk: Int
  billingFirstName: String
  billingLastName: String
  billingAddressStreet: String
  billingAddressCity: String
  billingAddressZip: String
  billingPhone: String
  billingEmail: String
  numPersons: Int
  name: String
  description: String

  """
  String value for ReservationType's ReservationState enum. Possible values are
  CREATED, CANCELLED, REQUIRES_HANDLING, WAITING_FOR_PAYMENT, CONFIRMED, DENIED.
  """
  state: String
  begin: DateTime
  end: DateTime
  bufferTimeBefore: Int
  bufferTimeAfter: Int
  purposePk: Int
  confirmedAt: DateTime
  unitPrice: Decimal
  taxPercentageValue: Decimal
  price: Decimal
  priceNet: Decimal
  nonSubsidisedPrice: Decimal
  nonSubsidisedPriceNet: Decimal
  type: String
  order: PaymentOrderNode
}

input ReservationCreateMutationInput {
  pk: Int
  reserveeFirstName: String
  reserveeLastName: String
  reserveePhone: String
  reserveeOrganisationName: String
  reserveeAddressStreet: String
  reserveeAddressCity: String
  reserveeAddressZip: String
  reserveeEmail: String
  reserveeType: String
  reserveeId: String
  reserveeIsUnregisteredAssociation: Boolean
  reserveeLanguage: String
  homeCityPk: Int
  applyingForFreeOfCharge: Boolean
  freeOfChargeReason: String
  ageGroupPk: Int
  billingFirstName: String
  billingLastName: String
  billingAddressStreet: String
  billingAddressCity: String
  billingAddressZip: String
  billingPhone: String
  billingEmail: String
  numPersons: Int
  name: String
  description: String
  begin: DateTime!
  end: DateTime!
  bufferTimeBefore: Int
  bufferTimeAfter: Int
  reservationUnitPks: [Int]!
  purposePk: Int
  type: String
}

type ReservationCreateMutationPayload {
  pk: Int
  reserveeFirstName: String
  reserveeLastName: String
  reserveePhone: String
  reserveeOrganisationName: String
  reserveeAddressStreet: String
  reserveeAddressCity: String
  reserveeAddressZip: String
  reserveeEmail: String
  reserveeType: String
  reserveeId: String
  reserveeIsUnregisteredAssociation: Boolean
  reserveeLanguage: String
  homeCityPk: Int
  applyingForFreeOfCharge: Boolean
  freeOfChargeReason: String
  ageGroupPk: Int
  billingFirstName: String
  billingLastName: String
  billingAddressStreet: String
  billingAddressCity: String
  billingAddressZip: String
  billingPhone: String
  billingEmail: String
  numPersons: Int
  name: String
  description: String
  state: String
  begin: DateTime
  end: DateTime
  bufferTimeBefore: Int
  bufferTimeAfter: Int
  purposePk: Int
  confirmedAt: DateTime
  unitPrice: Decimal
  taxPercentageValue: Decimal
  price: Decimal
  priceNet: Decimal
  nonSubsidisedPrice: Decimal
  nonSubsidisedPriceNet: Decimal
  type: String
}

input ReservationDeleteMutationInput {
  pk: ID!
}

type ReservationDeleteMutationPayload {
  deleted: Boolean
}

input ReservationDenyMutationInput {
  pk: Int

  """Additional information for denying."""
  handlingDetails: String

  """Primary key for the pre-defined deny reason."""
  denyReasonPk: Int!
}

type ReservationDenyMutationPayload {
  pk: Int
  state: State

  """Additional information for denying."""
  handlingDetails: String
  handledAt: DateTime

  """Primary key for the pre-defined deny reason."""
  denyReasonPk: Int
}

type ReservationDenyReasonNode implements Node {
  reason: String!
  reasonFi: String
  reasonEn: String
  reasonSv: String

  """The ID of the object"""
  id: ID!
  pk: Int
}

type ReservationDenyReasonNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ReservationDenyReasonNodeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `ReservationDenyReasonNode` and its cursor."""
type ReservationDenyReasonNodeEdge {
  """The item at the end of the edge"""
  node: ReservationDenyReasonNode

  """A cursor for use in pagination"""
  cursor: String!
}

"""Ordering fields for the 'ReservationDenyReason' model."""
enum ReservationDenyReasonOrderingChoices {
  pkAsc
  pkDesc
}

"""An enumeration."""
enum ReservationKind {
  """Direct"""
  DIRECT

  """Season"""
  SEASON

  """Direct And Season"""
  DIRECT_AND_SEASON
}

type ReservationMetadataFieldNode implements Node {
  fieldName: String!

  """The ID of the object"""
  id: ID!
  pk: Int
}

type ReservationMetadataSetNode implements Node {
  name: String!
  supportedFields: [ReservationMetadataFieldNode!]!
  requiredFields: [ReservationMetadataFieldNode!]!

  """The ID of the object"""
  id: ID!
  pk: Int
}

type ReservationMetadataSetNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ReservationMetadataSetNodeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `ReservationMetadataSetNode` and its cursor."""
type ReservationMetadataSetNodeEdge {
  """The item at the end of the edge"""
  node: ReservationMetadataSetNode

  """A cursor for use in pagination"""
  cursor: String!
}

type ReservationNode implements Node {
  name: String
  description: String
  numPersons: Int
  state: State!
  type: ReservationTypeChoice
  cancelDetails: String
  handlingDetails: String
  workingMemo: String
  begin: DateTime!
  end: DateTime!
  bufferTimeBefore: Duration!
  bufferTimeAfter: Duration!
  handledAt: DateTime
  createdAt: DateTime
  price: Decimal
  priceNet: Decimal
  unitPrice: Decimal
  taxPercentageValue: Decimal
  applyingForFreeOfCharge: Boolean
  freeOfChargeReason: String
  reserveeId: String
  reserveeFirstName: String
  reserveeLastName: String
  reserveeEmail: String
  reserveePhone: String
  reserveeOrganisationName: String
  reserveeAddressStreet: String
  reserveeAddressCity: String
  reserveeAddressZip: String
  reserveeIsUnregisteredAssociation: Boolean
  reserveeType: CustomerTypeChoice
  billingFirstName: String
  billingLastName: String
  billingEmail: String
  billingPhone: String
  billingAddressStreet: String
  billingAddressCity: String
  billingAddressZip: String
  reservationUnit(
    nameFi: String
    nameFi_Icontains: String
    nameFi_Istartswith: String
    nameSv: String
    nameSv_Icontains: String
    nameSv_Istartswith: String
    nameEn: String
    nameEn_Icontains: String
    nameEn_Istartswith: String
    descriptionFi: String
    descriptionFi_Icontains: String
    descriptionSv: String
    descriptionSv_Icontains: String
    descriptionEn: String
    descriptionEn_Icontains: String
    pk: [Int]
    unit: [Int]
    reservationUnitType: [Int]
    minPersonsGte: Decimal
    minPersonsLte: Decimal
    maxPersonsGte: Decimal
    maxPersonsLte: Decimal
    textSearch: String
    keywordGroups: [Int]
    purposes: [Int]
    qualifiers: [Int]
    equipments: [Int]
    isDraft: Boolean
    isVisible: Boolean
    applicationRound: [Int]
    surfaceAreaGte: Decimal
    surfaceAreaLte: Decimal
    rankGte: Decimal
    rankLte: Decimal
    typeRankGte: Decimal
    typeRankLte: Decimal
    reservationKind: String
    state: [String]
    reservationState: [String]
    onlyWithPermission: Boolean
    reservableDateStart: Date
    reservableDateEnd: Date
    reservableTimeStart: Time
    reservableTimeEnd: Time
    reservableMinimumDurationMinutes: Decimal
    showOnlyReservable: Boolean
    calculateFirstReservableTime: Boolean

    """Järjestä"""
    orderBy: [ReservationUnitOrderingChoices]
  ): [ReservationUnitNode!]
  user: UserNode
  recurringReservation: RecurringReservationNode
  denyReason: ReservationDenyReasonNode
  cancelReason: ReservationCancelReasonNode
  purpose: ReservationPurposeNode
  homeCity: CityNode
  ageGroup: AgeGroupNode

  """The ID of the object"""
  id: ID!
  order: PaymentOrderNode
  reserveeName: String
  isBlocked: Boolean
  isHandled: Boolean
  staffEvent: Boolean @deprecated(reason: "Please refer to type.")
  calendarUrl: String

  """
  Which reservation units' reserveability is affected by this reservation?
  """
  affectedReservationUnits: [Int]
  pk: Int
}

type ReservationNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ReservationNodeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `ReservationNode` and its cursor."""
type ReservationNodeEdge {
  """The item at the end of the edge"""
  node: ReservationNode

  """A cursor for use in pagination"""
  cursor: String!
}

"""An enumeration."""
enum ReservationNotification {
  """All"""
  ALL

  """Only Handling Required"""
  ONLY_HANDLING_REQUIRED

  """None"""
  NONE
}

"""Ordering fields for the 'Reservation' model."""
enum ReservationOrderingChoices {
  pkAsc
  pkDesc
  nameAsc
  nameDesc
  beginAsc
  beginDesc
  endAsc
  endDesc
  createdAtAsc
  createdAtDesc
  stateAsc
  stateDesc
  priceAsc
  priceDesc
  reservationUnitNameFiAsc
  reservationUnitNameFiDesc
  reservationUnitNameEnAsc
  reservationUnitNameEnDesc
  reservationUnitNameSvAsc
  reservationUnitNameSvDesc
  unitNameFiAsc
  unitNameFiDesc
  unitNameEnAsc
  unitNameEnDesc
  unitNameSvAsc
  unitNameSvDesc
  reserveeNameAsc
  reserveeNameDesc
  orderStatusAsc
  orderStatusDesc
}

type ReservationPurposeNode implements Node {
  name: String!
  nameFi: String
  nameEn: String
  nameSv: String

  """The ID of the object"""
  id: ID!
  pk: Int
}

type ReservationPurposeNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ReservationPurposeNodeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `ReservationPurposeNode` and its cursor."""
type ReservationPurposeNodeEdge {
  """The item at the end of the edge"""
  node: ReservationPurposeNode

  """A cursor for use in pagination"""
  cursor: String!
}

"""Ordering fields for the 'ReservationPurpose' model."""
enum ReservationPurposeOrderingChoices {
  pkAsc
  pkDesc
}

input ReservationRefundMutationInput {
  pk: Int
}

type ReservationRefundMutationPayload {
  pk: Int
}

input ReservationRequiresHandlingMutationInput {
  pk: Int
}

type ReservationRequiresHandlingMutationPayload {
  pk: Int
  state: State
}

input ReservationStaffAdjustTimeMutationInput {
  pk: Int!
  begin: DateTime
  end: DateTime
  state: State

  """
  Can be a number of seconds or timespan in format HH:MM:SS. Null/undefined
  value means buffer from reservation unit is used.
  """
  bufferTimeBefore: String

  """
  Can be a number of seconds or timespan in format HH:MM:SS. Null/undefined
  value means buffer from reservation unit is used.
  """
  bufferTimeAfter: String
}

type ReservationStaffAdjustTimeMutationPayload {
  pk: Int
  begin: DateTime
  end: DateTime
  state: State

  """
  Can be a number of seconds or timespan in format HH:MM:SS. Null/undefined
  value means buffer from reservation unit is used.
  """
  bufferTimeBefore: String

  """
  Can be a number of seconds or timespan in format HH:MM:SS. Null/undefined
  value means buffer from reservation unit is used.
  """
  bufferTimeAfter: String
}

input ReservationStaffCreateMutationInput {
  pk: Int
  reserveeFirstName: String
  reserveeLastName: String
  reserveePhone: String
  reserveeOrganisationName: String
  reserveeAddressStreet: String
  reserveeAddressCity: String
  reserveeAddressZip: String
  reserveeEmail: String
  reserveeType: String
  reserveeId: String
  reserveeIsUnregisteredAssociation: Boolean
  reserveeLanguage: String
  billingFirstName: String
  billingLastName: String
  billingAddressStreet: String
  billingAddressCity: String
  billingAddressZip: String
  billingPhone: String
  billingEmail: String
  homeCityPk: Int
  applyingForFreeOfCharge: Boolean
  freeOfChargeReason: String
  ageGroupPk: Int
  numPersons: Int
  name: String
  description: String
  begin: DateTime!
  end: DateTime!

  """
  Can be a number of seconds or timespan in format HH:MM:SS. Null/undefined
  value means buffer from reservation unit is used.
  """
  bufferTimeBefore: String

  """
  Can be a number of seconds or timespan in format HH:MM:SS. Null/undefined
  value means buffer from reservation unit is used.
  """
  bufferTimeAfter: String
  reservationUnitPks: [Int]!
  purposePk: Int
  unitPrice: Decimal
  type: String!
  workingMemo: String
  recurringReservationPk: Int
}

type ReservationStaffCreateMutationPayload {
  pk: Int
  reserveeFirstName: String
  reserveeLastName: String
  reserveePhone: String
  reserveeOrganisationName: String
  reserveeAddressStreet: String
  reserveeAddressCity: String
  reserveeAddressZip: String
  reserveeEmail: String
  reserveeType: String
  reserveeId: String
  reserveeIsUnregisteredAssociation: Boolean
  reserveeLanguage: String
  billingFirstName: String
  billingLastName: String
  billingAddressStreet: String
  billingAddressCity: String
  billingAddressZip: String
  billingPhone: String
  billingEmail: String
  homeCityPk: Int
  applyingForFreeOfCharge: Boolean
  freeOfChargeReason: String
  ageGroupPk: Int
  numPersons: Int
  name: String
  description: String
  state: State
  begin: DateTime
  end: DateTime

  """
  Can be a number of seconds or timespan in format HH:MM:SS. Null/undefined
  value means buffer from reservation unit is used.
  """
  bufferTimeBefore: String

  """
  Can be a number of seconds or timespan in format HH:MM:SS. Null/undefined
  value means buffer from reservation unit is used.
  """
  bufferTimeAfter: String
  reservationUnitPks: [Int]
  purposePk: Int
  confirmedAt: DateTime
  handledAt: DateTime
  unitPrice: Decimal
  type: String
  workingMemo: String
  recurringReservationPk: Int
}

input ReservationStaffModifyMutationInput {
  pk: Int!
  reserveeFirstName: String
  reserveeLastName: String
  reserveePhone: String
  reserveeOrganisationName: String
  reserveeAddressStreet: String
  reserveeAddressCity: String
  reserveeAddressZip: String
  reserveeEmail: String
  reserveeType: String
  reserveeId: String
  reserveeIsUnregisteredAssociation: Boolean
  reserveeLanguage: String
  homeCityPk: Int
  applyingForFreeOfCharge: Boolean
  freeOfChargeReason: String
  ageGroupPk: Int
  billingFirstName: String
  billingLastName: String
  billingAddressStreet: String
  billingAddressCity: String
  billingAddressZip: String
  billingPhone: String
  billingEmail: String
  numPersons: Int
  name: String
  description: String

  """
  String value for ReservationType's ReservationState enum. Possible values are
  CREATED, CANCELLED, REQUIRES_HANDLING, WAITING_FOR_PAYMENT, CONFIRMED, DENIED.
  """
  state: String
  reservationUnitPks: [Int]
  purposePk: Int
  type: String
}

type ReservationStaffModifyMutationPayload {
  pk: Int
  reserveeFirstName: String
  reserveeLastName: String
  reserveePhone: String
  reserveeOrganisationName: String
  reserveeAddressStreet: String
  reserveeAddressCity: String
  reserveeAddressZip: String
  reserveeEmail: String
  reserveeType: String
  reserveeId: String
  reserveeIsUnregisteredAssociation: Boolean
  reserveeLanguage: String
  homeCityPk: Int
  applyingForFreeOfCharge: Boolean
  freeOfChargeReason: String
  ageGroupPk: Int
  billingFirstName: String
  billingLastName: String
  billingAddressStreet: String
  billingAddressCity: String
  billingAddressZip: String
  billingPhone: String
  billingEmail: String
  numPersons: Int
  name: String
  description: String

  """
  String value for ReservationType's ReservationState enum. Possible values are
  CREATED, CANCELLED, REQUIRES_HANDLING, WAITING_FOR_PAYMENT, CONFIRMED, DENIED.
  """
  state: String
  begin: DateTime
  end: DateTime
  bufferTimeBefore: Int
  bufferTimeAfter: Int
  purposePk: Int
  confirmedAt: DateTime
  unitPrice: Decimal
  taxPercentageValue: Decimal
  price: Decimal
  priceNet: Decimal
  nonSubsidisedPrice: Decimal
  nonSubsidisedPriceNet: Decimal
  type: String
}

"""An enumeration."""
enum ReservationStartInterval {
  """15 minuuttia"""
  INTERVAL_15_MINS

  """30 minuuttia"""
  INTERVAL_30_MINS

  """60 minuuttia"""
  INTERVAL_60_MINS

  """90 minuuttia"""
  INTERVAL_90_MINS

  """2 tuntia"""
  INTERVAL_120_MINS

  """3 tuntia"""
  INTERVAL_180_MINS

  """4 tuntia"""
  INTERVAL_240_MINS

  """5 tuntia"""
  INTERVAL_300_MINS

  """6 tuntia"""
  INTERVAL_360_MINS

  """7 tuntia"""
  INTERVAL_420_MINS
}

"""An enumeration."""
enum ReservationState {
  SCHEDULED_RESERVATION
  SCHEDULED_PERIOD
  RESERVABLE
  SCHEDULED_CLOSING
  RESERVATION_CLOSED
}

"""An enumeration."""
enum ReservationTypeChoice {
  NORMAL
  BLOCKED
  STAFF
  BEHALF
}

type ReservationUnitCancellationRuleNode implements Node {
  name: String!
  nameFi: String
  nameEn: String
  nameSv: String

  """
  Seconds before reservations related to this cancellation rule can be cancelled without handling.
  """
  canBeCancelledTimeBefore: Duration
  needsHandling: Boolean!

  """The ID of the object"""
  id: ID!
  pk: Int
}

type ReservationUnitCancellationRuleNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ReservationUnitCancellationRuleNodeEdge]!
  totalCount: Int
}

"""
A Relay edge containing a `ReservationUnitCancellationRuleNode` and its cursor.
"""
type ReservationUnitCancellationRuleNodeEdge {
  """The item at the end of the edge"""
  node: ReservationUnitCancellationRuleNode

  """A cursor for use in pagination"""
  cursor: String!
}

"""Ordering fields for the 'ReservationUnitCancellationRule' model."""
enum ReservationUnitCancellationRuleOrderingChoices {
  pkAsc
  pkDesc
}

input ReservationUnitCreateMutationInput {
  pk: Int
  name: String!
  nameFi: String
  nameEn: String
  nameSv: String
  description: String
  descriptionFi: String
  descriptionEn: String
  descriptionSv: String
  termsOfUse: String
  termsOfUseFi: String
  termsOfUseEn: String
  termsOfUseSv: String
  contactInformation: String
  reservationPendingInstructions: String
  reservationPendingInstructionsFi: String
  reservationPendingInstructionsEn: String
  reservationPendingInstructionsSv: String
  reservationConfirmedInstructions: String
  reservationConfirmedInstructionsFi: String
  reservationConfirmedInstructionsEn: String
  reservationConfirmedInstructionsSv: String
  reservationCancelledInstructions: String
  reservationCancelledInstructionsFi: String
  reservationCancelledInstructionsEn: String
  reservationCancelledInstructionsSv: String
  surfaceArea: Int
  minPersons: Int
  maxPersons: Int
  maxReservationsPerUser: Int
  reservationsMinDaysBefore: Int
  reservationsMaxDaysBefore: Int
  reservationBegins: DateTime
  reservationEnds: DateTime
  publishBegins: DateTime
  publishEnds: DateTime
  minReservationDuration: Duration
  maxReservationDuration: Duration
  bufferTimeBefore: Duration
  bufferTimeAfter: Duration
  isDraft: Boolean
  isArchived: Boolean
  requireIntroduction: Boolean
  requireReservationHandling: Boolean
  reservationBlockWholeDay: Boolean
  canApplyFreeOfCharge: Boolean
  allowReservationsWithoutOpeningHours: Boolean
  authentication: Authentication
  reservationStartInterval: ReservationStartInterval
  reservationKind: ReservationKind
  unit: Int
  reservationUnitType: Int
  cancellationRule: Int
  metadataSet: Int
  cancellationTerms: String
  serviceSpecificTerms: String
  pricingTerms: String
  paymentTerms: String
  spaces: [Int]
  resources: [Int]
  purposes: [Int]
  equipments: [Int]
  services: [Int]
  paymentTypes: [String]
  qualifiers: [Int]
  images: [ReservationUnitImageFieldSerializerInput]
  pricings: [ReservationUnitPricingSerializerInput]
  applicationRoundTimeSlots: [ApplicationRoundTimeSlotSerializerInput]
}

type ReservationUnitCreateMutationPayload {
  pk: Int
  uuid: String
  name: String
  nameFi: String
  nameEn: String
  nameSv: String
  description: String
  descriptionFi: String
  descriptionEn: String
  descriptionSv: String
  termsOfUse: String
  termsOfUseFi: String
  termsOfUseEn: String
  termsOfUseSv: String
  contactInformation: String
  reservationPendingInstructions: String
  reservationPendingInstructionsFi: String
  reservationPendingInstructionsEn: String
  reservationPendingInstructionsSv: String
  reservationConfirmedInstructions: String
  reservationConfirmedInstructionsFi: String
  reservationConfirmedInstructionsEn: String
  reservationConfirmedInstructionsSv: String
  reservationCancelledInstructions: String
  reservationCancelledInstructionsFi: String
  reservationCancelledInstructionsEn: String
  reservationCancelledInstructionsSv: String
  surfaceArea: Int
  minPersons: Int
  maxPersons: Int
  maxReservationsPerUser: Int
  reservationsMinDaysBefore: Int
  reservationsMaxDaysBefore: Int
  reservationBegins: DateTime
  reservationEnds: DateTime
  publishBegins: DateTime
  publishEnds: DateTime
  minReservationDuration: Duration
  maxReservationDuration: Duration
  bufferTimeBefore: Duration
  bufferTimeAfter: Duration
  isDraft: Boolean
  isArchived: Boolean
  requireIntroduction: Boolean
  requireReservationHandling: Boolean
  reservationBlockWholeDay: Boolean
  canApplyFreeOfCharge: Boolean
  allowReservationsWithoutOpeningHours: Boolean
  authentication: Authentication
  reservationStartInterval: ReservationStartInterval
  reservationKind: ReservationKind
  state: String
  unit: Int
  reservationUnitType: Int
  cancellationRule: Int
  metadataSet: Int
  cancellationTerms: String
  serviceSpecificTerms: String
  pricingTerms: String
  paymentTerms: String
  spaces: [Int]
  resources: [Int]
  purposes: [Int]
  equipments: [Int]
  services: [Int]
  paymentTypes: [String]
  qualifiers: [Int]
  images: [ReservationUnitImageNode]
  pricings: [ReservationUnitPricingNode]
  applicationRoundTimeSlots: [ApplicationRoundTimeSlotNode]
}

input ReservationUnitImageCreateMutationInput {
  pk: Int
  reservationUnit: Int!
  image: Upload!
  imageType: ImageType!
}

type ReservationUnitImageCreateMutationPayload {
  pk: Int
  reservationUnit: Int
  imageType: ImageType
}

input ReservationUnitImageDeleteMutationInput {
  pk: ID!
}

type ReservationUnitImageDeleteMutationPayload {
  deleted: Boolean
}

input ReservationUnitImageFieldSerializerInput {
  imageUrl: Upload!
  largeUrl: String
  mediumUrl: String
  smallUrl: String
  imageType: ImageType!
}

type ReservationUnitImageNode implements Node {
  imageType: ImageType!
  largeUrl: String
  mediumUrl: String
  smallUrl: String

  """The ID of the object"""
  id: ID!
  imageUrl: String
  pk: Int
}

input ReservationUnitImageUpdateMutationInput {
  pk: Int!
  imageType: ImageType
}

type ReservationUnitImageUpdateMutationPayload {
  pk: Int
  imageType: ImageType
}

type ReservationUnitNode implements Node {
  uuid: UUID!
  rank: Int
  name: String!
  nameFi: String
  nameEn: String
  nameSv: String
  description: String!
  descriptionFi: String
  descriptionEn: String
  descriptionSv: String
  contactInformation: String!
  termsOfUse: String
  termsOfUseFi: String
  termsOfUseEn: String
  termsOfUseSv: String
  reservationPendingInstructions: String!
  reservationPendingInstructionsFi: String
  reservationPendingInstructionsEn: String
  reservationPendingInstructionsSv: String
  reservationConfirmedInstructions: String!
  reservationConfirmedInstructionsFi: String
  reservationConfirmedInstructionsEn: String
  reservationConfirmedInstructionsSv: String
  reservationCancelledInstructions: String!
  reservationCancelledInstructionsFi: String
  reservationCancelledInstructionsEn: String
  reservationCancelledInstructionsSv: String
  surfaceArea: Int
  minPersons: Int
  maxPersons: Int
  maxReservationsPerUser: Int
  reservationsMinDaysBefore: Int
  reservationsMaxDaysBefore: Int
  reservationBegins: DateTime
  reservationEnds: DateTime
  publishBegins: DateTime
  publishEnds: DateTime
  minReservationDuration: Duration
  maxReservationDuration: Duration
  bufferTimeBefore: Duration!
  bufferTimeAfter: Duration!
  isDraft: Boolean!
  isArchived: Boolean!
  requireIntroduction: Boolean!
  requireReservationHandling: Boolean!
  reservationBlockWholeDay: Boolean!
  canApplyFreeOfCharge: Boolean!
  allowReservationsWithoutOpeningHours: Boolean!
  authentication: Authentication!
  reservationStartInterval: ReservationStartInterval!
  reservationKind: ReservationKind!
  unit: UnitNode
  reservationUnitType: ReservationUnitTypeNode
  cancellationRule: ReservationUnitCancellationRuleNode
  metadataSet: ReservationMetadataSetNode
  cancellationTerms: TermsOfUseNode
  serviceSpecificTerms: TermsOfUseNode
  pricingTerms: TermsOfUseNode
  paymentTerms: TermsOfUseNode
  paymentProduct: PaymentProductNode
  paymentMerchant: PaymentMerchantNode
  spaces(
    nameFi: String
    nameFi_Icontains: String
    nameFi_Istartswith: String
    nameSv: String
    nameSv_Icontains: String
    nameSv_Istartswith: String
    nameEn: String
    nameEn_Icontains: String
    nameEn_Istartswith: String
    pk: [Int]
    onlyWithPermission: Boolean

    """Järjestä"""
    orderBy: [SpaceOrderingChoices]
  ): [SpaceNode!]!
  resources(
    nameFi: String
    nameFi_Icontains: String
    nameFi_Istartswith: String
    nameSv: String
    nameSv_Icontains: String
    nameSv_Istartswith: String
    nameEn: String
    nameEn_Icontains: String
    nameEn_Istartswith: String
    pk: [Int]
    onlyWithPermission: Boolean

    """Järjestä"""
    orderBy: [ResourceOrderingChoices]
  ): [ResourceNode!]!
  purposes(
    nameFi: String
    nameEn: String
    nameSv: String
    pk: [Int]

    """Järjestä"""
    orderBy: [PurposeOrderingChoices]
  ): [PurposeNode!]!
  equipments(
    name: String
    name_Icontains: String
    name_Istartswith: String
    nameFi: String
    nameFi_Icontains: String
    nameFi_Istartswith: String
    nameSv: String
    nameSv_Icontains: String
    nameSv_Istartswith: String
    nameEn: String
    nameEn_Icontains: String
    nameEn_Istartswith: String
    pk: [Int]
    rankGte: Decimal
    rankLte: Decimal

    """Järjestä"""
    orderBy: [EquipmentOrderingChoices]
  ): [EquipmentNode!]!
  services: [ServiceNode!]!
  paymentTypes: [ReservationUnitPaymentTypeNode!]!
  qualifiers(
    nameFi: String
    nameEn: String
    nameSv: String
    pk: [Int]

    """Järjestä"""
    orderBy: [QualifierOrderingChoices]
  ): [QualifierNode!]!
  applicationRounds(
    pk: [Int]
    name: String
    active: Boolean

    """Järjestä"""
    orderBy: [ApplicationRoundOrderingChoices]
  ): [ApplicationRoundNode!]!
  applicationRoundTimeSlots: [ApplicationRoundTimeSlotNode!]!
  images: [ReservationUnitImageNode!]!
  pricings: [ReservationUnitPricingNode!]!
  reservationSet(
    state: [String]
    begin: DateTime
    begin_Gte: DateTime
    begin_Lte: DateTime
    beginDate: Date
    endDate: Date
    onlyWithPermission: Boolean
    onlyWithHandlingPermission: Boolean

    """
    PaymentOrder's statuses; DRAFT, EXPIRED, CANCELLED, PAID, PAID_MANUALLY, REFUNDED
    """
    orderStatus: [String]
    priceGte: Decimal
    priceLte: Decimal
    recurringReservation: ID
    requested: Boolean
    reservationUnit: [ID]
    reservationType: [String]
    reservationUnitNameFi: String
    reservationUnitNameEn: String
    reservationUnitNameSv: String
    reservationUnitType: [ID]
    unit: [ID]
    user: ID
    textSearch: String

    """Järjestä"""
    orderBy: [ReservationOrderingChoices]
  ): [ReservationNode!]

  """The ID of the object"""
  id: ID!
  state: ReservationUnitState
  reservationState: ReservationState
  location: LocationNode
  isClosed: Boolean
  firstReservableDatetime: DateTime
  haukiUrl: String
  reservableTimeSpans(startDate: Date!, endDate: Date!): [ReservableTimeSpanType]
  calculatedSurfaceArea: Int
  pk: Int
}

type ReservationUnitNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ReservationUnitNodeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `ReservationUnitNode` and its cursor."""
type ReservationUnitNodeEdge {
  """The item at the end of the edge"""
  node: ReservationUnitNode

  """A cursor for use in pagination"""
  cursor: String!
}

input ReservationUnitOptionApplicantSerializerInput {
  pk: Int
  preferredOrder: Int!
  reservationUnit: Int!
}

type ReservationUnitOptionNode implements Node {
  preferredOrder: Int!
  rejected: Boolean!
  locked: Boolean!
  applicationSection: ApplicationSectionNode!
  reservationUnit: ReservationUnitNode!
  allocatedTimeSlots(
    pk: [Int]
    dayOfTheWeek: [Weekday]
    applicationRound: Int
    applicationSectionStatus: [ApplicationSectionStatusChoice]
    applicantType: [ApplicantTypeChoice]
    allocatedUnit: [Int]
    allocatedReservationUnit: [Int]
    textSearch: String

    """Järjestä"""
    orderBy: [AllocatedTimeSlotOrderingChoices]
  ): [AllocatedTimeSlotNode!]!

  """The ID of the object"""
  id: ID!
  pk: Int
}

"""Ordering fields for the 'ReservationUnitOption' model."""
enum ReservationUnitOptionOrderingChoices {
  pkAsc
  pkDesc
}

input ReservationUnitOptionUpdateMutationInput {
  pk: Int!
  rejected: Boolean
  locked: Boolean
}

type ReservationUnitOptionUpdateMutationPayload {
  pk: Int
  rejected: Boolean
  locked: Boolean
}

"""Ordering fields for the 'ReservationUnit' model."""
enum ReservationUnitOrderingChoices {
  pkAsc
  pkDesc
  nameFiAsc
  nameFiDesc
  nameEnAsc
  nameEnDesc
  nameSvAsc
  nameSvDesc
  typeFiAsc
  typeFiDesc
  typeEnAsc
  typeEnDesc
  typeSvAsc
  typeSvDesc
  unitNameFiAsc
  unitNameFiDesc
  unitNameEnAsc
  unitNameEnDesc
  unitNameSvAsc
  unitNameSvDesc
  maxPersonsAsc
  maxPersonsDesc
  surfaceAreaAsc
  surfaceAreaDesc
  rankAsc
  rankDesc
  typeRankAsc
  typeRankDesc
}

type ReservationUnitPaymentTypeNode implements Node {
  code: String!

  """The ID of the object"""
  id: ID!
}

type ReservationUnitPricingNode implements Node {
  """When pricing is activated"""
  begins: Date!

  """What kind of pricing types are available with this reservation unit."""
  pricingType: PricingType

  """Unit of the price"""
  priceUnit: PriceUnit!

  """Minimum price of the reservation unit including VAT"""
  lowestPrice: Decimal!

  """Maximum price of the reservation unit including VAT"""
  highestPrice: Decimal!

  """The percentage of tax included in the price"""
  taxPercentage: TaxPercentageNode!

  """Status of the pricing"""
  status: Status!

  """The ID of the object"""
  id: ID!
  lowestPriceNet: Decimal
  highestPriceNet: Decimal
  pk: Int
}

input ReservationUnitPricingSerializerInput {
  pk: Int

  """When pricing is activated"""
  begins: Date!

  """What kind of pricing types are available with this reservation unit."""
  pricingType: PricingType

  """Unit of the price"""
  priceUnit: PriceUnit

  """Minimum price of the reservation unit including VAT"""
  lowestPrice: Decimal
  lowestPriceNet: String

  """Maximum price of the reservation unit including VAT"""
  highestPrice: Decimal
  highestPriceNet: String

  """The percentage of tax included in the price"""
  taxPercentage: Int

  """Status of the pricing"""
  status: Status!
}

"""An enumeration."""
enum ReservationUnitState {
  DRAFT
  SCHEDULED_PUBLISHING
  SCHEDULED_HIDING
  SCHEDULED_PERIOD
  HIDDEN
  PUBLISHED
  ARCHIVED
}

type ReservationUnitTypeNode implements Node {
  name: String!
  nameFi: String
  nameEn: String
  nameSv: String

  """Järjestysnumero, jota käytetään rajapinnan järjestämisessä."""
  rank: Int

  """The ID of the object"""
  id: ID!
  pk: Int
}

type ReservationUnitTypeNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ReservationUnitTypeNodeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `ReservationUnitTypeNode` and its cursor."""
type ReservationUnitTypeNodeEdge {
  """The item at the end of the edge"""
  node: ReservationUnitTypeNode

  """A cursor for use in pagination"""
  cursor: String!
}

"""Ordering fields for the 'ReservationUnitType' model."""
enum ReservationUnitTypeOrderingChoices {
  rankAsc
  rankDesc
  nameFiAsc
  nameFiDesc
  nameEnAsc
  nameEnDesc
  nameSvAsc
  nameSvDesc
}

input ReservationUnitUpdateMutationInput {
  pk: Int!
  name: String
  nameFi: String
  nameEn: String
  nameSv: String
  description: String
  descriptionFi: String
  descriptionEn: String
  descriptionSv: String
  termsOfUse: String
  termsOfUseFi: String
  termsOfUseEn: String
  termsOfUseSv: String
  contactInformation: String
  reservationPendingInstructions: String
  reservationPendingInstructionsFi: String
  reservationPendingInstructionsEn: String
  reservationPendingInstructionsSv: String
  reservationConfirmedInstructions: String
  reservationConfirmedInstructionsFi: String
  reservationConfirmedInstructionsEn: String
  reservationConfirmedInstructionsSv: String
  reservationCancelledInstructions: String
  reservationCancelledInstructionsFi: String
  reservationCancelledInstructionsEn: String
  reservationCancelledInstructionsSv: String
  surfaceArea: Int
  minPersons: Int
  maxPersons: Int
  maxReservationsPerUser: Int
  reservationsMinDaysBefore: Int
  reservationsMaxDaysBefore: Int
  reservationBegins: DateTime
  reservationEnds: DateTime
  publishBegins: DateTime
  publishEnds: DateTime
  minReservationDuration: Duration
  maxReservationDuration: Duration
  bufferTimeBefore: Duration
  bufferTimeAfter: Duration
  isDraft: Boolean
  isArchived: Boolean
  requireIntroduction: Boolean
  requireReservationHandling: Boolean
  reservationBlockWholeDay: Boolean
  canApplyFreeOfCharge: Boolean
  allowReservationsWithoutOpeningHours: Boolean
  authentication: Authentication
  reservationStartInterval: ReservationStartInterval
  reservationKind: ReservationKind
  unit: Int
  reservationUnitType: Int
  cancellationRule: Int
  metadataSet: Int
  cancellationTerms: String
  serviceSpecificTerms: String
  pricingTerms: String
  paymentTerms: String
  spaces: [Int]
  resources: [Int]
  purposes: [Int]
  equipments: [Int]
  services: [Int]
  paymentTypes: [String]
  qualifiers: [Int]
  images: [UpdateReservationUnitImageFieldSerializerInput]
  pricings: [UpdateReservationUnitPricingSerializerInput]
  applicationRoundTimeSlots: [UpdateApplicationRoundTimeSlotSerializerInput]
}

type ReservationUnitUpdateMutationPayload {
  pk: Int
  uuid: String
  name: String
  nameFi: String
  nameEn: String
  nameSv: String
  description: String
  descriptionFi: String
  descriptionEn: String
  descriptionSv: String
  termsOfUse: String
  termsOfUseFi: String
  termsOfUseEn: String
  termsOfUseSv: String
  contactInformation: String
  reservationPendingInstructions: String
  reservationPendingInstructionsFi: String
  reservationPendingInstructionsEn: String
  reservationPendingInstructionsSv: String
  reservationConfirmedInstructions: String
  reservationConfirmedInstructionsFi: String
  reservationConfirmedInstructionsEn: String
  reservationConfirmedInstructionsSv: String
  reservationCancelledInstructions: String
  reservationCancelledInstructionsFi: String
  reservationCancelledInstructionsEn: String
  reservationCancelledInstructionsSv: String
  surfaceArea: Int
  minPersons: Int
  maxPersons: Int
  maxReservationsPerUser: Int
  reservationsMinDaysBefore: Int
  reservationsMaxDaysBefore: Int
  reservationBegins: DateTime
  reservationEnds: DateTime
  publishBegins: DateTime
  publishEnds: DateTime
  minReservationDuration: Duration
  maxReservationDuration: Duration
  bufferTimeBefore: Duration
  bufferTimeAfter: Duration
  isDraft: Boolean
  isArchived: Boolean
  requireIntroduction: Boolean
  requireReservationHandling: Boolean
  reservationBlockWholeDay: Boolean
  canApplyFreeOfCharge: Boolean
  allowReservationsWithoutOpeningHours: Boolean
  authentication: Authentication
  reservationStartInterval: ReservationStartInterval
  reservationKind: ReservationKind
  state: String
  unit: Int
  reservationUnitType: Int
  cancellationRule: Int
  metadataSet: Int
  cancellationTerms: String
  serviceSpecificTerms: String
  pricingTerms: String
  paymentTerms: String
  spaces: [Int]
  resources: [Int]
  purposes: [Int]
  equipments: [Int]
  services: [Int]
  paymentTypes: [String]
  qualifiers: [Int]
  images: [ReservationUnitImageNode]
  pricings: [ReservationUnitPricingNode]
  applicationRoundTimeSlots: [ApplicationRoundTimeSlotNode]
}

input ReservationUpdateMutationInput {
  pk: Int!
  reserveeFirstName: String
  reserveeLastName: String
  reserveePhone: String
  reserveeOrganisationName: String
  reserveeAddressStreet: String
  reserveeAddressCity: String
  reserveeAddressZip: String
  reserveeEmail: String
  reserveeType: String
  reserveeId: String
  reserveeIsUnregisteredAssociation: Boolean
  reserveeLanguage: String
  homeCityPk: Int
  applyingForFreeOfCharge: Boolean
  freeOfChargeReason: String
  ageGroupPk: Int
  billingFirstName: String
  billingLastName: String
  billingAddressStreet: String
  billingAddressCity: String
  billingAddressZip: String
  billingPhone: String
  billingEmail: String
  numPersons: Int
  name: String
  description: String

  """
  String value for ReservationType's ReservationState enum. Possible values are
  CREATED, CANCELLED, REQUIRES_HANDLING, WAITING_FOR_PAYMENT, CONFIRMED, DENIED.
  """
  state: String
  begin: DateTime
  end: DateTime
  bufferTimeBefore: Int
  bufferTimeAfter: Int
  reservationUnitPks: [Int]
  purposePk: Int
  type: String
}

type ReservationUpdateMutationPayload {
  pk: Int
  reserveeFirstName: String
  reserveeLastName: String
  reserveePhone: String
  reserveeOrganisationName: String
  reserveeAddressStreet: String
  reserveeAddressCity: String
  reserveeAddressZip: String
  reserveeEmail: String
  reserveeType: String
  reserveeId: String
  reserveeIsUnregisteredAssociation: Boolean
  reserveeLanguage: String
  homeCityPk: Int
  applyingForFreeOfCharge: Boolean
  freeOfChargeReason: String
  ageGroupPk: Int
  billingFirstName: String
  billingLastName: String
  billingAddressStreet: String
  billingAddressCity: String
  billingAddressZip: String
  billingPhone: String
  billingEmail: String
  numPersons: Int
  name: String
  description: String

  """
  String value for ReservationType's ReservationState enum. Possible values are
  CREATED, CANCELLED, REQUIRES_HANDLING, WAITING_FOR_PAYMENT, CONFIRMED, DENIED.
  """
  state: String
  begin: DateTime
  end: DateTime
  bufferTimeBefore: Int
  bufferTimeAfter: Int
  purposePk: Int
  confirmedAt: DateTime
  unitPrice: Decimal
  taxPercentageValue: Decimal
  price: Decimal
  priceNet: Decimal
  nonSubsidisedPrice: Decimal
  nonSubsidisedPriceNet: Decimal
  type: String
}

input ReservationWorkingMemoMutationInput {
  """Primary key of the reservation"""
  pk: Int
  workingMemo: String
}

type ReservationWorkingMemoMutationPayload {
  """Primary key of the reservation"""
  pk: Int
  workingMemo: String
}

input ResourceCreateMutationInput {
  pk: Int
  name: String!
  nameFi: String
  nameEn: String
  nameSv: String
  locationType: LocationType
  space: Int
  bufferTimeBefore: Duration
  bufferTimeAfter: Duration
}

type ResourceCreateMutationPayload {
  pk: Int
  name: String
  nameFi: String
  nameEn: String
  nameSv: String
  locationType: LocationType
  space: Int
  bufferTimeBefore: Duration
  bufferTimeAfter: Duration
}

input ResourceDeleteMutationInput {
  pk: ID!
}

type ResourceDeleteMutationPayload {
  deleted: Boolean
}

"""An enumeration."""
enum ResourceLocationType {
  FIXED
  MOVABLE
}

type ResourceNode implements Node {
  locationType: ResourceLocationType
  name: String!
  nameFi: String
  nameEn: String
  nameSv: String
  space: SpaceNode
  bufferTimeBefore: Duration
  bufferTimeAfter: Duration

  """The ID of the object"""
  id: ID!
  pk: Int
}

type ResourceNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ResourceNodeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `ResourceNode` and its cursor."""
type ResourceNodeEdge {
  """The item at the end of the edge"""
  node: ResourceNode

  """A cursor for use in pagination"""
  cursor: String!
}

"""Ordering fields for the 'Resource' model."""
enum ResourceOrderingChoices {
  pkAsc
  pkDesc
}

input ResourceUpdateMutationInput {
  pk: Int!
  name: String
  nameFi: String
  nameEn: String
  nameSv: String
  locationType: LocationType
  space: Int
  bufferTimeBefore: Duration
  bufferTimeAfter: Duration
}

type ResourceUpdateMutationPayload {
  pk: Int
  name: String
  nameFi: String
  nameEn: String
  nameSv: String
  locationType: LocationType
  space: Int
  bufferTimeBefore: Duration
  bufferTimeAfter: Duration
}

type ServiceNode implements Node {
  name: String!
  nameFi: String
  nameEn: String
  nameSv: String
  serviceType: ServiceType!
  bufferTimeBefore: Duration
  bufferTimeAfter: Duration

  """The ID of the object"""
  id: ID!
  pk: Int
}

type ServiceSectorNode implements Node {
  name: String!
  nameFi: String
  nameEn: String
  nameSv: String

  """The ID of the object"""
  id: ID!
  pk: Int
}

type ServiceSectorNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ServiceSectorNodeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `ServiceSectorNode` and its cursor."""
type ServiceSectorNodeEdge {
  """The item at the end of the edge"""
  node: ServiceSectorNode

  """A cursor for use in pagination"""
  cursor: String!
}

"""An enumeration."""
enum ServiceSectorPermissionsChoices {
  CAN_MANAGE_SERVICE_SECTOR_ROLES
  CAN_MANAGE_UNIT_ROLES
  CAN_MANAGE_RESERVATION_UNITS
  CAN_MANAGE_APPLICATION_ROUNDS
  CAN_HANDLE_APPLICATIONS
  CAN_MANAGE_RESERVATIONS
  CAN_VALIDATE_APPLICATIONS
  CAN_VIEW_RESERVATIONS
  CAN_VIEW_USERS
  CAN_ALLOCATE_APPLICATIONS
  CAN_MANAGE_SPACES
  CAN_MANAGE_RESOURCES
  CAN_CREATE_STAFF_RESERVATIONS
  CAN_COMMENT_RESERVATIONS
  CAN_MANAGE_UNITS
}

type ServiceSectorRoleChoiceNode implements Node {
  code: String!
  verboseName: String!
  verboseNameFi: String
  verboseNameEn: String
  verboseNameSv: String
  permissions: [ServiceSectorRolePermissionNode!]

  """The ID of the object"""
  id: ID!
}

type ServiceSectorRoleNode implements Node {
  role: ServiceSectorRoleChoiceNode!
  serviceSector: ServiceSectorNode!

  """The ID of the object"""
  id: ID!
  pk: Int
}

type ServiceSectorRolePermissionNode implements Node {
  permission: ServiceSectorPermissionsChoices

  """The ID of the object"""
  id: ID!
  pk: Int
}

"""An enumeration."""
enum ServiceType {
  """Perehdytys"""
  INTRODUCTION

  """Tarjoilu"""
  CATERING

  """Konfiguraatio"""
  CONFIGURATION
}

input SpaceCreateMutationInput {
  pk: Int
  name: String!
  nameFi: String
  nameEn: String
  nameSv: String
  surfaceArea: Int
  maxPersons: Int
  code: String
  unit: Int
  building: Int
  parent: Int
}

type SpaceCreateMutationPayload {
  pk: Int
  name: String
  nameFi: String
  nameEn: String
  nameSv: String
  surfaceArea: Int
  maxPersons: Int
  code: String
  unit: Int
  building: Int
  parent: Int
}

input SpaceDeleteMutationInput {
  pk: ID!
}

type SpaceDeleteMutationPayload {
  deleted: Boolean
}

type SpaceNode implements Node {
  name: String!
  nameFi: String
  nameEn: String
  nameSv: String
  surfaceArea: Int
  maxPersons: Int
  code: String!
  parent: SpaceNode
  unit: UnitNode
  children(
    nameFi: String
    nameFi_Icontains: String
    nameFi_Istartswith: String
    nameSv: String
    nameSv_Icontains: String
    nameSv_Istartswith: String
    nameEn: String
    nameEn_Icontains: String
    nameEn_Istartswith: String
    pk: [Int]
    onlyWithPermission: Boolean

    """Järjestä"""
    orderBy: [SpaceOrderingChoices]
  ): [SpaceNode!]
  resourceSet(
    nameFi: String
    nameFi_Icontains: String
    nameFi_Istartswith: String
    nameSv: String
    nameSv_Icontains: String
    nameSv_Istartswith: String
    nameEn: String
    nameEn_Icontains: String
    nameEn_Istartswith: String
    pk: [Int]
    onlyWithPermission: Boolean

    """Järjestä"""
    orderBy: [ResourceOrderingChoices]
  ): [ResourceNode!]!

  """The ID of the object"""
  id: ID!
  pk: Int
}

type SpaceNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [SpaceNodeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `SpaceNode` and its cursor."""
type SpaceNodeEdge {
  """The item at the end of the edge"""
  node: SpaceNode

  """A cursor for use in pagination"""
  cursor: String!
}

"""Ordering fields for the 'Space' model."""
enum SpaceOrderingChoices {
  pkAsc
  pkDesc
}

input SpaceUpdateMutationInput {
  pk: Int!
  name: String
  nameFi: String
  nameEn: String
  nameSv: String
  surfaceArea: Int
  maxPersons: Int
  code: String
  unit: Int
  building: Int
  parent: Int
}

type SpaceUpdateMutationPayload {
  pk: Int
  name: String
  nameFi: String
  nameEn: String
  nameSv: String
  surfaceArea: Int
  maxPersons: Int
  code: String
  unit: Int
  building: Int
  parent: Int
}

"""An enumeration."""
enum State {
  """Luotu"""
  CREATED

  """Peruttu"""
  CANCELLED

  """Vaatiiko käsittelyn"""
  REQUIRES_HANDLING

  """Odottaa maksua"""
  WAITING_FOR_PAYMENT

  """Vahvistettu"""
  CONFIRMED

  """Hylätty"""
  DENIED
}

"""An enumeration."""
enum Status {
  """mennyt"""
  PAST

  """aktiivinen"""
  ACTIVE

  """tuleva"""
  FUTURE
}

type SuitableTimeRangeNode implements Node {
  priority: Priority!
  dayOfTheWeek: Weekday!
  beginTime: Time!
  endTime: Time!
  applicationSection: ApplicationSectionNode!

  """The ID of the object"""
  id: ID!
  fulfilled: Boolean
  pk: Int
}

"""Ordering fields for the 'SuitableTimeRange' model."""
enum SuitableTimeRangeOrderingChoices {
  pkAsc
  pkDesc
}

input SuitableTimeRangeSerializerInput {
  pk: Int
  priority: Priority!
  dayOfTheWeek: Weekday!
  beginTime: Time!
  endTime: Time!
}

"""An enumeration."""
enum TargetGroup {
  """Sisäinen"""
  INTERNAL

  """Julkinen"""
  PUBLIC

  """Kaikki"""
  ALL
}

type TaxPercentageNode implements Node {
  """The tax percentage for a price"""
  value: Decimal!

  """The ID of the object"""
  id: ID!
  pk: Int
}

type TaxPercentageNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [TaxPercentageNodeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `TaxPercentageNode` and its cursor."""
type TaxPercentageNodeEdge {
  """The item at the end of the edge"""
  node: TaxPercentageNode

  """A cursor for use in pagination"""
  cursor: String!
}

"""Ordering fields for the 'TaxPercentage' model."""
enum TaxPercentageOrderingChoices {
  pkAsc
  pkDesc
}

type TermsOfUseNode implements Node {
  name: String
  nameFi: String
  nameEn: String
  nameSv: String
  text: String!
  textFi: String
  textEn: String
  textSv: String
  termsType: TermsType!

  """The ID of the object"""
  id: ID!
  pk: String
}

type TermsOfUseNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [TermsOfUseNodeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `TermsOfUseNode` and its cursor."""
type TermsOfUseNodeEdge {
  """The item at the end of the edge"""
  node: TermsOfUseNode

  """A cursor for use in pagination"""
  cursor: String!
}

"""Ordering fields for the 'TermsOfUse' model."""
enum TermsOfUseOrderingChoices {
  pkAsc
  pkDesc
}

"""An enumeration."""
enum TermsType {
  """Yleiset ehdot"""
  GENERIC_TERMS

  """Maksuehdot"""
  PAYMENT_TERMS

  """Peruutusehdot"""
  CANCELLATION_TERMS

  """Toistuvan varauksen ehdot"""
  RECURRING_TERMS

  """Palvelualuekohtaiset ehdot"""
  SERVICE_TERMS

  """Hinnoitteluehdot"""
  PRICING_TERMS
}

"""Time scalar that can parse time-strings from database."""
scalar Time

input TimeSlotSerializerInput {
  begin: Time!
  end: Time!
}

type TimeSlotType {
  begin: Time!
  end: Time!
}

type UnitGroupNode implements Node {
  name: String!
  nameFi: String
  nameEn: String
  nameSv: String
  units(
    nameFi: String
    nameFi_Icontains: String
    nameFi_Istartswith: String
    nameSv: String
    nameSv_Icontains: String
    nameSv_Istartswith: String
    nameEn: String
    nameEn_Icontains: String
    nameEn_Istartswith: String
    pk: [Int]
    serviceSector: Decimal
    onlyWithPermission: Boolean
    publishedReservationUnits: Boolean
    ownReservations: Boolean
    onlyDirectBookable: Boolean
    onlySeasonalBookable: Boolean

    """Järjestä"""
    orderBy: [UnitOrderingChoices]
  ): [UnitNode!]!

  """The ID of the object"""
  id: ID!
  pk: Int
}

type UnitNode implements Node {
  tprekId: String
  name: String!
  nameFi: String
  nameEn: String
  nameSv: String
  description: String!
  descriptionFi: String
  descriptionEn: String
  descriptionSv: String
  shortDescription: String!
  shortDescriptionFi: String
  shortDescriptionEn: String
  shortDescriptionSv: String
  webPage: String!
  email: String!
  phone: String!
  paymentMerchant: PaymentMerchantNode
  location: LocationNode
  serviceSectors: [ServiceSectorNode!]!
  spaces(
    nameFi: String
    nameFi_Icontains: String
    nameFi_Istartswith: String
    nameSv: String
    nameSv_Icontains: String
    nameSv_Istartswith: String
    nameEn: String
    nameEn_Icontains: String
    nameEn_Istartswith: String
    pk: [Int]
    onlyWithPermission: Boolean

    """Järjestä"""
    orderBy: [SpaceOrderingChoices]
  ): [SpaceNode!]!
  reservationunitSet(
    nameFi: String
    nameFi_Icontains: String
    nameFi_Istartswith: String
    nameSv: String
    nameSv_Icontains: String
    nameSv_Istartswith: String
    nameEn: String
    nameEn_Icontains: String
    nameEn_Istartswith: String
    descriptionFi: String
    descriptionFi_Icontains: String
    descriptionSv: String
    descriptionSv_Icontains: String
    descriptionEn: String
    descriptionEn_Icontains: String
    pk: [Int]
    unit: [Int]
    reservationUnitType: [Int]
    minPersonsGte: Decimal
    minPersonsLte: Decimal
    maxPersonsGte: Decimal
    maxPersonsLte: Decimal
    textSearch: String
    keywordGroups: [Int]
    purposes: [Int]
    qualifiers: [Int]
    equipments: [Int]
    isDraft: Boolean
    isVisible: Boolean
    applicationRound: [Int]
    surfaceAreaGte: Decimal
    surfaceAreaLte: Decimal
    rankGte: Decimal
    rankLte: Decimal
    typeRankGte: Decimal
    typeRankLte: Decimal
    reservationKind: String
    state: [String]
    reservationState: [String]
    onlyWithPermission: Boolean
    reservableDateStart: Date
    reservableDateEnd: Date
    reservableTimeStart: Time
    reservableTimeEnd: Time
    reservableMinimumDurationMinutes: Decimal
    showOnlyReservable: Boolean
    calculateFirstReservableTime: Boolean

    """Järjestä"""
    orderBy: [ReservationUnitOrderingChoices]
  ): [ReservationUnitNode!]!

  """The ID of the object"""
  id: ID!
  pk: Int
}

type UnitNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [UnitNodeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `UnitNode` and its cursor."""
type UnitNodeEdge {
  """The item at the end of the edge"""
  node: UnitNode

  """A cursor for use in pagination"""
  cursor: String!
}

"""Ordering fields for the 'Unit' model."""
enum UnitOrderingChoices {
  pkAsc
  pkDesc
  nameFiAsc
  nameFiDesc
  nameEnAsc
  nameEnDesc
  nameSvAsc
  nameSvDesc
  rankAsc
  rankDesc
  reservationCountAsc
  reservationCountDesc
}

"""An enumeration."""
enum UnitPermissionChoices {
  CAN_MANAGE_UNIT_ROLES
  CAN_MANAGE_RESERVATION_UNITS
  CAN_MANAGE_RESERVATIONS
  CAN_VIEW_RESERVATIONS
  CAN_VIEW_USERS
  CAN_VALIDATE_APPLICATIONS
  CAN_ALLOCATE_APPLICATIONS
  CAN_HANDLE_APPLICATIONS
  CAN_MANAGE_UNITS
  CAN_MANAGE_SPACES
  CAN_MANAGE_RESOURCES
  CAN_CREATE_STAFF_RESERVATIONS
  CAN_COMMENT_RESERVATIONS
}

type UnitRoleChoiceNode implements Node {
  code: String!
  verboseName: String!
  verboseNameFi: String
  verboseNameEn: String
  verboseNameSv: String
  permissions: [UnitRolePermissionNode!]

  """The ID of the object"""
  id: ID!
}

type UnitRoleNode implements Node {
  role: UnitRoleChoiceNode!
  unitGroup: [UnitGroupNode!]!
  unit(
    nameFi: String
    nameFi_Icontains: String
    nameFi_Istartswith: String
    nameSv: String
    nameSv_Icontains: String
    nameSv_Istartswith: String
    nameEn: String
    nameEn_Icontains: String
    nameEn_Istartswith: String
    pk: [Int]
    serviceSector: Decimal
    onlyWithPermission: Boolean
    publishedReservationUnits: Boolean
    ownReservations: Boolean
    onlyDirectBookable: Boolean
    onlySeasonalBookable: Boolean

    """Järjestä"""
    orderBy: [UnitOrderingChoices]
  ): [UnitNode!]!

  """The ID of the object"""
  id: ID!
  pk: Int
}

type UnitRolePermissionNode implements Node {
  permission: UnitPermissionChoices

  """The ID of the object"""
  id: ID!
  pk: Int
}

input UnitUpdateMutationInput {
  pk: Int!
  tprekId: String
  name: String
  nameFi: String
  nameEn: String
  nameSv: String
  description: String
  descriptionFi: String
  descriptionEn: String
  descriptionSv: String
  shortDescription: String
  shortDescriptionFi: String
  shortDescriptionEn: String
  shortDescriptionSv: String
  webPage: String
  email: String
  phone: String
}

type UnitUpdateMutationPayload {
  pk: Int
  tprekId: String
  name: String
  nameFi: String
  nameEn: String
  nameSv: String
  description: String
  descriptionFi: String
  descriptionEn: String
  descriptionSv: String
  shortDescription: String
  shortDescriptionFi: String
  shortDescriptionEn: String
  shortDescriptionSv: String
  webPage: String
  email: String
  phone: String
}

input UpdateAddressSerializerInput {
  pk: Int
  streetAddress: String
  streetAddressFi: String
  streetAddressEn: String
  streetAddressSv: String
  postCode: String
  city: String
  cityFi: String
  cityEn: String
  citySv: String
}

input UpdateApplicationRoundTimeSlotSerializerInput {
  weekday: Int!
  closed: Boolean
  reservableTimes: [TimeSlotSerializerInput]
}

input UpdateApplicationSectionForApplicationSerializerInput {
  pk: Int
  name: String
  numPersons: Int
  reservationsBeginDate: Date
  reservationsEndDate: Date
  reservationMinDuration: Duration
  reservationMaxDuration: Duration
  appliedReservationsPerWeek: Int
  purpose: Int
  ageGroup: Int
  reservationUnitOptions: [UpdateReservationUnitOptionApplicantSerializerInput]
  suitableTimeRanges: [UpdateSuitableTimeRangeSerializerInput]
}

input UpdateOrganisationSerializerInput {
  pk: Int
  name: String
  nameFi: String
  nameEn: String
  nameSv: String
  identifier: String
  yearEstablished: Int
  address: UpdateAddressSerializerInput
  activeMembers: Int
  coreBusiness: String
  coreBusinessFi: String
  coreBusinessEn: String
  coreBusinessSv: String
  organisationType: OrganizationTypeChoice
  email: String
}

input UpdatePersonSerializerInput {
  pk: Int
  firstName: String
  lastName: String
  email: String
  phoneNumber: String
}

input UpdateReservationUnitImageFieldSerializerInput {
  imageUrl: Upload!
  largeUrl: String
  mediumUrl: String
  smallUrl: String
  imageType: ImageType
}

input UpdateReservationUnitOptionApplicantSerializerInput {
  pk: Int
  preferredOrder: Int
  reservationUnit: Int
}

input UpdateReservationUnitPricingSerializerInput {
  pk: Int

  """When pricing is activated"""
  begins: Date

  """What kind of pricing types are available with this reservation unit."""
  pricingType: PricingType

  """Unit of the price"""
  priceUnit: PriceUnit

  """Minimum price of the reservation unit including VAT"""
  lowestPrice: Decimal
  lowestPriceNet: String

  """Maximum price of the reservation unit including VAT"""
  highestPrice: Decimal
  highestPriceNet: String

  """The percentage of tax included in the price"""
  taxPercentage: Int

  """Status of the pricing"""
  status: Status
}

input UpdateSuitableTimeRangeSerializerInput {
  pk: Int
  priority: Priority
  dayOfTheWeek: Weekday
  beginTime: Time
  endTime: Time
}

"""Represents a file upload."""
scalar Upload

type UserNode implements Node {
  """
  Antaa käyttäjälle kaikki oikeudet ilman, että niitä täytyy erikseen luetella.
  """
  isSuperuser: Boolean!

  """
  Vaaditaan. Enintään 150 merkkiä. Vain kirjaimet, numerot ja @/./+/-/_ ovat sallittuja.
  """
  username: String!
  firstName: String!
  lastName: String!
  email: String!
  uuid: UUID!
  reservationNotification: String
  dateOfBirth: Date
  generalRoles: [GeneralRoleNode!]!
  unitRoles: [UnitRoleNode!]!
  serviceSectorRoles: [ServiceSectorRoleNode!]!

  """The ID of the object"""
  id: ID!
  name: String
  isAdAuthenticated: Boolean
  isStronglyAuthenticated: Boolean
  pk: Int
}

input UserUpdateMutationInput {
  pk: Int!

  """When user wants to receive reservation notification emails."""
  reservationNotification: ReservationNotification
}

type UserUpdateMutationPayload {
  pk: Int

  """When user wants to receive reservation notification emails."""
  reservationNotification: ReservationNotification
}

"""
Leverages the internal Python implementation of UUID (uuid.UUID) to provide native UUID objects
in fields, resolvers and input.
"""
scalar UUID

"""An enumeration."""
enum Weekday {
  MONDAY
  TUESDAY
  WEDNESDAY
  THURSDAY
  FRIDAY
  SATURDAY
  SUNDAY
}

