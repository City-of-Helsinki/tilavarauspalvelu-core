"""Exposes a URL that specifies the behaviour of this scalar."""
directive @specifiedBy(
  """The URL that specifies the behaviour of this scalar."""
  url: String!
) on SCALAR

type AbilityGroupType {
  name: String!
  pk: Int
}

type AgeGroupType implements Node {
  minimum: Int!
  maximum: Int

  """The ID of the object"""
  id: ID!
  pk: Int
}

type AgeGroupTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [AgeGroupTypeEdge]!
}

"""A Relay edge containing a `AgeGroupType` and its cursor."""
type AgeGroupTypeEdge {
  """The item at the end of the edge"""
  node: AgeGroupType

  """A cursor for use in pagination"""
  cursor: String!
}

type AggregatedDataType {
  allocationResultEventsCount: Int
  allocationDurationTotal: Int
  totalReservationDuration: Int
  totalHourCapacity: Int
}

type ApplicationRoundBasketType implements Node {
  """The ID of the object"""
  id: ID!
  name: String!
  mustBeMainPurposeOfApplicant: Boolean!
  customerType: [String]!
  allocationPercentage: Int!
  orderNumber: Int!
  pk: Int
  purposeIds: [Int]
  ageGroupIds: [Int]
  homeCityId: Int
}

type ApplicationRoundType implements Node {
  """The ID of the object"""
  id: ID!
  nameFi: String
  nameEn: String
  nameSv: String
  targetGroup: ApplicationsApplicationRoundTargetGroupChoices!
  allocating: Boolean!
  reservationUnits: [ReservationUnitType]
  applicationPeriodBegin: DateTime!
  applicationPeriodEnd: DateTime!
  reservationPeriodBegin: Date!
  reservationPeriodEnd: Date!
  publicDisplayBegin: DateTime!
  publicDisplayEnd: DateTime!
  purposes: [ReservationPurposeType]
  serviceSector: ServiceSectorType
  criteriaFi: String
  criteriaEn: String
  criteriaSv: String
  aggregatedData: AggregatedDataType
  applicationRoundBaskets: [ApplicationRoundBasketType]
  pk: Int
  status: status
  statusTimestamp: DateTime
  approvedBy: String
  applicationsSent: Boolean
}

type ApplicationRoundTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ApplicationRoundTypeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `ApplicationRoundType` and its cursor."""
type ApplicationRoundTypeEdge {
  """The item at the end of the edge"""
  node: ApplicationRoundType

  """A cursor for use in pagination"""
  cursor: String!
}

"""An enumeration."""
enum ApplicationsApplicationRoundTargetGroupChoices {
  """Internal"""
  INTERNAL

  """Public"""
  PUBLIC

  """Kaikki"""
  ALL
}

type BuildingType implements Node {
  nameFi: String
  nameEn: String
  nameSv: String
  district: DistrictType
  realEstate: RealEstateType
  surfaceArea: Decimal

  """The ID of the object"""
  id: ID!
  pk: Int
}

type CityType implements Node {
  name: String!

  """The ID of the object"""
  id: ID!
  pk: Int
}

type CityTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [CityTypeEdge]!
}

"""A Relay edge containing a `CityType` and its cursor."""
type CityTypeEdge {
  """The item at the end of the edge"""
  node: CityType

  """A cursor for use in pagination"""
  cursor: String!
}

"""
The `Date` scalar type represents a Date
value as specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar Date

"""
The `DateTime` scalar type represents a DateTime
value as specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar DateTime

"""The `Decimal` scalar type represents a python Decimal."""
scalar Decimal

type DistrictType implements Node {
  nameFi: String
  nameEn: String
  nameSv: String

  """The ID of the object"""
  id: ID!
  pk: Int
}

"""
The `Duration` scalar type represents a duration value as an integer in seconds.
For example, a value of 900 means a duration of 15 minutes.
"""
scalar Duration

input EquipmentCategoryCreateMutationInput {
  nameFi: String
  nameEn: String
  nameSv: String
  clientMutationId: String
}

type EquipmentCategoryCreateMutationPayload {
  pk: Int
  nameFi: String
  nameEn: String
  nameSv: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  equipmentCategory: EquipmentCategoryType
  clientMutationId: String
}

input EquipmentCategoryDeleteMutationInput {
  pk: Int!
  clientMutationId: String
}

type EquipmentCategoryDeleteMutationPayload {
  deleted: Boolean
  errors: String
  clientMutationId: String
}

type EquipmentCategoryType implements Node {
  nameFi: String
  nameEn: String
  nameSv: String

  """The ID of the object"""
  id: ID!
  pk: Int
}

type EquipmentCategoryTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [EquipmentCategoryTypeEdge]!
}

"""A Relay edge containing a `EquipmentCategoryType` and its cursor."""
type EquipmentCategoryTypeEdge {
  """The item at the end of the edge"""
  node: EquipmentCategoryType

  """A cursor for use in pagination"""
  cursor: String!
}

input EquipmentCategoryUpdateMutationInput {
  pk: Int!
  nameFi: String
  nameEn: String
  nameSv: String
  clientMutationId: String
}

type EquipmentCategoryUpdateMutationPayload {
  pk: Int
  nameFi: String
  nameEn: String
  nameSv: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  equipmentCategory: EquipmentCategoryType
  clientMutationId: String
}

input EquipmentCreateMutationInput {
  categoryPk: Int!
  nameFi: String
  nameEn: String
  nameSv: String
  clientMutationId: String
}

type EquipmentCreateMutationPayload {
  pk: Int
  categoryPk: Int
  nameFi: String
  nameEn: String
  nameSv: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  equipment: EquipmentType
  clientMutationId: String
}

input EquipmentDeleteMutationInput {
  pk: Int!
  clientMutationId: String
}

type EquipmentDeleteMutationPayload {
  deleted: Boolean
  errors: String
  clientMutationId: String
}

type EquipmentType implements Node {
  nameFi: String
  nameEn: String
  nameSv: String

  """The ID of the object"""
  id: ID!
  pk: Int
  category: EquipmentCategoryType
}

type EquipmentTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [EquipmentTypeEdge]!
}

"""A Relay edge containing a `EquipmentType` and its cursor."""
type EquipmentTypeEdge {
  """The item at the end of the edge"""
  node: EquipmentType

  """A cursor for use in pagination"""
  cursor: String!
}

input EquipmentUpdateMutationInput {
  pk: Int!
  categoryPk: Int!
  nameFi: String
  nameEn: String
  nameSv: String
  clientMutationId: String
}

type EquipmentUpdateMutationPayload {
  pk: Int
  categoryPk: Int
  nameFi: String
  nameEn: String
  nameSv: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  equipment: EquipmentType
  clientMutationId: String
}

type ErrorType {
  field: String!
  messages: [String!]!
}

type KeywordCategoryType implements Node {
  nameFi: String
  nameEn: String
  nameSv: String

  """The ID of the object"""
  id: ID!
  pk: Int
  keywordGroups: [KeywordGroupType]
}

type KeywordCategoryTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [KeywordCategoryTypeEdge]!
}

"""A Relay edge containing a `KeywordCategoryType` and its cursor."""
type KeywordCategoryTypeEdge {
  """The item at the end of the edge"""
  node: KeywordCategoryType

  """A cursor for use in pagination"""
  cursor: String!
}

type KeywordGroupType implements Node {
  nameFi: String
  nameEn: String
  nameSv: String

  """The ID of the object"""
  id: ID!
  pk: Int
  keywords: [KeywordType]
}

type KeywordGroupTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [KeywordGroupTypeEdge]!
}

"""A Relay edge containing a `KeywordGroupType` and its cursor."""
type KeywordGroupTypeEdge {
  """The item at the end of the edge"""
  node: KeywordGroupType

  """A cursor for use in pagination"""
  cursor: String!
}

type KeywordType implements Node {
  nameFi: String
  nameEn: String
  nameSv: String

  """The ID of the object"""
  id: ID!
  pk: Int
}

type KeywordTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [KeywordTypeEdge]!
}

"""A Relay edge containing a `KeywordType` and its cursor."""
type KeywordTypeEdge {
  """The item at the end of the edge"""
  node: KeywordType

  """A cursor for use in pagination"""
  cursor: String!
}

type LocationType implements Node {
  addressStreetFi: String
  addressStreetEn: String
  addressStreetSv: String
  addressZip: String!
  addressCityFi: String
  addressCityEn: String
  addressCitySv: String

  """The ID of the object"""
  id: ID!
  pk: Int
  longitude: String
  latitude: String
}

type Mutation {
  createReservation(input: ReservationCreateMutationInput!): ReservationCreateMutationPayload
  updateReservation(input: ReservationUpdateMutationInput!): ReservationUpdateMutationPayload
  confirmReservation(input: ReservationConfirmMutationInput!): ReservationConfirmMutationPayload
  cancelReservation(input: ReservationCancellationMutationInput!): ReservationCancellationMutationPayload
  denyReservation(input: ReservationDenyMutationInput!): ReservationDenyMutationPayload
  approveReservation(input: ReservationApproveMutationInput!): ReservationApproveMutationPayload
  requireHandlingForReservation(input: ReservationRequiresHandlingMutationInput!): ReservationRequiresHandlingMutationPayload
  updateReservationWorkingMemo(input: ReservationWorkingMemoMutationInput!): ReservationWorkingMemoMutationPayload
  createReservationUnit(input: ReservationUnitCreateMutationInput!): ReservationUnitCreateMutationPayload
  updateReservationUnit(input: ReservationUnitUpdateMutationInput!): ReservationUnitUpdateMutationPayload
  createReservationUnitImage(input: ReservationUnitImageCreateMutationInput!): ReservationUnitImageCreateMutationPayload
  updateReservationUnitImage(input: ReservationUnitImageUpdateMutationInput!): ReservationUnitImageUpdateMutationPayload
  deleteReservationUnitImage(input: ReservationUnitImageDeleteMutationInput!): ReservationUnitImageDeleteMutationPayload
  createPurpose(input: PurposeCreateMutationInput!): PurposeCreateMutationPayload
  updatePurpose(input: PurposeUpdateMutationInput!): PurposeUpdateMutationPayload
  createEquipment(input: EquipmentCreateMutationInput!): EquipmentCreateMutationPayload
  updateEquipment(input: EquipmentUpdateMutationInput!): EquipmentUpdateMutationPayload
  deleteEquipment(input: EquipmentDeleteMutationInput!): EquipmentDeleteMutationPayload
  createEquipmentCategory(input: EquipmentCategoryCreateMutationInput!): EquipmentCategoryCreateMutationPayload
  updateEquipmentCategory(input: EquipmentCategoryUpdateMutationInput!): EquipmentCategoryUpdateMutationPayload
  deleteEquipmentCategory(input: EquipmentCategoryDeleteMutationInput!): EquipmentCategoryDeleteMutationPayload
  createSpace(input: SpaceCreateMutationInput!): SpaceCreateMutationPayload
  updateSpace(input: SpaceUpdateMutationInput!): SpaceUpdateMutationPayload
  deleteSpace(input: SpaceDeleteMutationInput!): SpaceDeleteMutationPayload
  createResource(input: ResourceCreateMutationInput!): ResourceCreateMutationPayload
  updateResource(input: ResourceUpdateMutationInput!): ResourceUpdateMutationPayload
  deleteResource(input: ResourceDeleteMutationInput!): ResourceDeleteMutationPayload
  updateUnit(input: UnitUpdateMutationInput!): UnitUpdateMutationPayload
}

"""An object with an ID"""
interface Node {
  """The ID of the object"""
  id: ID!
}

type OpeningHoursType {
  openingTimes: [OpeningTimesType]
  openingTimePeriods: [PeriodType]
}

type OpeningTimesType {
  date: Date
  startTime: Time
  endTime: Time
  state: String
  periods: [Int]
}

"""
The Relay compliant `PageInfo` type, containing data necessary to paginate this connection.
"""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String

  """When paginating forwards, the cursor to continue."""
  endCursor: String
}

type PeriodType {
  periodId: Int
  startDate: Date
  endDate: Date
  resourceState: String
  timeSpans: [TimeSpanType]
  nameFi: String
  nameEn: String
  nameSv: String
  descriptionFi: String
  descriptionEn: String
  descriptionSv: String
}

input PurposeCreateMutationInput {
  nameFi: String
  nameEn: String
  nameSv: String
  clientMutationId: String
}

type PurposeCreateMutationPayload {
  nameFi: String
  nameEn: String
  nameSv: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  purpose: PurposeType
  clientMutationId: String
}

type PurposeType implements Node {
  nameFi: String
  nameEn: String
  nameSv: String

  """The ID of the object"""
  id: ID!
  pk: Int
}

type PurposeTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [PurposeTypeEdge]!
}

"""A Relay edge containing a `PurposeType` and its cursor."""
type PurposeTypeEdge {
  """The item at the end of the edge"""
  node: PurposeType

  """A cursor for use in pagination"""
  cursor: String!
}

input PurposeUpdateMutationInput {
  pk: Int!
  nameFi: String
  nameEn: String
  nameSv: String
  clientMutationId: String
}

type PurposeUpdateMutationPayload {
  pk: Int
  nameFi: String
  nameEn: String
  nameSv: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  purpose: PurposeType
  clientMutationId: String
}

type Query {
  applicationRounds(offset: Int = null, before: String = null, after: String = null, first: Int = null, last: Int = null, nameFi: String = null, nameFi_Icontains: String = null, nameFi_Istartswith: String = null, nameSv: String = null, nameSv_Icontains: String = null, nameSv_Istartswith: String = null, nameEn: String = null, nameEn_Icontains: String = null, nameEn_Istartswith: String = null): ApplicationRoundTypeConnection
  reservations(
    offset: Int = null
    before: String = null
    after: String = null
    first: Int = null
    last: Int = null
    begin: DateTime = null
    end: DateTime = null
    state: [String] = null
    requested: Boolean = null

    """Järjestys"""
    orderBy: String = null
  ): ReservationTypeConnection
  reservationByPk(pk: Int = null): ReservationType
  reservationCancelReasons(offset: Int = null, before: String = null, after: String = null, first: Int = null, last: Int = null, reason: String = null): ReservationCancelReasonTypeConnection
  reservationDenyReasons(offset: Int = null, before: String = null, after: String = null, first: Int = null, last: Int = null, reason: String = null): ReservationDenyReasonTypeConnection
  reservationUnits(
    offset: Int = null
    before: String = null
    after: String = null
    first: Int = null
    last: Int = null
    pk: [ID] = null
    unit: [ID] = null
    keywordGroups: [ID] = null
    reservationUnitType: [ID] = null
    maxPersonsGte: Float = null
    maxPersonsLte: Float = null
    textSearch: String = null
    purposes: [ID] = null
    isDraft: Boolean = null
    isVisible: Boolean = null
    applicationRound: [ID] = null

    """Järjestys"""
    orderBy: String = null
  ): ReservationUnitTypeConnection
  reservationUnit(
    """The ID of the object"""
    id: ID!
  ): ReservationUnitType
  reservationUnitByPk(pk: Int = null): ReservationUnitByPkType
  reservationUnitCancellationRules(offset: Int = null, before: String = null, after: String = null, first: Int = null, last: Int = null, name: String = null): ReservationUnitCancellationRuleTypeConnection
  reservationUnitTypes(offset: Int = null, before: String = null, after: String = null, first: Int = null, last: Int = null, nameFi: String = null, nameEn: String = null, nameSv: String = null): ReservationUnitTypeTypeConnection
  resources(offset: Int = null, before: String = null, after: String = null, first: Int = null, last: Int = null, nameFi: String = null, nameFi_Icontains: String = null, nameFi_Istartswith: String = null, nameSv: String = null, nameSv_Icontains: String = null, nameSv_Istartswith: String = null, nameEn: String = null, nameEn_Icontains: String = null, nameEn_Istartswith: String = null): ResourceTypeConnection
  resource(
    """The ID of the object"""
    id: ID!
  ): ResourceType
  resourceByPk(pk: Int = null): ResourceType
  equipments(offset: Int = null, before: String = null, after: String = null, first: Int = null, last: Int = null, nameFi: String = null, nameFi_Icontains: String = null, nameFi_Istartswith: String = null, nameSv: String = null, nameSv_Icontains: String = null, nameSv_Istartswith: String = null, nameEn: String = null, nameEn_Icontains: String = null, nameEn_Istartswith: String = null): EquipmentTypeConnection
  equipment(
    """The ID of the object"""
    id: ID!
  ): EquipmentType
  equipmentByPk(pk: Int = null): EquipmentType
  equipmentCategories(offset: Int = null, before: String = null, after: String = null, first: Int = null, last: Int = null, nameFi: String = null, nameFi_Icontains: String = null, nameFi_Istartswith: String = null, nameSv: String = null, nameSv_Icontains: String = null, nameSv_Istartswith: String = null, nameEn: String = null, nameEn_Icontains: String = null, nameEn_Istartswith: String = null): EquipmentCategoryTypeConnection
  equipmentCategory(
    """The ID of the object"""
    id: ID!
  ): EquipmentCategoryType
  equipmentCategoryByPk(pk: Int = null): EquipmentCategoryType
  spaces(offset: Int = null, before: String = null, after: String = null, first: Int = null, last: Int = null, nameFi: String = null, nameFi_Icontains: String = null, nameFi_Istartswith: String = null, nameSv: String = null, nameSv_Icontains: String = null, nameSv_Istartswith: String = null, nameEn: String = null, nameEn_Icontains: String = null, nameEn_Istartswith: String = null): SpaceTypeConnection
  space(
    """The ID of the object"""
    id: ID!
  ): SpaceType
  spaceByPk(pk: Int = null): SpaceType
  units(offset: Int = null, before: String = null, after: String = null, first: Int = null, last: Int = null, nameFi: String = null, nameFi_Icontains: String = null, nameFi_Istartswith: String = null, nameSv: String = null, nameSv_Icontains: String = null, nameSv_Istartswith: String = null, nameEn: String = null, nameEn_Icontains: String = null, nameEn_Istartswith: String = null): UnitTypeConnection
  unit(
    """The ID of the object"""
    id: ID!
  ): UnitType
  unitByPk(pk: Int = null): UnitByPkType
  keywordCategories(offset: Int = null, before: String = null, after: String = null, first: Int = null, last: Int = null, nameFi: String = null, nameSv: String = null, nameEn: String = null): KeywordCategoryTypeConnection
  keywordGroups(offset: Int = null, before: String = null, after: String = null, first: Int = null, last: Int = null, nameFi: String = null, nameSv: String = null, nameEn: String = null): KeywordGroupTypeConnection
  keywords(offset: Int = null, before: String = null, after: String = null, first: Int = null, last: Int = null, nameFi: String = null, nameSv: String = null, nameEn: String = null): KeywordTypeConnection
  purposes(offset: Int = null, before: String = null, after: String = null, first: Int = null, last: Int = null, nameFi: String = null, nameEn: String = null, nameSv: String = null): PurposeTypeConnection
  reservationPurposes(offset: Int = null, before: String = null, after: String = null, first: Int = null, last: Int = null, nameFi: String = null, nameEn: String = null, nameSv: String = null): ReservationPurposeTypeConnection
  termsOfUse(offset: Int = null, before: String = null, after: String = null, first: Int = null, last: Int = null, termsType: String = null): TermsOfUseTypeConnection
  taxPercentages(offset: Int = null, before: String = null, after: String = null, first: Int = null, last: Int = null, value: Float = null): TaxPercentageTypeConnection
  ageGroups(offset: Int = null, before: String = null, after: String = null, first: Int = null, last: Int = null): AgeGroupTypeConnection
  cities(offset: Int = null, before: String = null, after: String = null, first: Int = null, last: Int = null): CityTypeConnection
  metadataSets(offset: Int = null, before: String = null, after: String = null, first: Int = null, last: Int = null): ReservationMetadataSetTypeConnection
}

type RealEstateType implements Node {
  nameFi: String
  nameEn: String
  nameSv: String
  district: DistrictType
  surfaceArea: Decimal

  """The ID of the object"""
  id: ID!
  pk: Int
}

type RecurringReservationType {
  user: String
  ageGroup: AgeGroupType
  abilityGroup: AbilityGroupType
  pk: Int
  applicationPk: Int
  applicationEventPk: Int
}

input ReservationApproveMutationInput {
  pk: Int

  """Additional information for approval."""
  handlingDetails: String

  """The price of this particular reservation"""
  price: Float!
  clientMutationId: String
}

type ReservationApproveMutationPayload {
  pk: Int
  state: state

  """Additional information for approval."""
  handlingDetails: String

  """When this reservation was handled."""
  handledAt: DateTime

  """The price of this particular reservation"""
  price: Float

  """May contain more than one error for same field."""
  errors: [ErrorType]
  clientMutationId: String
}

input ReservationCancellationMutationInput {
  pk: Int!

  """Primary key for the pre-defined cancel reason."""
  cancelReasonPk: Int!

  """Additional information for the cancellation."""
  cancelDetails: String
  clientMutationId: String
}

type ReservationCancellationMutationPayload {
  pk: Int

  """Primary key for the pre-defined cancel reason."""
  cancelReasonPk: Int

  """Additional information for the cancellation."""
  cancelDetails: String
  state: state

  """May contain more than one error for same field."""
  errors: [ErrorType]
  clientMutationId: String
}

type ReservationCancelReasonType implements Node {
  reason: String!
  reasonFi: String
  reasonEn: String
  reasonSv: String

  """The ID of the object"""
  id: ID!
  pk: Int
}

type ReservationCancelReasonTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ReservationCancelReasonTypeEdge]!
}

"""
A Relay edge containing a `ReservationCancelReasonType` and its cursor.
"""
type ReservationCancelReasonTypeEdge {
  """The item at the end of the edge"""
  node: ReservationCancelReasonType

  """A cursor for use in pagination"""
  cursor: String!
}

input ReservationConfirmMutationInput {
  pk: Int!
  clientMutationId: String
}

type ReservationConfirmMutationPayload {
  pk: Int
  reserveeFirstName: String
  reserveeLastName: String
  reserveePhone: String
  reserveeOrganisationName: String
  reserveeAddressStreet: String
  reserveeAddressCity: String
  reserveeAddressZip: String
  reserveeEmail: String

  """
  Type of the reservee. Possible values are BUSINESS, NONPROFIT, INDIVIDUAL.
  """
  reserveeType: String

  """Reservee's business or association identity code"""
  reserveeId: String
  reserveeIsUnregisteredAssociation: Boolean
  homeCityPk: Int
  applyingForFreeOfCharge: Boolean
  freeOfChargeReason: String
  ageGroupPk: Int
  billingFirstName: String
  billingLastName: String
  billingAddressStreet: String
  billingAddressCity: String
  billingAddressZip: String
  billingPhone: String
  billingEmail: String
  numPersons: Int
  name: String
  description: String

  """
  String value for ReservationType's ReservationState enum. Possible values are
  CREATED, CANCELLED, REQUIRES_HANDLING, CONFIRMED, DENIED.
  """
  state: String
  priority: Int
  begin: DateTime
  end: DateTime
  bufferTimeBefore: Int
  bufferTimeAfter: Int
  purposePk: Int
  confirmedAt: DateTime

  """The price of this particular reservation"""
  unitPrice: Float

  """The value of the tax percentage for this particular reservation"""
  taxPercentageValue: Float

  """The price of this particular reservation"""
  price: Float

  """May contain more than one error for same field."""
  errors: [ErrorType]
  clientMutationId: String
}

input ReservationCreateMutationInput {
  reserveeFirstName: String
  reserveeLastName: String
  reserveePhone: String
  reserveeOrganisationName: String
  reserveeAddressStreet: String
  reserveeAddressCity: String
  reserveeAddressZip: String
  reserveeEmail: String

  """
  Type of the reservee. Possible values are BUSINESS, NONPROFIT, INDIVIDUAL.
  """
  reserveeType: String

  """Reservee's business or association identity code"""
  reserveeId: String
  reserveeIsUnregisteredAssociation: Boolean
  homeCityPk: Int
  applyingForFreeOfCharge: Boolean
  freeOfChargeReason: String
  ageGroupPk: Int
  billingFirstName: String
  billingLastName: String
  billingAddressStreet: String
  billingAddressCity: String
  billingAddressZip: String
  billingPhone: String
  billingEmail: String
  numPersons: Int
  name: String
  description: String
  priority: Int
  begin: DateTime!
  end: DateTime!
  bufferTimeBefore: Int
  bufferTimeAfter: Int
  reservationUnitPks: [Int]!
  purposePk: Int
  clientMutationId: String
}

type ReservationCreateMutationPayload {
  pk: Int
  reserveeFirstName: String
  reserveeLastName: String
  reserveePhone: String
  reserveeOrganisationName: String
  reserveeAddressStreet: String
  reserveeAddressCity: String
  reserveeAddressZip: String
  reserveeEmail: String

  """
  Type of the reservee. Possible values are BUSINESS, NONPROFIT, INDIVIDUAL.
  """
  reserveeType: String

  """Reservee's business or association identity code"""
  reserveeId: String
  reserveeIsUnregisteredAssociation: Boolean
  homeCityPk: Int
  applyingForFreeOfCharge: Boolean
  freeOfChargeReason: String
  ageGroupPk: Int
  billingFirstName: String
  billingLastName: String
  billingAddressStreet: String
  billingAddressCity: String
  billingAddressZip: String
  billingPhone: String
  billingEmail: String
  numPersons: Int
  name: String
  description: String

  """Read only string value for ReservationType's ReservationState enum."""
  state: String
  priority: Int
  begin: DateTime
  end: DateTime
  bufferTimeBefore: Int
  bufferTimeAfter: Int
  purposePk: Int
  confirmedAt: DateTime

  """The price of this particular reservation"""
  unitPrice: Float

  """The value of the tax percentage for this particular reservation"""
  taxPercentageValue: Float

  """The price of this particular reservation"""
  price: Float

  """May contain more than one error for same field."""
  errors: [ErrorType]
  reservation: ReservationType
  clientMutationId: String
}

input ReservationDenyMutationInput {
  pk: Int

  """Additional information for denying."""
  handlingDetails: String

  """Primary key for the pre-defined deny reason."""
  denyReasonPk: Int!
  clientMutationId: String
}

type ReservationDenyMutationPayload {
  pk: Int
  state: state

  """Additional information for denying."""
  handlingDetails: String

  """When this reservation was handled."""
  handledAt: DateTime

  """Primary key for the pre-defined deny reason."""
  denyReasonPk: Int

  """May contain more than one error for same field."""
  errors: [ErrorType]
  clientMutationId: String
}

type ReservationDenyReasonType implements Node {
  reason: String!
  reasonFi: String
  reasonEn: String
  reasonSv: String

  """The ID of the object"""
  id: ID!
  pk: Int
}

type ReservationDenyReasonTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ReservationDenyReasonTypeEdge]!
}

"""A Relay edge containing a `ReservationDenyReasonType` and its cursor."""
type ReservationDenyReasonTypeEdge {
  """The item at the end of the edge"""
  node: ReservationDenyReasonType

  """A cursor for use in pagination"""
  cursor: String!
}

type ReservationMetadataSetType implements Node {
  name: String!
  supportedFields: [String]
  requiredFields: [String]

  """The ID of the object"""
  id: ID!
  pk: Int
}

type ReservationMetadataSetTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ReservationMetadataSetTypeEdge]!
}

"""A Relay edge containing a `ReservationMetadataSetType` and its cursor."""
type ReservationMetadataSetTypeEdge {
  """The item at the end of the edge"""
  node: ReservationMetadataSetType

  """A cursor for use in pagination"""
  cursor: String!
}

type ReservationPurposeType implements Node {
  nameFi: String
  nameEn: String
  nameSv: String

  """The ID of the object"""
  id: ID!
  pk: Int
}

type ReservationPurposeTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ReservationPurposeTypeEdge]!
}

"""A Relay edge containing a `ReservationPurposeType` and its cursor."""
type ReservationPurposeTypeEdge {
  """The item at the end of the edge"""
  node: ReservationPurposeType

  """A cursor for use in pagination"""
  cursor: String!
}

input ReservationRequiresHandlingMutationInput {
  pk: Int
  clientMutationId: String
}

type ReservationRequiresHandlingMutationPayload {
  pk: Int
  state: state

  """May contain more than one error for same field."""
  errors: [ErrorType]
  clientMutationId: String
}

"""An enumeration."""
enum ReservationsReservationPriorityChoices {
  """Low"""
  A_100

  """Medium"""
  A_200

  """High"""
  A_300
}

"""An enumeration."""
enum ReservationsReservationReserveeTypeChoices {
  """Business"""
  BUSINESS

  """Nonprofit"""
  NONPROFIT

  """Individual"""
  INDIVIDUAL
}

"""An enumeration."""
enum ReservationsReservationStateChoices {
  """created"""
  CREATED

  """cancelled"""
  CANCELLED

  """requires_handling"""
  REQUIRES_HANDLING

  """confirmed"""
  CONFIRMED

  """denied"""
  DENIED
}

type ReservationType implements Node {
  """Type of reservee"""
  reserveeType: ReservationsReservationReserveeTypeChoices
  reserveeFirstName: String
  reserveeLastName: String
  reserveeOrganisationName: String!
  reserveePhone: String
  reserveeEmail: String

  """Reservee's business or association identity code"""
  reserveeId: String!
  reserveeIsUnregisteredAssociation: Boolean!
  reserveeAddressStreet: String!
  reserveeAddressCity: String!
  reserveeAddressZip: String!
  billingFirstName: String!
  billingLastName: String!
  billingPhone: String!
  billingEmail: String
  billingAddressStreet: String!
  billingAddressCity: String!
  billingAddressZip: String!

  """Home city of the group or association"""
  homeCity: CityType
  ageGroup: AgeGroupType
  applyingForFreeOfCharge: Boolean!
  freeOfChargeReason: String
  name: String
  description: String
  state: ReservationsReservationStateChoices!
  priority: ReservationsReservationPriorityChoices!
  user: String
  begin: DateTime!
  end: DateTime!
  bufferTimeBefore: Duration
  bufferTimeAfter: Duration
  recurringReservation: RecurringReservationType
  numPersons: Int
  purpose: ReservationPurposeType
  cancelDetails: String!
  unitPrice: Float
  taxPercentageValue: Decimal
  price: Float

  """Working memo for staff users."""
  workingMemo: String

  """The ID of the object"""
  id: ID!
  pk: Int
  reservationUnits: [ReservationUnitType]
  calendarUrl: String
}

type ReservationTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ReservationTypeEdge]!
  totalCount: Int
}

"""A Relay edge containing a `ReservationType` and its cursor."""
type ReservationTypeEdge {
  """The item at the end of the edge"""
  node: ReservationType

  """A cursor for use in pagination"""
  cursor: String!
}

type ReservationUnitByPkType implements Node {
  nameFi: String
  nameEn: String
  nameSv: String
  descriptionFi: String
  descriptionEn: String
  descriptionSv: String
  spaces: [SpaceType]
  resources: [ResourceType]
  services: [ServiceType]
  purposes: [PurposeType]
  reservationUnitType: ReservationUnitTypeType
  requireIntroduction: Boolean!
  termsOfUseFi: String
  termsOfUseEn: String
  termsOfUseSv: String
  additionalInstructionsFi: String
  additionalInstructionsEn: String
  additionalInstructionsSv: String
  contactInformation: String!
  maxReservationDuration: Duration
  minReservationDuration: Duration
  uuid: UUID!
  isDraft: Boolean!
  maxPersons: Int
  bufferTimeBefore: Duration
  bufferTimeAfter: Duration

  """Unit of the price"""
  priceUnit: ReservationUnitsReservationUnitPriceUnitChoices!

  """Minimum price of the reservation unit"""
  lowestPrice: Decimal!

  """Maximum price of the reservation unit"""
  highestPrice: Decimal!
  taxPercentage: TaxPercentageType

  """
  Determines the interval for the start time of the reservation. For example an
  interval of 15 minutes means a reservation can begin at minutes 15, 30, 60, or
  90. Possible values are interval_15_mins, interval_30_mins, interval_60_mins,
  interval_90_mins.
  """
  reservationStartInterval: ReservationUnitsReservationUnitReservationStartIntervalChoices!

  """
  Time when making reservations become possible for this reservation unit.
  """
  reservationBegins: DateTime

  """
  Time when making reservations become not possible for this reservation unit
  """
  reservationEnds: DateTime

  """Time after this reservation unit should be publicly visible in UI."""
  publishBegins: DateTime

  """Time after this reservation unit should not be publicly visible in UI."""
  publishEnds: DateTime
  metadataSet: ReservationMetadataSetType
  maxReservationsPerUser: Int

  """
  Does reservations of this reservation unit need to be handled before they're confirmed.
  """
  requireReservationHandling: Boolean!

  """Authentication required for reserving this reservation unit."""
  authentication: ReservationUnitsReservationUnitAuthenticationChoices!
  images: [ReservationUnitImageType]

  """The ID of the object"""
  id: ID!
  openingHours(openingTimes: Boolean = null, periods: Boolean = null, startDate: Date = null, endDate: Date = null): OpeningHoursType
  pk: Int
  location: LocationType
  equipment: [EquipmentType]
  unit: UnitType
  surfaceArea: Decimal
  keywordGroups: [KeywordGroupType]
  reservations(from: Date = null, to: Date = null, state: [String] = null): [ReservationType]
  applicationRounds(active: Boolean = null): [ApplicationRoundType]
  cancellationRule: ReservationUnitCancellationRuleType
  paymentTerms: TermsOfUseType
  cancellationTerms: TermsOfUseType
  serviceSpecificTerms: TermsOfUseType
  nextAvailableSlot: DateTime
  haukiUrl: ReservationUnitHaukiUrlType
}

type ReservationUnitCancellationRuleType implements Node {
  nameFi: String
  nameEn: String
  nameSv: String

  """
  Seconds before reservations related to this cancellation rule can be cancelled without handling.
  """
  canBeCancelledTimeBefore: Float
  needsHandling: Boolean!

  """The ID of the object"""
  id: ID!
  pk: Int
}

type ReservationUnitCancellationRuleTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ReservationUnitCancellationRuleTypeEdge]!
}

"""
A Relay edge containing a `ReservationUnitCancellationRuleType` and its cursor.
"""
type ReservationUnitCancellationRuleTypeEdge {
  """The item at the end of the edge"""
  node: ReservationUnitCancellationRuleType

  """A cursor for use in pagination"""
  cursor: String!
}

input ReservationUnitCreateMutationInput {
  """
  Determines if introduction is required in order to reserve this reservation unit.
  """
  requireIntroduction: Boolean
  maxPersons: Int
  equipmentPks: [Int]
  unitPk: Int

  """Contact information for this reservation unit."""
  contactInformation: String
  maxReservationDuration: Int
  minReservationDuration: Int
  isDraft: Boolean
  spacePks: [Int]
  resourcePks: [Int]
  purposePks: [Int]
  servicePks: [Int]
  reservationUnitTypePk: Int
  surfaceArea: Float
  bufferTimeBefore: Int
  bufferTimeAfter: Int
  cancellationRulePk: Int
  paymentTermsPk: String
  cancellationTermsPk: String
  serviceSpecificTermsPk: String

  """Minimum price of the reservation unit"""
  lowestPrice: Float

  """Maximum price of the reservation unit"""
  highestPrice: Float

  """
  Unit of the price. Possible values are PER_15_MINS, PER_30_MINS, PER_HOUR, PER_HALF_DAY, PER_DAY, PER_WEEK, FIXED.
  """
  priceUnit: String

  """
  Determines the interval for the start time of the reservation. For example an
  interval of 15 minutes means a reservation can begin at minutes 0, 15, 30, or
  45. Possible values are INTERVAL_15_MINS, INTERVAL_30_MINS, INTERVAL_60_MINS,
  INTERVAL_90_MINS.
  """
  reservationStartInterval: String
  taxPercentagePk: Int

  """
  Time when making reservations become possible for this reservation unit.
  """
  reservationBegins: DateTime

  """
  Time when making reservations become not possible for this reservation unit
  """
  reservationEnds: DateTime

  """Time after this reservation unit should be publicly visible in UI."""
  publishBegins: DateTime

  """Time after this reservation unit should not be publicly visible in UI."""
  publishEnds: DateTime
  metadataSetPk: Int
  maxReservationsPerUser: Int

  """
  Does reservations of this reservation unit need to be handled before they're confirmed.
  """
  requireReservationHandling: Boolean

  """
  Authentication required for reserving this reservation unit. Possible values are WEAK, STRONG.
  """
  authentication: String
  descriptionFi: String
  descriptionEn: String
  descriptionSv: String
  nameFi: String
  nameEn: String
  nameSv: String
  termsOfUseFi: String
  termsOfUseEn: String
  termsOfUseSv: String
  additionalInstructionsFi: String
  additionalInstructionsEn: String
  additionalInstructionsSv: String
  clientMutationId: String
}

type ReservationUnitCreateMutationPayload {
  pk: Int

  """Spaces included in the reservation unit as nested related objects."""
  spaces: [SpaceType]

  """Resources included in the reservation unit as nested related objects."""
  resources: [ResourceType]

  """Services included in the reservation unit as nested related objects."""
  services: [ServiceType]

  """
  Determines if introduction is required in order to reserve this reservation unit.
  """
  requireIntroduction: Boolean
  purposes: [ReservationPurposeType]

  """Images of the reservation unit as nested related objects. """
  images: [ReservationUnitImageType]

  """
  Location of this reservation unit. Dynamically determined from spaces of the reservation unit.
  """
  location: String
  maxPersons: Int

  """Type of the reservation unit as nested related object."""
  reservationUnitType: ReservationUnitTypeType
  building: String
  unitPk: Int
  uuid: String

  """Contact information for this reservation unit."""
  contactInformation: String
  maxReservationDuration: Int
  minReservationDuration: Int
  isDraft: Boolean
  reservationUnitTypePk: Int
  surfaceArea: Float
  bufferTimeBefore: Int
  bufferTimeAfter: Int
  cancellationRulePk: Int

  """Minimum price of the reservation unit"""
  lowestPrice: Float

  """Maximum price of the reservation unit"""
  highestPrice: Float

  """
  Unit of the price. Possible values are PER_15_MINS, PER_30_MINS, PER_HOUR, PER_HALF_DAY, PER_DAY, PER_WEEK, FIXED.
  """
  priceUnit: String

  """
  Determines the interval for the start time of the reservation. For example an
  interval of 15 minutes means a reservation can begin at minutes 0, 15, 30, or
  45. Possible values are INTERVAL_15_MINS, INTERVAL_30_MINS, INTERVAL_60_MINS,
  INTERVAL_90_MINS.
  """
  reservationStartInterval: String

  """
  Time when making reservations become possible for this reservation unit.
  """
  reservationBegins: DateTime

  """
  Time when making reservations become not possible for this reservation unit
  """
  reservationEnds: DateTime

  """Time after this reservation unit should be publicly visible in UI."""
  publishBegins: DateTime

  """Time after this reservation unit should not be publicly visible in UI."""
  publishEnds: DateTime
  maxReservationsPerUser: Int

  """
  Does reservations of this reservation unit need to be handled before they're confirmed.
  """
  requireReservationHandling: Boolean

  """
  Authentication required for reserving this reservation unit. Possible values are WEAK, STRONG.
  """
  authentication: String
  descriptionFi: String
  descriptionEn: String
  descriptionSv: String
  nameFi: String
  nameEn: String
  nameSv: String
  termsOfUseFi: String
  termsOfUseEn: String
  termsOfUseSv: String
  additionalInstructionsFi: String
  additionalInstructionsEn: String
  additionalInstructionsSv: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  reservationUnit: ReservationUnitType
  clientMutationId: String
}

type ReservationUnitHaukiUrlType {
  url: String
}

input ReservationUnitImageCreateMutationInput {
  image: Upload
  reservationUnitPk: Int!

  """
  Type of image. Value is one of image_type enum values: MAIN, GROUND_PLAN, MAP, OTHER.
  """
  imageType: String!
  clientMutationId: String
}

type ReservationUnitImageCreateMutationPayload {
  pk: Int
  reservationUnitPk: Int

  """
  Type of image. Value is one of image_type enum values: MAIN, GROUND_PLAN, MAP, OTHER.
  """
  imageType: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  reservationUnitImage: ReservationUnitImageType
  clientMutationId: String
}

input ReservationUnitImageDeleteMutationInput {
  pk: Int!
  clientMutationId: String
}

type ReservationUnitImageDeleteMutationPayload {
  deleted: Boolean
  errors: String
  clientMutationId: String
}

type ReservationUnitImageType {
  imageType: ReservationUnitsReservationUnitImageImageTypeChoices!
  pk: Int
  imageUrl: String
  mediumUrl: String
  smallUrl: String
  largeUrl: String
}

input ReservationUnitImageUpdateMutationInput {
  pk: Int!

  """
  Type of image. Value is one of image_type enum values: MAIN, GROUND_PLAN, MAP, OTHER.
  """
  imageType: String
  clientMutationId: String
}

type ReservationUnitImageUpdateMutationPayload {
  pk: Int
  reservationUnitPk: Int

  """
  Type of image. Value is one of image_type enum values: MAIN, GROUND_PLAN, MAP, OTHER.
  """
  imageType: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  reservationUnitImage: ReservationUnitImageType
  clientMutationId: String
}

"""An enumeration."""
enum ReservationUnitsReservationUnitAuthenticationChoices {
  """Weak"""
  WEAK

  """Strong"""
  STRONG
}

"""An enumeration."""
enum ReservationUnitsReservationUnitImageImageTypeChoices {
  """Main image"""
  MAIN

  """Ground plan"""
  GROUND_PLAN

  """Map"""
  MAP

  """Other"""
  OTHER
}

"""An enumeration."""
enum ReservationUnitsReservationUnitPriceUnitChoices {
  """per 15 minutes"""
  PER_15_MINS

  """per 30 minutes"""
  PER_30_MINS

  """per hour"""
  PER_HOUR

  """per half a day"""
  PER_HALF_DAY

  """per day"""
  PER_DAY

  """per week"""
  PER_WEEK

  """fixed"""
  FIXED
}

"""An enumeration."""
enum ReservationUnitsReservationUnitReservationStartIntervalChoices {
  """15 minutes"""
  INTERVAL_15_MINS

  """30 minutes"""
  INTERVAL_30_MINS

  """60 minutes"""
  INTERVAL_60_MINS

  """90 minutes"""
  INTERVAL_90_MINS
}

type ReservationUnitType implements Node {
  nameFi: String
  nameEn: String
  nameSv: String
  descriptionFi: String
  descriptionEn: String
  descriptionSv: String
  spaces: [SpaceType]
  resources: [ResourceType]
  services: [ServiceType]
  purposes: [PurposeType]
  reservationUnitType: ReservationUnitTypeType
  requireIntroduction: Boolean!
  termsOfUseFi: String
  termsOfUseEn: String
  termsOfUseSv: String
  paymentTerms: TermsOfUseType
  cancellationTerms: TermsOfUseType
  serviceSpecificTerms: TermsOfUseType
  additionalInstructionsFi: String
  additionalInstructionsEn: String
  additionalInstructionsSv: String
  contactInformation: String!
  maxReservationDuration: Duration
  minReservationDuration: Duration
  uuid: UUID!
  isDraft: Boolean!
  maxPersons: Int
  surfaceArea: Decimal
  bufferTimeBefore: Duration
  bufferTimeAfter: Duration
  cancellationRule: ReservationUnitCancellationRuleType

  """Unit of the price"""
  priceUnit: ReservationUnitsReservationUnitPriceUnitChoices!

  """Minimum price of the reservation unit"""
  lowestPrice: Decimal!

  """Maximum price of the reservation unit"""
  highestPrice: Decimal!
  taxPercentage: TaxPercentageType

  """
  Determines the interval for the start time of the reservation. For example an
  interval of 15 minutes means a reservation can begin at minutes 15, 30, 60, or
  90. Possible values are interval_15_mins, interval_30_mins, interval_60_mins,
  interval_90_mins.
  """
  reservationStartInterval: ReservationUnitsReservationUnitReservationStartIntervalChoices!

  """
  Time when making reservations become possible for this reservation unit.
  """
  reservationBegins: DateTime

  """
  Time when making reservations become not possible for this reservation unit
  """
  reservationEnds: DateTime

  """Time after this reservation unit should be publicly visible in UI."""
  publishBegins: DateTime

  """Time after this reservation unit should not be publicly visible in UI."""
  publishEnds: DateTime
  metadataSet: ReservationMetadataSetType
  maxReservationsPerUser: Int

  """
  Does reservations of this reservation unit need to be handled before they're confirmed.
  """
  requireReservationHandling: Boolean!

  """Authentication required for reserving this reservation unit."""
  authentication: ReservationUnitsReservationUnitAuthenticationChoices!
  images: [ReservationUnitImageType]
  applicationRounds(active: Boolean = null): [ApplicationRoundType]

  """The ID of the object"""
  id: ID!
  pk: Int
  location: LocationType
  equipment: [EquipmentType]
  unit: UnitType
  keywordGroups: [KeywordGroupType]
  reservations(from: Date = null, to: Date = null, state: [String] = null): [ReservationType]
}

type ReservationUnitTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ReservationUnitTypeEdge]!
}

"""A Relay edge containing a `ReservationUnitType` and its cursor."""
type ReservationUnitTypeEdge {
  """The item at the end of the edge"""
  node: ReservationUnitType

  """A cursor for use in pagination"""
  cursor: String!
}

type ReservationUnitTypeType implements Node {
  nameFi: String
  nameEn: String
  nameSv: String

  """The ID of the object"""
  id: ID!
  pk: Int
}

type ReservationUnitTypeTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ReservationUnitTypeTypeEdge]!
}

"""A Relay edge containing a `ReservationUnitTypeType` and its cursor."""
type ReservationUnitTypeTypeEdge {
  """The item at the end of the edge"""
  node: ReservationUnitTypeType

  """A cursor for use in pagination"""
  cursor: String!
}

input ReservationUnitUpdateMutationInput {
  pk: Int!

  """
  Determines if introduction is required in order to reserve this reservation unit.
  """
  requireIntroduction: Boolean
  maxPersons: Int
  equipmentPks: [Int]
  unitPk: Int

  """Contact information for this reservation unit."""
  contactInformation: String
  maxReservationDuration: Int
  minReservationDuration: Int
  isDraft: Boolean
  spacePks: [Int]
  resourcePks: [Int]
  purposePks: [Int]
  servicePks: [Int]
  reservationUnitTypePk: Int
  surfaceArea: Float
  bufferTimeBefore: Int
  bufferTimeAfter: Int
  cancellationRulePk: Int
  paymentTermsPk: String
  cancellationTermsPk: String
  serviceSpecificTermsPk: String

  """Minimum price of the reservation unit"""
  lowestPrice: Float

  """Maximum price of the reservation unit"""
  highestPrice: Float

  """
  Unit of the price. Possible values are PER_15_MINS, PER_30_MINS, PER_HOUR, PER_HALF_DAY, PER_DAY, PER_WEEK, FIXED.
  """
  priceUnit: String

  """
  Determines the interval for the start time of the reservation. For example an
  interval of 15 minutes means a reservation can begin at minutes 0, 15, 30, or
  45. Possible values are INTERVAL_15_MINS, INTERVAL_30_MINS, INTERVAL_60_MINS,
  INTERVAL_90_MINS.
  """
  reservationStartInterval: String
  taxPercentagePk: Int

  """
  Time when making reservations become possible for this reservation unit.
  """
  reservationBegins: DateTime

  """
  Time when making reservations become not possible for this reservation unit
  """
  reservationEnds: DateTime

  """Time after this reservation unit should be publicly visible in UI."""
  publishBegins: DateTime

  """Time after this reservation unit should not be publicly visible in UI."""
  publishEnds: DateTime
  metadataSetPk: Int
  maxReservationsPerUser: Int

  """
  Does reservations of this reservation unit need to be handled before they're confirmed.
  """
  requireReservationHandling: Boolean

  """
  Authentication required for reserving this reservation unit. Possible values are WEAK, STRONG.
  """
  authentication: String
  descriptionFi: String
  descriptionEn: String
  descriptionSv: String
  nameFi: String
  nameEn: String
  nameSv: String
  termsOfUseFi: String
  termsOfUseEn: String
  termsOfUseSv: String
  additionalInstructionsFi: String
  additionalInstructionsEn: String
  additionalInstructionsSv: String
  clientMutationId: String
}

type ReservationUnitUpdateMutationPayload {
  pk: Int

  """Spaces included in the reservation unit as nested related objects."""
  spaces: [SpaceType]

  """Resources included in the reservation unit as nested related objects."""
  resources: [ResourceType]

  """Services included in the reservation unit as nested related objects."""
  services: [ServiceType]

  """
  Determines if introduction is required in order to reserve this reservation unit.
  """
  requireIntroduction: Boolean
  purposes: [ReservationPurposeType]

  """Images of the reservation unit as nested related objects. """
  images: [ReservationUnitImageType]

  """
  Location of this reservation unit. Dynamically determined from spaces of the reservation unit.
  """
  location: String
  maxPersons: Int

  """Type of the reservation unit as nested related object."""
  reservationUnitType: ReservationUnitTypeType
  building: String
  unitPk: Int
  uuid: String

  """Contact information for this reservation unit."""
  contactInformation: String
  maxReservationDuration: Int
  minReservationDuration: Int
  isDraft: Boolean
  reservationUnitTypePk: Int
  surfaceArea: Float
  bufferTimeBefore: Int
  bufferTimeAfter: Int
  cancellationRulePk: Int

  """Minimum price of the reservation unit"""
  lowestPrice: Float

  """Maximum price of the reservation unit"""
  highestPrice: Float

  """
  Unit of the price. Possible values are PER_15_MINS, PER_30_MINS, PER_HOUR, PER_HALF_DAY, PER_DAY, PER_WEEK, FIXED.
  """
  priceUnit: String

  """
  Determines the interval for the start time of the reservation. For example an
  interval of 15 minutes means a reservation can begin at minutes 0, 15, 30, or
  45. Possible values are INTERVAL_15_MINS, INTERVAL_30_MINS, INTERVAL_60_MINS,
  INTERVAL_90_MINS.
  """
  reservationStartInterval: String

  """
  Time when making reservations become possible for this reservation unit.
  """
  reservationBegins: DateTime

  """
  Time when making reservations become not possible for this reservation unit
  """
  reservationEnds: DateTime

  """Time after this reservation unit should be publicly visible in UI."""
  publishBegins: DateTime

  """Time after this reservation unit should not be publicly visible in UI."""
  publishEnds: DateTime
  maxReservationsPerUser: Int

  """
  Does reservations of this reservation unit need to be handled before they're confirmed.
  """
  requireReservationHandling: Boolean

  """
  Authentication required for reserving this reservation unit. Possible values are WEAK, STRONG.
  """
  authentication: String
  descriptionFi: String
  descriptionEn: String
  descriptionSv: String
  nameFi: String
  nameEn: String
  nameSv: String
  termsOfUseFi: String
  termsOfUseEn: String
  termsOfUseSv: String
  additionalInstructionsFi: String
  additionalInstructionsEn: String
  additionalInstructionsSv: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  reservationUnit: ReservationUnitType
  clientMutationId: String
}

input ReservationUpdateMutationInput {
  pk: Int!
  reserveeFirstName: String
  reserveeLastName: String
  reserveePhone: String
  reserveeOrganisationName: String
  reserveeAddressStreet: String
  reserveeAddressCity: String
  reserveeAddressZip: String
  reserveeEmail: String

  """
  Type of the reservee. Possible values are BUSINESS, NONPROFIT, INDIVIDUAL.
  """
  reserveeType: String

  """Reservee's business or association identity code"""
  reserveeId: String
  reserveeIsUnregisteredAssociation: Boolean
  homeCityPk: Int
  applyingForFreeOfCharge: Boolean
  freeOfChargeReason: String
  ageGroupPk: Int
  billingFirstName: String
  billingLastName: String
  billingAddressStreet: String
  billingAddressCity: String
  billingAddressZip: String
  billingPhone: String
  billingEmail: String
  numPersons: Int
  name: String
  description: String

  """
  String value for ReservationType's ReservationState enum. Possible values are
  CREATED, CANCELLED, REQUIRES_HANDLING, CONFIRMED, DENIED.
  """
  state: String
  priority: Int
  begin: DateTime
  end: DateTime
  bufferTimeBefore: Int
  bufferTimeAfter: Int
  reservationUnitPks: [Int]
  purposePk: Int
  clientMutationId: String
}

type ReservationUpdateMutationPayload {
  pk: Int
  reserveeFirstName: String
  reserveeLastName: String
  reserveePhone: String
  reserveeOrganisationName: String
  reserveeAddressStreet: String
  reserveeAddressCity: String
  reserveeAddressZip: String
  reserveeEmail: String

  """
  Type of the reservee. Possible values are BUSINESS, NONPROFIT, INDIVIDUAL.
  """
  reserveeType: String

  """Reservee's business or association identity code"""
  reserveeId: String
  reserveeIsUnregisteredAssociation: Boolean
  homeCityPk: Int
  applyingForFreeOfCharge: Boolean
  freeOfChargeReason: String
  ageGroupPk: Int
  billingFirstName: String
  billingLastName: String
  billingAddressStreet: String
  billingAddressCity: String
  billingAddressZip: String
  billingPhone: String
  billingEmail: String
  numPersons: Int
  name: String
  description: String

  """
  String value for ReservationType's ReservationState enum. Possible values are
  CREATED, CANCELLED, REQUIRES_HANDLING, CONFIRMED, DENIED.
  """
  state: String
  priority: Int
  begin: DateTime
  end: DateTime
  bufferTimeBefore: Int
  bufferTimeAfter: Int
  purposePk: Int
  confirmedAt: DateTime

  """The price of this particular reservation"""
  unitPrice: Float

  """The value of the tax percentage for this particular reservation"""
  taxPercentageValue: Float

  """The price of this particular reservation"""
  price: Float

  """May contain more than one error for same field."""
  errors: [ErrorType]
  reservation: ReservationType
  clientMutationId: String
}

input ReservationWorkingMemoMutationInput {
  """Primary key of the reservation"""
  pk: Int

  """Working memo for staff users."""
  workingMemo: String
  clientMutationId: String
}

type ReservationWorkingMemoMutationPayload {
  """Primary key of the reservation"""
  pk: Int

  """Working memo for staff users."""
  workingMemo: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  clientMutationId: String
}

input ResourceCreateMutationInput {
  locationType: String

  """PK of the related space for this resource."""
  spacePk: Int

  """
  Buffer time while reservation unit is unreservable before the reservation.
  Dynamically calculated from spaces and resources.
  """
  bufferTimeBefore: Int

  """
  Buffer time while reservation unit is unreservable after the reservation.
  Dynamically calculated from spaces and resources.
  """
  bufferTimeAfter: Int
  isDraft: Boolean
  nameFi: String
  nameEn: String
  nameSv: String
  descriptionFi: String
  descriptionEn: String
  descriptionSv: String
  clientMutationId: String
}

type ResourceCreateMutationPayload {
  pk: Int
  locationType: String

  """PK of the related space for this resource."""
  spacePk: Int

  """
  Buffer time while reservation unit is unreservable before the reservation.
  Dynamically calculated from spaces and resources.
  """
  bufferTimeBefore: Int

  """
  Buffer time while reservation unit is unreservable after the reservation.
  Dynamically calculated from spaces and resources.
  """
  bufferTimeAfter: Int
  isDraft: Boolean
  nameFi: String
  nameEn: String
  nameSv: String
  descriptionFi: String
  descriptionEn: String
  descriptionSv: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  resource: ResourceType
  clientMutationId: String
}

input ResourceDeleteMutationInput {
  pk: Int!
  clientMutationId: String
}

type ResourceDeleteMutationPayload {
  deleted: Boolean
  errors: String
  clientMutationId: String
}

"""An enumeration."""
enum ResourcesResourceLocationTypeChoices {
  """Fixed"""
  FIXED

  """Movable"""
  MOVABLE
}

type ResourceType implements Node {
  locationType: ResourcesResourceLocationTypeChoices!
  nameFi: String
  nameEn: String
  nameSv: String
  descriptionFi: String
  descriptionEn: String
  descriptionSv: String
  space: SpaceType
  bufferTimeBefore: Duration
  bufferTimeAfter: Duration
  isDraft: Boolean!

  """The ID of the object"""
  id: ID!
  pk: Int
  building: [BuildingType]
}

type ResourceTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ResourceTypeEdge]!
}

"""A Relay edge containing a `ResourceType` and its cursor."""
type ResourceTypeEdge {
  """The item at the end of the edge"""
  node: ResourceType

  """A cursor for use in pagination"""
  cursor: String!
}

input ResourceUpdateMutationInput {
  pk: Int!
  locationType: String

  """PK of the related space for this resource."""
  spacePk: Int

  """
  Buffer time while reservation unit is unreservable before the reservation.
  Dynamically calculated from spaces and resources.
  """
  bufferTimeBefore: Int

  """
  Buffer time while reservation unit is unreservable after the reservation.
  Dynamically calculated from spaces and resources.
  """
  bufferTimeAfter: Int
  isDraft: Boolean
  nameFi: String
  nameEn: String
  nameSv: String
  descriptionFi: String
  descriptionEn: String
  descriptionSv: String
  clientMutationId: String
}

type ResourceUpdateMutationPayload {
  pk: Int
  locationType: String

  """PK of the related space for this resource."""
  spacePk: Int

  """
  Buffer time while reservation unit is unreservable before the reservation.
  Dynamically calculated from spaces and resources.
  """
  bufferTimeBefore: Int

  """
  Buffer time while reservation unit is unreservable after the reservation.
  Dynamically calculated from spaces and resources.
  """
  bufferTimeAfter: Int
  isDraft: Boolean
  nameFi: String
  nameEn: String
  nameSv: String
  descriptionFi: String
  descriptionEn: String
  descriptionSv: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  resource: ResourceType
  clientMutationId: String
}

type ServiceSectorType implements Node {
  """The ID of the object"""
  id: ID!
  pk: Int
}

"""An enumeration."""
enum ServicesServiceServiceTypeChoices {
  """Introduction"""
  INTRODUCTION

  """Catering"""
  CATERING

  """Configuration"""
  CONFIGURATION
}

type ServiceType implements Node {
  nameFi: String
  nameEn: String
  nameSv: String
  serviceType: ServicesServiceServiceTypeChoices!
  bufferTimeBefore: Duration
  bufferTimeAfter: Duration

  """The ID of the object"""
  id: ID!
  pk: Int
}

input SpaceCreateMutationInput {
  """PK of the parent space for this space."""
  parentPk: Int

  """Surface area of the space as square meters"""
  surfaceArea: Float

  """PK of the district for this space."""
  districtPk: Int
  maxPersons: Int
  code: String
  unitPk: Int
  nameFi: String!
  nameEn: String
  nameSv: String
  clientMutationId: String
}

type SpaceCreateMutationPayload {
  pk: Int

  """PK of the parent space for this space."""
  parentPk: Int

  """Surface area of the space as square meters"""
  surfaceArea: Float

  """PK of the district for this space."""
  districtPk: Int
  maxPersons: Int
  code: String
  unitPk: Int
  nameFi: String
  nameEn: String
  nameSv: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  space: SpaceType
  clientMutationId: String
}

input SpaceDeleteMutationInput {
  pk: Int!
  clientMutationId: String
}

type SpaceDeleteMutationPayload {
  deleted: Boolean
  errors: String
  clientMutationId: String
}

type SpaceType implements Node {
  nameFi: String
  nameEn: String
  nameSv: String
  parent: SpaceType
  building: BuildingType
  unit: UnitByPkType
  surfaceArea: Float
  maxPersons: Int
  code: String!

  """The ID of the object"""
  id: ID!
  pk: Int
  children: [SpaceType]
  resources: [ResourceType]
}

type SpaceTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [SpaceTypeEdge]!
}

"""A Relay edge containing a `SpaceType` and its cursor."""
type SpaceTypeEdge {
  """The item at the end of the edge"""
  node: SpaceType

  """A cursor for use in pagination"""
  cursor: String!
}

input SpaceUpdateMutationInput {
  pk: Int!

  """PK of the parent space for this space."""
  parentPk: Int

  """Surface area of the space as square meters"""
  surfaceArea: Float

  """PK of the district for this space."""
  districtPk: Int
  maxPersons: Int
  code: String
  unitPk: Int
  nameFi: String
  nameEn: String
  nameSv: String
  clientMutationId: String
}

type SpaceUpdateMutationPayload {
  pk: Int

  """PK of the parent space for this space."""
  parentPk: Int

  """Surface area of the space as square meters"""
  surfaceArea: Float

  """PK of the district for this space."""
  districtPk: Int
  maxPersons: Int
  code: String
  unitPk: Int
  nameFi: String
  nameEn: String
  nameSv: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  space: SpaceType
  clientMutationId: String
}

"""An enumeration."""
enum state {
  """created"""
  CREATED

  """cancelled"""
  CANCELLED

  """requires_handling"""
  REQUIRES_HANDLING

  """confirmed"""
  CONFIRMED

  """denied"""
  DENIED
}

"""An enumeration."""
enum status {
  draft
  in_review
  review_done
  allocated
  handled
  validated
  approved
}

type TaxPercentageType implements Node {
  """The tax percentage for a price"""
  value: Decimal!

  """The ID of the object"""
  id: ID!
  pk: Int
}

type TaxPercentageTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [TaxPercentageTypeEdge]!
}

"""A Relay edge containing a `TaxPercentageType` and its cursor."""
type TaxPercentageTypeEdge {
  """The item at the end of the edge"""
  node: TaxPercentageType

  """A cursor for use in pagination"""
  cursor: String!
}

"""An enumeration."""
enum TermsOfUseTermsOfUseTermsTypeChoices {
  """Generic terms"""
  GENERIC_TERMS

  """Payment terms"""
  PAYMENT_TERMS

  """Cancellation terms"""
  CANCELLATION_TERMS

  """Recurring reservation terms"""
  RECURRING_TERMS

  """Service-specific terms"""
  SERVICE_TERMS
}

type TermsOfUseType implements Node {
  nameFi: String
  nameEn: String
  nameSv: String
  textFi: String
  textEn: String
  textSv: String
  termsType: TermsOfUseTermsOfUseTermsTypeChoices!

  """The ID of the object"""
  id: ID!
  pk: String
}

type TermsOfUseTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [TermsOfUseTypeEdge]!
}

"""A Relay edge containing a `TermsOfUseType` and its cursor."""
type TermsOfUseTypeEdge {
  """The item at the end of the edge"""
  node: TermsOfUseType

  """A cursor for use in pagination"""
  cursor: String!
}

"""
The `Time` scalar type represents a Time value as
specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar Time

type TimeSpanType {
  startTime: Time
  endTime: Time
  weekdays: [Int]
  resourceState: String
  endTimeOnNextDay: Boolean
  nameFi: String
  nameEn: String
  nameSv: String
  descriptionFi: String
  descriptionEn: String
  descriptionSv: String
}

type UnitByPkType implements Node {
  tprekId: String
  nameFi: String
  nameEn: String
  nameSv: String
  descriptionFi: String
  descriptionEn: String
  descriptionSv: String
  shortDescriptionFi: String
  shortDescriptionEn: String
  shortDescriptionSv: String
  webPage: String!
  email: String!
  phone: String!

  """The ID of the object"""
  id: ID!
  openingHours(openingTimes: Boolean = null, periods: Boolean = null, startDate: Date = null, endDate: Date = null): OpeningHoursType
  pk: Int
  reservationUnits: [ReservationUnitType]
  spaces: [SpaceType]
  location: LocationType
}

type UnitType implements Node {
  tprekId: String
  nameFi: String
  nameEn: String
  nameSv: String
  descriptionFi: String
  descriptionEn: String
  descriptionSv: String
  shortDescriptionFi: String
  shortDescriptionEn: String
  shortDescriptionSv: String
  webPage: String!
  email: String!
  phone: String!

  """The ID of the object"""
  id: ID!
  pk: Int
  reservationUnits: [ReservationUnitType]
  spaces: [SpaceType]
  location: LocationType
}

type UnitTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [UnitTypeEdge]!
}

"""A Relay edge containing a `UnitType` and its cursor."""
type UnitTypeEdge {
  """The item at the end of the edge"""
  node: UnitType

  """A cursor for use in pagination"""
  cursor: String!
}

input UnitUpdateMutationInput {
  pk: Int!
  tprekId: String
  webPage: String
  email: String
  phone: String
  shortDescriptionFi: String
  shortDescriptionEn: String
  shortDescriptionSv: String
  nameFi: String
  nameEn: String
  nameSv: String
  descriptionFi: String
  descriptionEn: String
  descriptionSv: String
  clientMutationId: String
}

type UnitUpdateMutationPayload {
  pk: Int
  tprekId: String
  webPage: String
  email: String
  phone: String
  shortDescriptionFi: String
  shortDescriptionEn: String
  shortDescriptionSv: String
  nameFi: String
  nameEn: String
  nameSv: String
  descriptionFi: String
  descriptionEn: String
  descriptionSv: String

  """May contain more than one error for same field."""
  errors: [ErrorType]
  unit: UnitType
  clientMutationId: String
}

"""
Create scalar that ignores normal serialization/deserialization, since
that will be handled by the multipart request spec
"""
scalar Upload

"""
Leverages the internal Python implementation of UUID (uuid.UUID) to provide native UUID objects
in fields, resolvers and input.
"""
scalar UUID

