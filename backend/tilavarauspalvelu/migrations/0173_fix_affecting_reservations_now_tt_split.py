# Generated by Django 5.1.8 on 2025-06-12 07:28 (This is just a copy of 0148, to fix MATERIALIZED VIEW in stage/prod)
from __future__ import annotations

from inspect import cleandoc

from django.conf import settings
from django.db import migrations


def remove_affecting_reservations() -> str:
    return cleandoc(
        """
        DROP INDEX IF EXISTS idx_buffered_end_datetime;
        DROP INDEX IF EXISTS idx_buffered_start_datetime;
        DROP INDEX IF EXISTS idx_affected_reservation_unit_ids;
        DROP INDEX IF EXISTS idx_reservation_id;
        DROP MATERIALIZED VIEW IF EXISTS affecting_time_spans;
        """
    )


def create_affecting_reservations() -> str:
    now_func = "NOW_TT()" if settings.ENABLE_NOW_TT else "STATEMENT_TIMESTAMP()"

    # "SELECT 1;" for syntax highlighting
    return cleandoc(
        f"""
        SELECT 1;

        CREATE MATERIALIZED VIEW affecting_time_spans AS
             SELECT
                 res.reservation_id,
                 array_agg(res.ru_id ORDER BY res.ru_id) AS affected_reservation_unit_ids,
                 res.buffered_start_datetime,
                 res.buffered_end_datetime,
                 res.buffer_time_before,
                 res.buffer_time_after,
                 res.is_blocking
             FROM (
                 SELECT DISTINCT
                     r.id as reservation_id,
                     unnest(ruh.related_reservation_unit_ids) as ru_id,
                     (r.begins_at - r.buffer_time_before) as buffered_start_datetime,
                     (r.ends_at + r.buffer_time_after) as buffered_end_datetime,
                     r.buffer_time_before as buffer_time_before,
                     r.buffer_time_after as buffer_time_after,
                     (CASE WHEN UPPER(r."type") = 'BLOCKED' THEN true ELSE false END) as is_blocking
                 FROM reservation r
                 INNER JOIN "reservation_unit_hierarchy" ruh ON r.reservation_unit_id = ruh.reservation_unit_id
                 WHERE (
                     -- Make use of reservation's index on 'ends_at', even if this fetches some past reservations
                     r.ends_at >= DATE_TRUNC('day', {now_func} - interval '1 day')
                     AND UPPER(r.state) IN ('CREATED', 'CONFIRMED', 'WAITING_FOR_PAYMENT', 'REQUIRES_HANDLING')
                 )
            ) res
            GROUP BY
                res.reservation_id,
                res.buffered_start_datetime,
                res.buffered_end_datetime,
                res.buffer_time_before,
                res.buffer_time_after,
                res.is_blocking
            ORDER BY res.buffered_start_datetime, res.reservation_id;

        CREATE UNIQUE INDEX idx_reservation_id ON affecting_time_spans (reservation_id);
        CREATE INDEX idx_affected_reservation_unit_ids on affecting_time_spans USING GIN (
            affected_reservation_unit_ids gin__int_ops
        );
        CREATE INDEX idx_buffered_start_datetime ON affecting_time_spans (buffered_start_datetime);
        CREATE INDEX idx_buffered_end_datetime ON affecting_time_spans (buffered_end_datetime);
        """  # noqa: S608
    )


class Migration(migrations.Migration):
    dependencies = [
        ("tilavarauspalvelu", "0172_nh3fields_update"),
    ]

    operations = [
        migrations.RunSQL(sql=remove_affecting_reservations(), reverse_sql=None),
        migrations.RunSQL(sql=create_affecting_reservations(), reverse_sql=None),
    ]
