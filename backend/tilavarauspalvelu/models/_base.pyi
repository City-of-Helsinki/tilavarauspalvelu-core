import datetime
from collections.abc import Collection, Iterable, Iterator, Mapping, Sequence
from typing import Any, Generic, Literal, Self, TypeVar

from django.db.models import Model, OrderBy, QuerySet
from django.db.models.manager import BaseManager
from django.db.models.sql import Query
from mptt.managers import TreeManager
from mptt.models import MPTTModel
from mptt.querysets import TreeQuerySet

_TModel = TypeVar("_TModel", bound=Model)
_TMPTTModel = TypeVar("_TMPTTModel", bound=MPTTModel)
_TQuerySet = TypeVar("_TQuerySet", bound=QuerySet)

class ModelQuerySet(QuerySet[_TModel], Generic[_TModel]):  # noqa: UP046
    model: type[_TModel]
    query: Query
    _hints: dict[str, Any]
    _result_cache: list[_TModel] | None

    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[_TModel]: ...
    def __bool__(self) -> bool: ...
    def __class_getitem__(cls, item: type[_TModel]) -> Self: ...
    def __getstate__(self) -> dict[str, Any]: ...
    def __and__(self, other: Self) -> Self: ...
    def __or__(self, other: Self) -> Self: ...
    @classmethod
    def as_manager(cls) -> ModelManager[_TModel, Self]: ...
    def _fetch_all(self) -> None: ...
    def iterator(self, chunk_size: int | None = ...) -> Iterator[_TModel]: ...
    def aggregate(self, *args: Any, **kwargs: Any) -> dict[str, Any]: ...
    def count(self) -> int: ...
    def get(self, *args: Any, **kwargs: Any) -> _TModel: ...
    def create(self, **kwargs: Any) -> _TModel: ...
    def bulk_create(
        self,
        objs: Iterable[_TModel],
        batch_size: int | None = ...,
        ignore_conflicts: bool = ...,
        update_conflicts: bool = ...,
        update_fields: Collection[str] | None = ...,
        unique_fields: Collection[str] | None = ...,
    ) -> list[_TModel]: ...
    def bulk_update(
        self,
        objs: Iterable[_TModel],
        fields: Iterable[str],
        batch_size: int | None = ...,
    ) -> int: ...
    def get_or_create(
        self,
        defaults: Mapping[str, Any] | None = ...,
        **kwargs: Any,
    ) -> tuple[_TModel, bool]: ...
    def update_or_create(
        self,
        defaults: Mapping[str, Any] | None = ...,
        create_defaults: Mapping[str, Any] | None = ...,
        **kwargs: Any,
    ) -> tuple[_TModel, bool]: ...
    def earliest(self, *fields: str | OrderBy) -> _TModel: ...
    def latest(self, *fields: str | OrderBy) -> _TModel: ...
    def first(self) -> _TModel | None: ...
    def last(self) -> _TModel | None: ...
    def in_bulk(self, id_list: Iterable[Any] | None = ..., *, field_name: str = ...) -> dict[Any, _TModel]: ...
    def delete(self) -> int: ...
    def update(self, **kwargs: Any) -> int: ...
    def exists(self) -> bool: ...
    def explain(self, *, format: Any | None = ..., **options: Any) -> str: ...  # noqa: A002
    def contains(self, obj: _TModel) -> bool: ...
    def values(self, *fields: str, **expressions: Any) -> Self: ...
    def values_list(self, *fields: str, flat: bool = ..., named: bool = ...) -> Self: ...
    def dates(self, field_name: str, kind: str, order: str = ...) -> Self: ...
    def datetimes(
        self,
        field_name: str,
        kind: str,
        order: str = ...,
        tzinfo: datetime.tzinfo | None = ...,
    ) -> Self: ...
    def none(self) -> Self: ...
    def all(self) -> Self: ...
    def filter(self, *args: Any, **kwargs: Any) -> Self: ...
    def exclude(self, *args: Any, **kwargs: Any) -> Self: ...
    def complex_filter(self, filter_obj: Any) -> Self: ...
    def union(self, *other_qs: Self, all: bool = ...) -> Self: ...  # noqa: A002
    def intersection(self, *other_qs: Self) -> Self: ...
    def difference(self, *other_qs: Self) -> Self: ...
    def select_for_update(
        self, nowait: bool = ..., skip_locked: bool = ..., of: Sequence[str] = ..., no_key: bool = ...
    ) -> Self: ...
    def select_related(self, *fields: Any) -> Self: ...
    def prefetch_related(self, *lookups: Any) -> Self: ...
    def annotate(self, *args: Any, **kwargs: Any) -> Self: ...
    def alias(self, *args: Any, **kwargs: Any) -> Self: ...
    def order_by(self, *field_names: Any) -> Self: ...
    def distinct(self, *field_names: Any) -> Self: ...
    def reverse(self) -> Self: ...
    def defer(self, *fields: Any) -> Self: ...
    def only(self, *fields: Any) -> Self: ...
    def using(self, alias: str | None) -> Self: ...

class ModelManager(BaseManager[_TModel], Generic[_TModel, _TQuerySet]):  # noqa: UP046
    model: type[_TModel]
    name: str
    creation_counter: int
    auto_created: bool
    use_in_migrations: bool
    _queryset_class: type[_TQuerySet]

    def __class_getitem__(cls, *args: Any, **kwargs: Any) -> type[Self]: ...
    def get_queryset(self) -> _TQuerySet: ...
    def iterator(self, chunk_size: int | None = ...) -> Iterator[_TModel]: ...
    def aggregate(self, *args: Any, **kwargs: Any) -> dict[str, Any]: ...
    def count(self) -> int: ...
    def get(self, *args: Any, **kwargs: Any) -> _TModel: ...
    def create(self, **kwargs: Any) -> _TModel: ...
    def bulk_create(
        self,
        objs: Iterable[_TModel],
        batch_size: int | None = ...,
        ignore_conflicts: bool = ...,
        update_conflicts: bool = ...,
        update_fields: Collection[str] | None = ...,
        unique_fields: Collection[str] | None = ...,
    ) -> list[_TModel]: ...
    def bulk_update(
        self,
        objs: Iterable[_TModel],
        fields: Iterable[str],
        batch_size: int | None = ...,
    ) -> int: ...
    def get_or_create(
        self,
        defaults: Mapping[str, Any] | None = ...,
        **kwargs: Any,
    ) -> tuple[_TModel, bool]: ...
    def update_or_create(
        self,
        defaults: Mapping[str, Any] | None = ...,
        create_defaults: Mapping[str, Any] | None = ...,
        **kwargs: Any,
    ) -> tuple[_TModel, bool]: ...
    def earliest(self, *fields: str | OrderBy) -> _TModel: ...
    def latest(self, *fields: str | OrderBy) -> _TModel: ...
    def first(self) -> _TModel | None: ...
    def last(self) -> _TModel | None: ...
    def in_bulk(self, id_list: Iterable[Any] | None = ..., *, field_name: str = ...) -> dict[Any, _TModel]: ...
    def delete(self) -> int: ...
    def update(self, **kwargs: Any) -> int: ...
    def exists(self) -> bool: ...
    def explain(self, *, format: Any | None = ..., **options: Any) -> str: ...  # noqa: A002
    def contains(self, obj: _TModel) -> bool: ...
    def values(self, *fields: str, **expressions: Any) -> _TQuerySet: ...
    def values_list(self, *fields: str, flat: bool = ..., named: bool = ...) -> _TQuerySet: ...
    def dates(self, field_name: str, kind: str, order: str = ...) -> _TQuerySet: ...
    def datetimes(
        self,
        field_name: str,
        kind: str,
        order: str = ...,
        tzinfo: datetime.tzinfo | None = ...,
    ) -> _TQuerySet: ...
    def none(self) -> _TQuerySet: ...
    def all(self) -> _TQuerySet: ...
    def filter(self, *args: Any, **kwargs: Any) -> _TQuerySet: ...
    def exclude(self, *args: Any, **kwargs: Any) -> _TQuerySet: ...
    def complex_filter(self, filter_obj: Any) -> _TQuerySet: ...
    def union(self, *other_qs: _TQuerySet, all: bool = ...) -> _TQuerySet: ...  # noqa: A002
    def intersection(self, *other_qs: _TQuerySet) -> _TQuerySet: ...
    def difference(self, *other_qs: _TQuerySet) -> _TQuerySet: ...
    def select_for_update(
        self, nowait: bool = ..., skip_locked: bool = ..., of: Sequence[str] = ..., no_key: bool = ...
    ) -> _TQuerySet: ...
    def select_related(self, *fields: Any) -> _TQuerySet: ...
    def prefetch_related(self, *lookups: Any) -> _TQuerySet: ...
    def annotate(self, *args: Any, **kwargs: Any) -> _TQuerySet: ...
    def alias(self, *args: Any, **kwargs: Any) -> _TQuerySet: ...
    def order_by(self, *field_names: Any) -> _TQuerySet: ...
    def distinct(self, *field_names: Any) -> _TQuerySet: ...
    def reverse(self) -> _TQuerySet: ...
    def defer(self, *fields: Any) -> _TQuerySet: ...
    def only(self, *fields: Any) -> _TQuerySet: ...
    def using(self, alias: str | None) -> _TQuerySet: ...

class OneToManyRelatedManager(ModelManager[_TModel, _TQuerySet]):
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def add(self, *objs: _TModel | int, bulk: bool = ...) -> int: ...
    def remove(self, *obj: _TModel | int, bulk: bool = ...) -> _TModel: ...
    def clear(self, *, clear: bool = ...) -> None: ...
    def set(
        self,
        objs: Iterable[_TModel | int],
        *,
        bulk: bool = ...,
        clear: bool = ...,
    ) -> None: ...

class ManyToManyRelatedManager(ModelManager[_TModel, _TQuerySet]):
    through: type[Model]

    def add(
        self,
        *objs: _TModel | int,
        through_defaults: Mapping[str, Any] | None = ...,
    ) -> None: ...
    def remove(self, obj: _TModel | int) -> None: ...
    def clear(self) -> None: ...
    def set(
        self,
        objs: Iterable[_TModel | int],
        *,
        clear: bool = ...,
        through_defaults: Mapping[str, Any] | None = ...,
    ) -> None: ...
    def create(
        self,
        through_defaults: Mapping[str, Any] | None = ...,
        **kwargs: Any,
    ) -> _TModel: ...
    def get_or_create(
        self,
        defaults: Mapping[str, Any] | None = ...,
        through_defaults: Mapping[str, Any] | None = ...,
        **kwargs: Any,
    ) -> tuple[_TModel, bool]: ...
    def update_or_create(
        self,
        defaults: Mapping[str, Any] | None = ...,
        create_defaults: Mapping[str, Any] | None = ...,
        through_defaults: Mapping[str, Any] | None = ...,
        **kwargs: Any,
    ) -> tuple[_TModel, bool]: ...

type TreePos = Literal["first-child", "last-child", "left", "right"]

class ModelTreeQuerySet(ModelQuerySet[_TMPTTModel], TreeQuerySet[_TMPTTModel], Generic[_TMPTTModel]):  # noqa: UP046
    def get_descendants(self, *args: Any, **kwargs: Any) -> Self: ...
    def get_ancestors(self, *args: Any, **kwargs: Any) -> Self: ...
    def get_cached_trees(self) -> list[_TMPTTModel]: ...

class ModelTreeManager[TMPTTModel: MPTTModel, TQuerySet: QuerySet](
    ModelManager[TMPTTModel, TQuerySet],
    TreeManager[TMPTTModel],
):
    def get_queryset_descendants(self, queryset: _TQuerySet, include_self: bool = False) -> _TQuerySet: ...
    def get_queryset_ancestors(self, queryset: _TQuerySet, include_self: bool = False) -> _TQuerySet: ...
    @property
    def parent_attr(self) -> str: ...
    @property
    def left_attr(self) -> str: ...
    @property
    def right_attr(self) -> str: ...
    @property
    def tree_id_attr(self) -> str: ...
    @property
    def level_attr(self) -> str: ...
    def insert_node(
        self,
        node: _TMPTTModel,
        target: _TMPTTModel,
        position: TreePos = "last-child",
        save: bool = False,
        allow_existing_pk: bool = False,
        refresh_target: bool = True,
    ) -> _TMPTTModel: ...
    def move_node(
        self,
        node: _TMPTTModel,
        target: _TMPTTModel,
        position: TreePos = "last-child",
    ) -> _TMPTTModel | None: ...
    def root_node(self, tree_id: int) -> _TMPTTModel: ...
    def root_nodes(self) -> _TQuerySet: ...
    def rebuild(self, batch_size: int = 1000, **filters: Any) -> None: ...
    def partial_rebuild(self, tree_id: int, batch_size: int = 1000, **filters: Any) -> None: ...
    def build_tree_nodes(
        self,
        data: dict[str, Any],
        target: _TMPTTModel | None = None,
        position: TreePos = "last-child",
    ) -> list[_TMPTTModel]: ...
